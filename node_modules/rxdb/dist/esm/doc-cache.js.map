{"version":3,"file":"doc-cache.js","names":["getFromMapOrThrow","getHeightOfRevision","overwriteGetterForCaching","requestIdlePromiseNoQueue","overwritable","DocumentCache","primaryPath","changes$","documentCreator","cacheItemByDocId","Map","tasks","Set","registry","FinalizationRegistry","docMeta","docId","cacheItem","get","delete","revisionHeight","lwt","size","undefined","subscribe","events","add","index","length","event","documentId","documentData","previousDocumentData","then","processTasks","_proto","prototype","Array","from","forEach","task","clear","getLatestDocumentData","getLatestDocumentDataIfExists","_createClass","key","fn","getCachedRxDocumentMonad","doc","docCache","deepFreezeWhenDevMode","docsData","ret","registryTasks","docData","_rev","byRev","cachedRxDocumentWeakRef","set","_meta","cachedRxDocument","deref","createWeakRefWithFallback","push","register","primary","revision","_data","mapDocumentsDataToCacheDocs","getCachedRxDocuments","HAS_WEAK_REF","WeakRef","createWeakRef","createWeakRefFallback","obj"],"sources":["../../src/doc-cache.ts"],"sourcesContent":["import type {\n    RxDocument,\n    RxDocumentData,\n    RxStorageChangeEvent\n} from './types/index.d.ts';\nimport {\n    getFromMapOrThrow,\n    getHeightOfRevision,\n    overwriteGetterForCaching,\n    requestIdlePromiseNoQueue\n} from './plugins/utils/index.ts';\nimport {\n    overwritable\n} from './overwritable.ts';\nimport { Observable } from 'rxjs';\n\n/**\n * Because we have to create many cache items,\n * we use an array instead of an object with properties\n * for better performance and less memory usage.\n * @link https://stackoverflow.com/questions/17295056/array-vs-object-efficiency-in-javascript\n */\ndeclare type CacheItem<RxDocType, OrmMethods> = [\n    /**\n     * Store the different document states of time\n     * based on their [revisionHeight+_meta.lwt] .\n     * We store WeakRefs so that we can later clean up\n     * document states that are no longer needed.\n     *\n     * Notice that we can not only rely on the revisionHeight\n     * because when cleanup is used, two document states can end up with\n     * the same revision but different _meta.lwt.\n     */\n    Map<string, WeakRef<RxDocument<RxDocType, OrmMethods>>>,\n\n    /**\n     * Store the latest known document state.\n     * As long as any state of the document is in the cache,\n     * we observe the changestream and update the latestDoc accordingly.\n     * This makes it easier to optimize performance on other parts\n     * because for each known document we can always get the current state\n     * in the storage.\n     * Also it makes it possible to call RxDocument.latest() in a non-async way\n     * to retrieve the latest document state or to observe$ some property.\n     *\n     * To not prevent the whole cacheItem from being garbage collected,\n     * we store only the document data here, but not the RxDocument.\n     */\n    RxDocumentData<RxDocType>\n];\n\n\n/**\n * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n */\ndeclare type FinalizationRegistryValue = {\n    docId: string;\n    revisionHeight: number;\n    lwt: number;\n};\n\n/**\n * The DocumentCache stores RxDocument objects\n * by their primary key and revision.\n * This is useful on client side applications where\n * it is not known how much memory can be used, so\n * we de-duplicate RxDocument states to save memory.\n * To not fill up the memory with old document states, the DocumentCache\n * only contains weak references to the RxDocuments themself.\n * @link https://caniuse.com/?search=weakref\n */\nexport class DocumentCache<RxDocType, OrmMethods> {\n    public readonly cacheItemByDocId = new Map<string, CacheItem<RxDocType, OrmMethods>>();\n\n    /**\n     * Process stuff lazy to not block the CPU\n     * on critical paths.\n     */\n    public readonly tasks = new Set<Function>();\n\n    /**\n     * Some JavaScript runtimes like QuickJS,\n     * so not have a FinalizationRegistry or WeakRef.\n     * Therefore we need a workaround which might waste a lot of memory,\n     * but at least works.\n     */\n    public readonly registry?: FinalizationRegistry<FinalizationRegistryValue> = typeof FinalizationRegistry === 'function' ?\n        new FinalizationRegistry<FinalizationRegistryValue>(docMeta => {\n            const docId = docMeta.docId;\n            const cacheItem = this.cacheItemByDocId.get(docId);\n            if (cacheItem) {\n                cacheItem[0].delete(docMeta.revisionHeight + docMeta.lwt + '');\n                if (cacheItem[0].size === 0) {\n                    /**\n                     * No state of the document is cached anymore,\n                     * so we can clean up.\n                     */\n                    this.cacheItemByDocId.delete(docId);\n                }\n            }\n        }) :\n        undefined;\n\n    constructor(\n        public readonly primaryPath: string,\n        public readonly changes$: Observable<RxStorageChangeEvent<RxDocType>[]>,\n        /**\n         * A method that can create a RxDocument by the given document data.\n         */\n        public documentCreator: (docData: RxDocumentData<RxDocType>) => RxDocument<RxDocType, OrmMethods>\n    ) {\n        changes$.subscribe(events => {\n            this.tasks.add(() => {\n                const cacheItemByDocId = this.cacheItemByDocId;\n                for (let index = 0; index < events.length; index++) {\n                    const event = events[index];\n                    const cacheItem = cacheItemByDocId.get(event.documentId);\n                    if (cacheItem) {\n                        let documentData = event.documentData;\n                        if (!documentData) {\n                            documentData = event.previousDocumentData as any;\n                        }\n                        cacheItem[1] = documentData;\n                    }\n                }\n            });\n            if (this.tasks.size <= 1) {\n                requestIdlePromiseNoQueue().then(() => {\n                    this.processTasks();\n                });\n            }\n        });\n    }\n\n    public processTasks() {\n        if (this.tasks.size === 0) {\n            return;\n        }\n        const tasks = Array.from(this.tasks);\n        tasks.forEach(task => task());\n        this.tasks.clear();\n    }\n\n    /**\n     * Get the RxDocument from the cache\n     * and create a new one if not exits before.\n     * @overwrites itself with the actual function\n     * because this is @performance relevant.\n     * It is called on each document row for each write and read.\n     */\n    get getCachedRxDocuments(): (docsData: RxDocumentData<RxDocType>[]) => RxDocument<RxDocType, OrmMethods>[] {\n        const fn = getCachedRxDocumentMonad(this);\n        return overwriteGetterForCaching(\n            this,\n            'getCachedRxDocuments',\n            fn\n        );\n    }\n\n    get getCachedRxDocument(): (docData: RxDocumentData<RxDocType>) => RxDocument<RxDocType, OrmMethods> {\n        const fn = getCachedRxDocumentMonad(this);\n        return overwriteGetterForCaching(\n            this,\n            'getCachedRxDocument',\n            doc => fn([doc])[0]\n        );\n    }\n\n    /**\n     * Throws if not exists\n     */\n    public getLatestDocumentData(docId: string): RxDocumentData<RxDocType> {\n        this.processTasks();\n        const cacheItem = getFromMapOrThrow(this.cacheItemByDocId, docId);\n        return cacheItem[1];\n    }\n\n    public getLatestDocumentDataIfExists(docId: string): RxDocumentData<RxDocType> | undefined {\n        this.processTasks();\n        const cacheItem = this.cacheItemByDocId.get(docId);\n        if (cacheItem) {\n            return cacheItem[1];\n        }\n    }\n}\n\n/**\n * This function is called very very often.\n * @hotPath This is one of the most important methods for performance.\n * It is used in many places to transform the raw document data into RxDocuments.\n */\nfunction getCachedRxDocumentMonad<RxDocType, OrmMethods>(\n    docCache: DocumentCache<RxDocType, OrmMethods>\n): (docsData: RxDocumentData<RxDocType>[]) => RxDocument<RxDocType, OrmMethods>[] {\n    const primaryPath = docCache.primaryPath;\n    const cacheItemByDocId = docCache.cacheItemByDocId;\n    const registry = docCache.registry;\n    const deepFreezeWhenDevMode = overwritable.deepFreezeWhenDevMode;\n    const documentCreator = docCache.documentCreator;\n    const fn: (docsData: RxDocumentData<RxDocType>[]) => RxDocument<RxDocType, OrmMethods>[] = (docsData: RxDocumentData<RxDocType>[]) => {\n        const ret: RxDocument<RxDocType, OrmMethods>[] = new Array(docsData.length);\n        const registryTasks: RxDocument<RxDocType, OrmMethods>[] = [];\n        for (let index = 0; index < docsData.length; index++) {\n            let docData = docsData[index];\n            const docId: string = (docData as any)[primaryPath];\n\n            const revisionHeight = getHeightOfRevision(docData._rev);\n\n            let byRev: Map<string, WeakRef<RxDocument<RxDocType, OrmMethods>>>;\n            let cachedRxDocumentWeakRef: WeakRef<RxDocument<RxDocType, OrmMethods>> | undefined;\n            let cacheItem = cacheItemByDocId.get(docId);\n            if (!cacheItem) {\n                byRev = new Map();\n                cacheItem = [\n                    byRev,\n                    docData\n                ];\n                cacheItemByDocId.set(docId, cacheItem);\n            } else {\n                byRev = cacheItem[0];\n                cachedRxDocumentWeakRef = byRev.get(revisionHeight + docData._meta.lwt + '');\n            }\n            let cachedRxDocument = cachedRxDocumentWeakRef ? cachedRxDocumentWeakRef.deref() : undefined;\n            if (!cachedRxDocument) {\n                docData = deepFreezeWhenDevMode(docData) as any;\n                cachedRxDocument = documentCreator(docData) as RxDocument<RxDocType, OrmMethods>;\n                byRev.set(revisionHeight + docData._meta.lwt + '', createWeakRefWithFallback(cachedRxDocument));\n                if (registry) {\n                    registryTasks.push(cachedRxDocument);\n                }\n            }\n            ret[index] = cachedRxDocument;\n        }\n        if (registryTasks.length > 0 && registry) {\n            /**\n             * Calling registry.register() has shown to have\n             * really bad performance. So we add the cached documents\n             * lazily.\n             */\n            docCache.tasks.add(() => {\n                for (let index = 0; index < registryTasks.length; index++) {\n                    const doc = registryTasks[index];\n                    registry.register(doc, {\n                        docId: doc.primary,\n                        revisionHeight: getHeightOfRevision(doc.revision),\n                        lwt: doc._data._meta.lwt\n                    });\n                }\n            });\n            if (docCache.tasks.size <= 1) {\n                requestIdlePromiseNoQueue().then(() => {\n                    docCache.processTasks();\n                });\n            }\n        }\n        return ret;\n    };\n    return fn;\n}\n\nexport function mapDocumentsDataToCacheDocs<RxDocType, OrmMethods>(\n    docCache: DocumentCache<RxDocType, OrmMethods>,\n    docsData: RxDocumentData<RxDocType>[]\n) {\n    const getCachedRxDocuments = docCache.getCachedRxDocuments;\n    return getCachedRxDocuments(docsData);\n}\n\n/**\n * Fallback for JavaScript runtimes that do not support WeakRef.\n * The fallback will keep the items in cache forever,\n * but at least works.\n */\nconst HAS_WEAK_REF = typeof WeakRef === 'function';\nconst createWeakRefWithFallback = HAS_WEAK_REF ? createWeakRef : createWeakRefFallback;\nfunction createWeakRef<T extends object>(obj: T): WeakRef<T> {\n    return new WeakRef(obj) as any;\n}\nfunction createWeakRefFallback<T extends object>(obj: T): WeakRef<T> {\n    return {\n        deref() {\n            return obj;\n        }\n    } as any;\n}\n"],"mappings":"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","ignoreList":[]}