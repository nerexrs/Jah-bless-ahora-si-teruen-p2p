{"version":3,"file":"rx-migration-state.js","names":["Subject","filter","firstValueFrom","map","shareReplay","isBulkWriteConflictError","newRxError","MIGRATION_DEFAULT_BATCH_SIZE","addMigrationStateToDatabase","getOldCollectionMeta","migrateDocumentData","mustMigrate","PROMISE_RESOLVE_TRUE","RXJS_SHARE_REPLAY_DEFAULTS","clone","deepEqual","ensureNotFalsy","errorToPlainJson","getDefaultRevision","getDefaultRxDocumentMeta","getSingleDocument","hasEncryption","observeSingle","writeSingle","BroadcastChannel","createLeaderElection","META_INSTANCE_SCHEMA_TITLE","awaitRxStorageReplicationFirstInSync","awaitRxStorageReplicationInSync","cancelRxStorageReplication","defaultConflictHandler","getRxReplicationMetaInstanceSchema","replicateRxStorageInstance","rxStorageInstanceToReplicationHandler","overwritable","INTERNAL_CONTEXT_MIGRATION_STATUS","addConnectedStorageToCollection","getPrimaryKeyOfInternalDocument","normalizeMangoQuery","prepareQuery","RxMigrationState","collection","migrationStrategies","statusDocKey","name","schema","version","join","started","canceled","updateStatusHandlers","updateStatusQueue","database","oldCollectionMeta","statusDocId","$","internalStore","pipe","d","data","_proto","prototype","getStatus","startMigration","batchSize","must","multiInstance","broadcastChannel","leaderElector","awaitLeadership","oldStorageInstance","storage","createStorageInstance","databaseName","collectionName","databaseInstanceToken","token","options","password","devMode","isDevMode","connectedInstances","getConnectedStorageInstances","totalCount","countAllDocuments","concat","r","oldStorage","updateStatus","s","count","total","Promise","all","connectedInstance","newStorage","migrateStorage","close","storageInstance","originalStorageInstance","err","status","error","previous","document","Object","assign","_deleted","isConflict","documentInDb","handler","push","then","length","useHandlers","newDoc","id","key","context","handled","percent","_meta","_rev","_attachments","oneHandler","Math","round","onClose","cancel","replicationMetaStorageInstance","replicationHandlerBase","replicationState","keepMeta","identifier","replicationHandler","masterChangesSince","resolve","checkpoint","documents","masterWrite","rows","migratedRows","row","newDocData","newDocumentState","title","docData","isCheckpoint","assumedMasterState","undefined","migratedDocData","newRow","result","masterChangeStream$","asObservable","forkInstance","metaInstance","pushBatchSize","pullBatchSize","conflictHandler","hashFunction","hasError","events","subscribe","processed","up","remove","storageInstances","ret","instance","preparedQuery","selector","countResult","connectedStorages","connectedStorage","Error","newSchema","jsonSchema","migratePromise","race"],"sources":["../../../../src/plugins/migration-schema/rx-migration-state.ts"],"sourcesContent":["import {\n    Observable,\n    Subject,\n    filter,\n    firstValueFrom,\n    map,\n    shareReplay\n} from 'rxjs';\nimport {\n    isBulkWriteConflictError,\n    newRxError\n} from '../../rx-error.ts';\nimport type {\n    InternalStoreCollectionDocType,\n    NumberFunctionMap,\n    RxCollection,\n    RxDatabase,\n    RxError,\n    RxReplicationWriteToMasterRow,\n    RxStorageInstance,\n    RxStorageInstanceReplicationState,\n    RxTypeError\n} from '../../types/index.d.ts';\nimport {\n    MIGRATION_DEFAULT_BATCH_SIZE,\n    addMigrationStateToDatabase,\n    getOldCollectionMeta,\n    migrateDocumentData,\n    mustMigrate\n} from './migration-helpers.ts';\nimport {\n    PROMISE_RESOLVE_TRUE,\n    RXJS_SHARE_REPLAY_DEFAULTS,\n    clone,\n    deepEqual,\n    ensureNotFalsy,\n    errorToPlainJson,\n    getDefaultRevision,\n    getDefaultRxDocumentMeta,\n    promiseWait\n} from '../utils/index.ts';\nimport type {\n    MigrationStatusUpdate,\n    RxMigrationStatus,\n    RxMigrationStatusDocument\n} from './migration-types.ts';\nimport {\n    getSingleDocument,\n    hasEncryption,\n    observeSingle,\n    writeSingle\n} from '../../rx-storage-helper.ts';\nimport {\n    BroadcastChannel,\n    createLeaderElection\n} from 'broadcast-channel';\nimport {\n    META_INSTANCE_SCHEMA_TITLE,\n    awaitRxStorageReplicationFirstInSync,\n    awaitRxStorageReplicationInSync,\n    cancelRxStorageReplication,\n    defaultConflictHandler,\n    getRxReplicationMetaInstanceSchema,\n    replicateRxStorageInstance,\n    rxStorageInstanceToReplicationHandler\n} from '../../replication-protocol/index.ts';\nimport { overwritable } from '../../overwritable.ts';\nimport {\n    INTERNAL_CONTEXT_MIGRATION_STATUS,\n    addConnectedStorageToCollection,\n    getPrimaryKeyOfInternalDocument\n} from '../../rx-database-internal-store.ts';\nimport { normalizeMangoQuery, prepareQuery } from '../../rx-query-helper.ts';\n\n\n\nexport class RxMigrationState {\n\n    public database: RxDatabase;\n\n\n    private started: boolean = false;\n    public readonly oldCollectionMeta: ReturnType<typeof getOldCollectionMeta>;\n    public readonly mustMigrate: ReturnType<typeof mustMigrate>;\n    public readonly statusDocId: string;\n    public readonly $: Observable<RxMigrationStatus>;\n    public replicationState?: RxStorageInstanceReplicationState<any>;\n    public canceled: boolean = false;\n    public broadcastChannel?: BroadcastChannel;\n    constructor(\n        public readonly collection: RxCollection,\n        public readonly migrationStrategies: NumberFunctionMap,\n        public readonly statusDocKey = [\n            collection.name,\n            'v',\n            collection.schema.version\n        ].join('-'),\n    ) {\n        this.database = collection.database;\n        this.oldCollectionMeta = getOldCollectionMeta(this);\n        this.mustMigrate = mustMigrate(this);\n        this.statusDocId = getPrimaryKeyOfInternalDocument(\n            this.statusDocKey,\n            INTERNAL_CONTEXT_MIGRATION_STATUS\n        );\n        addMigrationStateToDatabase(this);\n\n        this.$ = observeSingle<RxMigrationStatusDocument>(\n            this.database.internalStore,\n            this.statusDocId\n        ).pipe(\n            filter(d => !!d),\n            map(d => ensureNotFalsy(d).data),\n            shareReplay(RXJS_SHARE_REPLAY_DEFAULTS)\n        );\n    }\n\n    getStatus() {\n        return firstValueFrom(this.$);\n    }\n\n\n    /**\n     * Starts the migration.\n     * Returns void so that people to not get the idea to await\n     * this function.\n     * Instead use migratePromise() if you want to await\n     * the migration. This ensures it works even if the migration\n     * is run on a different browser tab.\n     */\n    async startMigration(batchSize: number = MIGRATION_DEFAULT_BATCH_SIZE): Promise<void> {\n        const must = await this.mustMigrate;\n        if (!must) {\n            return;\n        }\n        if (this.started) {\n            throw newRxError('DM1');\n        }\n        this.started = true;\n\n\n        /**\n         * To ensure that multiple tabs do not migrate the same collection,\n         * we use a new broadcastChannel/leaderElector for each collection.\n         * This is required because collections can be added dynamically and\n         * not all tabs might know about this collection.\n         */\n        if (this.database.multiInstance) {\n            this.broadcastChannel = new BroadcastChannel([\n                'rx-migration-state',\n                this.database.name,\n                this.collection.name,\n                this.collection.schema.version\n            ].join('|'));\n            const leaderElector = createLeaderElection(this.broadcastChannel);\n            await leaderElector.awaitLeadership();\n        }\n\n        /**\n         * Instead of writing a custom migration protocol,\n         * we do a push-only replication from the old collection data to the new one.\n         * This also ensure that restarting the replication works without problems.\n         */\n        const oldCollectionMeta = await this.oldCollectionMeta;\n        const oldStorageInstance = await this.database.storage.createStorageInstance({\n            databaseName: this.database.name,\n            collectionName: this.collection.name,\n            databaseInstanceToken: this.database.token,\n            multiInstance: this.database.multiInstance,\n            options: {},\n            schema: ensureNotFalsy(oldCollectionMeta).data.schema,\n            password: this.database.password,\n            devMode: overwritable.isDevMode()\n        });\n\n\n        const connectedInstances = await this.getConnectedStorageInstances();\n\n\n        /**\n         * Initially write the migration status into a meta document.\n         */\n        const totalCount = await this.countAllDocuments(\n            [oldStorageInstance].concat(connectedInstances.map(r => r.oldStorage))\n        );\n        await this.updateStatus(s => {\n            s.count.total = totalCount;\n            return s;\n        });\n\n\n        try {\n            /**\n             * First migrate the connected storages,\n             * afterwards migrate the normal collection.\n            */\n            await Promise.all(\n                connectedInstances.map(async (connectedInstance) => {\n                    await addConnectedStorageToCollection(\n                        this.collection,\n                        connectedInstance.newStorage.collectionName,\n                        connectedInstance.newStorage.schema\n                    );\n                    await this.migrateStorage(\n                        connectedInstance.oldStorage,\n                        connectedInstance.newStorage,\n                        batchSize\n                    );\n                    await connectedInstance.newStorage.close();\n                })\n            );\n\n            await this.migrateStorage(\n                oldStorageInstance,\n                /**\n                 * Use the originalStorageInstance here\n                 * so that the _meta.lwt time keeps the same\n                 * and our replication checkpoints still point to the\n                 * correct checkpoint.\n                */\n                this.collection.storageInstance.originalStorageInstance,\n                batchSize\n            );\n        } catch (err) {\n            await oldStorageInstance.close();\n            await this.updateStatus(s => {\n                s.status = 'ERROR';\n                s.error = errorToPlainJson(err as Error);\n                return s;\n            });\n            return;\n        }\n\n        // remove old collection meta doc\n        try {\n            await writeSingle(\n                this.database.internalStore,\n                {\n                    previous: oldCollectionMeta,\n                    document: Object.assign(\n                        {},\n                        oldCollectionMeta,\n                        {\n                            _deleted: true\n                        }\n                    )\n                },\n                'rx-migration-remove-collection-meta'\n            );\n        } catch (error) {\n            const isConflict = isBulkWriteConflictError<InternalStoreCollectionDocType>(error);\n            if (isConflict && !!isConflict.documentInDb._deleted) {\n            } else {\n                throw error;\n            }\n        }\n\n        await this.updateStatus(s => {\n            s.status = 'DONE';\n            return s;\n        });\n        if (this.broadcastChannel) {\n            await this.broadcastChannel.close();\n        }\n    }\n\n    public updateStatusHandlers: MigrationStatusUpdate[] = [];\n    public updateStatusQueue: Promise<any> = PROMISE_RESOLVE_TRUE;\n    public updateStatus(\n        handler: MigrationStatusUpdate\n    ) {\n        this.updateStatusHandlers.push(handler);\n        this.updateStatusQueue = this.updateStatusQueue.then(async () => {\n            if (this.updateStatusHandlers.length === 0) {\n                return;\n            }\n            // re-run until no conflict\n            const useHandlers = this.updateStatusHandlers;\n            this.updateStatusHandlers = [];\n            while (true) {\n                const previous = await getSingleDocument<RxMigrationStatusDocument>(\n                    this.database.internalStore,\n                    this.statusDocId\n                );\n                let newDoc = clone(previous);\n                if (!previous) {\n                    newDoc = {\n                        id: this.statusDocId,\n                        key: this.statusDocKey,\n                        context: INTERNAL_CONTEXT_MIGRATION_STATUS,\n                        data: {\n                            collectionName: this.collection.name,\n                            status: 'RUNNING',\n                            count: {\n                                total: 0,\n                                handled: 0,\n                                percent: 0\n                            }\n                        },\n                        _deleted: false,\n                        _meta: getDefaultRxDocumentMeta(),\n                        _rev: getDefaultRevision(),\n                        _attachments: {}\n                    };\n                }\n\n                let status = ensureNotFalsy(newDoc).data;\n                for (const oneHandler of useHandlers) {\n                    status = oneHandler(status);\n                }\n                status.count.percent = Math.round((status.count.handled / status.count.total) * 100);\n\n                if (\n                    newDoc && previous &&\n                    deepEqual(newDoc.data, previous.data)\n                ) {\n                    break;\n                }\n\n\n                try {\n                    await writeSingle<RxMigrationStatusDocument>(\n                        this.database.internalStore,\n                        {\n                            previous,\n                            document: ensureNotFalsy(newDoc)\n                        },\n                        INTERNAL_CONTEXT_MIGRATION_STATUS\n                    );\n\n                    // write successful\n                    break;\n                } catch (err) {\n                    // ignore conflicts\n                    if (!isBulkWriteConflictError(err)) {\n                        throw err;\n                    }\n                }\n            }\n        });\n        return this.updateStatusQueue;\n    }\n\n\n    public async migrateStorage(\n        oldStorage: RxStorageInstance<any, any, any>,\n        newStorage: RxStorageInstance<any, any, any>,\n        batchSize: number\n    ) {\n\n        this.collection.onClose.push(() => this.cancel());\n        this.database.onClose.push(() => this.cancel());\n        const replicationMetaStorageInstance = await this.database.storage.createStorageInstance({\n            databaseName: this.database.name,\n            collectionName: 'rx-migration-state-meta-' + oldStorage.collectionName + '-' + oldStorage.schema.version,\n            databaseInstanceToken: this.database.token,\n            multiInstance: this.database.multiInstance,\n            options: {},\n            schema: getRxReplicationMetaInstanceSchema(oldStorage.schema, hasEncryption(oldStorage.schema)),\n            password: this.database.password,\n            devMode: overwritable.isDevMode()\n        });\n\n        const replicationHandlerBase = rxStorageInstanceToReplicationHandler(\n            newStorage,\n            /**\n             * Ignore push-conflicts.\n             * If this happens we drop the 'old' document state.\n             */\n            defaultConflictHandler,\n            this.database.token,\n            true\n        );\n\n        const replicationState = replicateRxStorageInstance({\n            keepMeta: true,\n            identifier: [\n                'rx-migration-state',\n                oldStorage.collectionName,\n                oldStorage.schema.version,\n                this.collection.schema.version\n            ].join('-'),\n            replicationHandler: {\n                masterChangesSince() {\n                    return Promise.resolve({\n                        checkpoint: null,\n                        documents: []\n                    });\n                },\n                masterWrite: async (rows) => {\n                    let migratedRows = await Promise.all(\n                        rows\n                            .map(async (row) => {\n                                let newDocData = row.newDocumentState;\n                                if (newStorage.schema.title === META_INSTANCE_SCHEMA_TITLE) {\n                                    newDocData = row.newDocumentState.docData;\n                                    if (row.newDocumentState.isCheckpoint === '1') {\n                                        return {\n                                            assumedMasterState: undefined,\n                                            newDocumentState: row.newDocumentState\n                                        };\n                                    }\n                                }\n                                const migratedDocData: RxReplicationWriteToMasterRow<any> = await migrateDocumentData(\n                                    this.collection,\n                                    oldStorage.schema.version,\n                                    newDocData\n                                );\n\n                                /**\n                                 * The migration strategy can return null\n                                 * which means the document must be deleted during migration.\n                                 */\n                                if (migratedDocData === null) {\n                                    return null;\n                                }\n\n                                const newRow: RxReplicationWriteToMasterRow<any> = {\n                                    // drop the assumed master state, we do not have to care about conflicts here.\n                                    assumedMasterState: undefined,\n                                    newDocumentState: newStorage.schema.title === META_INSTANCE_SCHEMA_TITLE\n                                        ? Object.assign({}, row.newDocumentState, { docData: migratedDocData })\n                                        : migratedDocData\n                                };\n\n                                return newRow;\n                            })\n                    );\n\n                    // filter out the documents where the migration strategy returned null\n                    migratedRows = migratedRows.filter(row => !!row && !!row.newDocumentState);\n\n                    const result = await replicationHandlerBase.masterWrite(migratedRows as any);\n                    return result;\n                },\n                masterChangeStream$: new Subject<any>().asObservable()\n            },\n            forkInstance: oldStorage,\n            metaInstance: replicationMetaStorageInstance,\n            pushBatchSize: batchSize,\n            pullBatchSize: 0,\n            conflictHandler: defaultConflictHandler,\n            hashFunction: this.database.hashFunction\n        });\n\n\n        let hasError: RxError | RxTypeError | false = false;\n        replicationState.events.error.subscribe(err => hasError = err);\n\n        // update replication status on each change\n        replicationState.events.processed.up.subscribe(() => {\n            this.updateStatus(status => {\n                status.count.handled = status.count.handled + 1;\n                return status;\n            });\n        });\n\n        await awaitRxStorageReplicationFirstInSync(replicationState);\n        await awaitRxStorageReplicationInSync(replicationState);\n\n        await this.updateStatusQueue;\n        if (hasError) {\n            await replicationMetaStorageInstance.close();\n            throw hasError;\n        }\n\n        // cleanup old storages\n        await Promise.all([\n            oldStorage.remove(),\n            replicationMetaStorageInstance.remove()\n        ]);\n\n        await this.cancel();\n    }\n\n    /**\n     * Stops the migration.\n     * Mostly used in tests to simulate what happens\n     * when the user reloads the page during a migration.\n     */\n    public async cancel() {\n        this.canceled = true;\n        if (this.replicationState) {\n            await cancelRxStorageReplication(this.replicationState);\n        }\n        if (this.broadcastChannel) {\n            await this.broadcastChannel.close();\n        }\n    }\n\n    public async countAllDocuments(\n        storageInstances: RxStorageInstance<any, any, any>[]\n    ): Promise<number> {\n        let ret = 0;\n        await Promise.all(\n            storageInstances.map(async (instance) => {\n\n                const preparedQuery = prepareQuery(\n                    instance.schema,\n                    normalizeMangoQuery(\n                        instance.schema,\n                        {\n                            selector: {}\n                        }\n                    )\n                );\n                const countResult = await instance.count(preparedQuery);\n                ret += countResult.count;\n            })\n        );\n        return ret;\n    }\n\n    public async getConnectedStorageInstances() {\n        const oldCollectionMeta = ensureNotFalsy(await this.oldCollectionMeta);\n        const ret: {\n            oldStorage: RxStorageInstance<any, any, any>;\n            newStorage: RxStorageInstance<any, any, any>;\n        }[] = [];\n\n        await Promise.all(\n            await Promise.all(\n                oldCollectionMeta\n                    .data\n                    .connectedStorages\n                    .map(async (connectedStorage) => {\n\n                        // atm we can only migrate replication states.\n                        if (connectedStorage.schema.title !== META_INSTANCE_SCHEMA_TITLE) {\n                            throw new Error('unknown migration handling for schema');\n                        }\n\n                        const newSchema = getRxReplicationMetaInstanceSchema(\n                            clone(this.collection.schema.jsonSchema),\n                            hasEncryption(connectedStorage.schema)\n                        );\n                        newSchema.version = this.collection.schema.version;\n                        const [oldStorage, newStorage] = await Promise.all([\n                            this.database.storage.createStorageInstance({\n                                databaseInstanceToken: this.database.token,\n                                databaseName: this.database.name,\n                                devMode: overwritable.isDevMode(),\n                                multiInstance: this.database.multiInstance,\n                                options: {},\n                                schema: connectedStorage.schema,\n                                password: this.database.password,\n                                collectionName: connectedStorage.collectionName\n                            }),\n                            this.database.storage.createStorageInstance({\n                                databaseInstanceToken: this.database.token,\n                                databaseName: this.database.name,\n                                devMode: overwritable.isDevMode(),\n                                multiInstance: this.database.multiInstance,\n                                options: {},\n                                schema: newSchema,\n                                password: this.database.password,\n                                collectionName: connectedStorage.collectionName\n                            })\n                        ]);\n                        ret.push({ oldStorage, newStorage });\n                    })\n            )\n        );\n\n        return ret;\n    }\n\n\n\n    async migratePromise(batchSize?: number): Promise<RxMigrationStatus> {\n        this.startMigration(batchSize);\n        const must = await this.mustMigrate;\n        if (!must) {\n            return {\n                status: 'DONE',\n                collectionName: this.collection.name,\n                count: {\n                    handled: 0,\n                    percent: 0,\n                    total: 0\n                }\n            };\n        }\n\n        const result = await Promise.race([\n            firstValueFrom(\n                this.$.pipe(\n                    filter(d => d.status === 'DONE')\n                )\n            ),\n            firstValueFrom(\n                this.$.pipe(\n                    filter(d => d.status === 'ERROR')\n                )\n            )\n        ]);\n\n        if (result.status === 'ERROR') {\n            throw newRxError('DM4', {\n                collection: this.collection.name,\n                error: result.error\n            });\n        } else {\n            return result;\n        }\n\n    }\n}\n"],"mappings":"AAAA,SAEIA,OAAO,EACPC,MAAM,EACNC,cAAc,EACdC,GAAG,EACHC,WAAW,QACR,MAAM;AACb,SACIC,wBAAwB,EACxBC,UAAU,QACP,mBAAmB;AAY1B,SACIC,4BAA4B,EAC5BC,2BAA2B,EAC3BC,oBAAoB,EACpBC,mBAAmB,EACnBC,WAAW,QACR,wBAAwB;AAC/B,SACIC,oBAAoB,EACpBC,0BAA0B,EAC1BC,KAAK,EACLC,SAAS,EACTC,cAAc,EACdC,gBAAgB,EAChBC,kBAAkB,EAClBC,wBAAwB,QAErB,mBAAmB;AAM1B,SACIC,iBAAiB,EACjBC,aAAa,EACbC,aAAa,EACbC,WAAW,QACR,4BAA4B;AACnC,SACIC,gBAAgB,EAChBC,oBAAoB,QACjB,mBAAmB;AAC1B,SACIC,0BAA0B,EAC1BC,oCAAoC,EACpCC,+BAA+B,EAC/BC,0BAA0B,EAC1BC,sBAAsB,EACtBC,kCAAkC,EAClCC,0BAA0B,EAC1BC,qCAAqC,QAClC,qCAAqC;AAC5C,SAASC,YAAY,QAAQ,uBAAuB;AACpD,SACIC,iCAAiC,EACjCC,+BAA+B,EAC/BC,+BAA+B,QAC5B,qCAAqC;AAC5C,SAASC,mBAAmB,EAAEC,YAAY,QAAQ,0BAA0B;AAI5E,WAAaC,gBAAgB;EAazB,SAAAA,iBACoBC,UAAwB,EACxBC,mBAAsC,EACtCC,YAAY,GAAG,CAC3BF,UAAU,CAACG,IAAI,EACf,GAAG,EACHH,UAAU,CAACI,MAAM,CAACC,OAAO,CAC5B,CAACC,IAAI,CAAC,GAAG,CAAC,EACb;IAAA,KAhBMC,OAAO,GAAY,KAAK;IAAA,KAMzBC,QAAQ,GAAY,KAAK;IAAA,KAmLzBC,oBAAoB,GAA4B,EAAE;IAAA,KAClDC,iBAAiB,GAAiBvC,oBAAoB;IAAA,KAjLzC6B,UAAwB,GAAxBA,UAAwB;IAAA,KACxBC,mBAAsC,GAAtCA,mBAAsC;IAAA,KACtCC,YAAY,GAAZA,YAAY;IAM5B,IAAI,CAACS,QAAQ,GAAGX,UAAU,CAACW,QAAQ;IACnC,IAAI,CAACC,iBAAiB,GAAG5C,oBAAoB,CAAC,IAAI,CAAC;IACnD,IAAI,CAACE,WAAW,GAAGA,WAAW,CAAC,IAAI,CAAC;IACpC,IAAI,CAAC2C,WAAW,GAAGjB,+BAA+B,CAC9C,IAAI,CAACM,YAAY,EACjBR,iCACJ,CAAC;IACD3B,2BAA2B,CAAC,IAAI,CAAC;IAEjC,IAAI,CAAC+C,CAAC,GAAGjC,aAAa,CAClB,IAAI,CAAC8B,QAAQ,CAACI,aAAa,EAC3B,IAAI,CAACF,WACT,CAAC,CAACG,IAAI,CACFxD,MAAM,CAACyD,CAAC,IAAI,CAAC,CAACA,CAAC,CAAC,EAChBvD,GAAG,CAACuD,CAAC,IAAI1C,cAAc,CAAC0C,CAAC,CAAC,CAACC,IAAI,CAAC,EAChCvD,WAAW,CAACS,0BAA0B,CAC1C,CAAC;EACL;EAAC,IAAA+C,MAAA,GAAApB,gBAAA,CAAAqB,SAAA;EAAAD,MAAA,CAEDE,SAAS,GAAT,SAAAA,SAASA,CAAA,EAAG;IACR,OAAO5D,cAAc,CAAC,IAAI,CAACqD,CAAC,CAAC;EACjC;;EAGA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAPI;EAAAK,MAAA,CAQMG,cAAc,GAApB,eAAMA,cAAcA,CAACC,SAAiB,GAAGzD,4BAA4B,EAAiB;IAClF,IAAM0D,IAAI,GAAG,MAAM,IAAI,CAACtD,WAAW;IACnC,IAAI,CAACsD,IAAI,EAAE;MACP;IACJ;IACA,IAAI,IAAI,CAACjB,OAAO,EAAE;MACd,MAAM1C,UAAU,CAAC,KAAK,CAAC;IAC3B;IACA,IAAI,CAAC0C,OAAO,GAAG,IAAI;;IAGnB;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,IAAI,CAACI,QAAQ,CAACc,aAAa,EAAE;MAC7B,IAAI,CAACC,gBAAgB,GAAG,IAAI3C,gBAAgB,CAAC,CACzC,oBAAoB,EACpB,IAAI,CAAC4B,QAAQ,CAACR,IAAI,EAClB,IAAI,CAACH,UAAU,CAACG,IAAI,EACpB,IAAI,CAACH,UAAU,CAACI,MAAM,CAACC,OAAO,CACjC,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC;MACZ,IAAMqB,aAAa,GAAG3C,oBAAoB,CAAC,IAAI,CAAC0C,gBAAgB,CAAC;MACjE,MAAMC,aAAa,CAACC,eAAe,CAAC,CAAC;IACzC;;IAEA;AACR;AACA;AACA;AACA;IACQ,IAAMhB,iBAAiB,GAAG,MAAM,IAAI,CAACA,iBAAiB;IACtD,IAAMiB,kBAAkB,GAAG,MAAM,IAAI,CAAClB,QAAQ,CAACmB,OAAO,CAACC,qBAAqB,CAAC;MACzEC,YAAY,EAAE,IAAI,CAACrB,QAAQ,CAACR,IAAI;MAChC8B,cAAc,EAAE,IAAI,CAACjC,UAAU,CAACG,IAAI;MACpC+B,qBAAqB,EAAE,IAAI,CAACvB,QAAQ,CAACwB,KAAK;MAC1CV,aAAa,EAAE,IAAI,CAACd,QAAQ,CAACc,aAAa;MAC1CW,OAAO,EAAE,CAAC,CAAC;MACXhC,MAAM,EAAE7B,cAAc,CAACqC,iBAAiB,CAAC,CAACM,IAAI,CAACd,MAAM;MACrDiC,QAAQ,EAAE,IAAI,CAAC1B,QAAQ,CAAC0B,QAAQ;MAChCC,OAAO,EAAE7C,YAAY,CAAC8C,SAAS,CAAC;IACpC,CAAC,CAAC;IAGF,IAAMC,kBAAkB,GAAG,MAAM,IAAI,CAACC,4BAA4B,CAAC,CAAC;;IAGpE;AACR;AACA;IACQ,IAAMC,UAAU,GAAG,MAAM,IAAI,CAACC,iBAAiB,CAC3C,CAACd,kBAAkB,CAAC,CAACe,MAAM,CAACJ,kBAAkB,CAAC9E,GAAG,CAACmF,CAAC,IAAIA,CAAC,CAACC,UAAU,CAAC,CACzE,CAAC;IACD,MAAM,IAAI,CAACC,YAAY,CAACC,CAAC,IAAI;MACzBA,CAAC,CAACC,KAAK,CAACC,KAAK,GAAGR,UAAU;MAC1B,OAAOM,CAAC;IACZ,CAAC,CAAC;IAGF,IAAI;MACA;AACZ;AACA;AACA;MACY,MAAMG,OAAO,CAACC,GAAG,CACbZ,kBAAkB,CAAC9E,GAAG,CAAC,MAAO2F,iBAAiB,IAAK;QAChD,MAAM1D,+BAA+B,CACjC,IAAI,CAACK,UAAU,EACfqD,iBAAiB,CAACC,UAAU,CAACrB,cAAc,EAC3CoB,iBAAiB,CAACC,UAAU,CAAClD,MACjC,CAAC;QACD,MAAM,IAAI,CAACmD,cAAc,CACrBF,iBAAiB,CAACP,UAAU,EAC5BO,iBAAiB,CAACC,UAAU,EAC5B/B,SACJ,CAAC;QACD,MAAM8B,iBAAiB,CAACC,UAAU,CAACE,KAAK,CAAC,CAAC;MAC9C,CAAC,CACL,CAAC;MAED,MAAM,IAAI,CAACD,cAAc,CACrB1B,kBAAkB;MAClB;AAChB;AACA;AACA;AACA;AACA;MACgB,IAAI,CAAC7B,UAAU,CAACyD,eAAe,CAACC,uBAAuB,EACvDnC,SACJ,CAAC;IACL,CAAC,CAAC,OAAOoC,GAAG,EAAE;MACV,MAAM9B,kBAAkB,CAAC2B,KAAK,CAAC,CAAC;MAChC,MAAM,IAAI,CAACT,YAAY,CAACC,CAAC,IAAI;QACzBA,CAAC,CAACY,MAAM,GAAG,OAAO;QAClBZ,CAAC,CAACa,KAAK,GAAGrF,gBAAgB,CAACmF,GAAY,CAAC;QACxC,OAAOX,CAAC;MACZ,CAAC,CAAC;MACF;IACJ;;IAEA;IACA,IAAI;MACA,MAAMlE,WAAW,CACb,IAAI,CAAC6B,QAAQ,CAACI,aAAa,EAC3B;QACI+C,QAAQ,EAAElD,iBAAiB;QAC3BmD,QAAQ,EAAEC,MAAM,CAACC,MAAM,CACnB,CAAC,CAAC,EACFrD,iBAAiB,EACjB;UACIsD,QAAQ,EAAE;QACd,CACJ;MACJ,CAAC,EACD,qCACJ,CAAC;IACL,CAAC,CAAC,OAAOL,KAAK,EAAE;MACZ,IAAMM,UAAU,GAAGvG,wBAAwB,CAAiCiG,KAAK,CAAC;MAClF,IAAIM,UAAU,IAAI,CAAC,CAACA,UAAU,CAACC,YAAY,CAACF,QAAQ,EAAE,CACtD,CAAC,MAAM;QACH,MAAML,KAAK;MACf;IACJ;IAEA,MAAM,IAAI,CAACd,YAAY,CAACC,CAAC,IAAI;MACzBA,CAAC,CAACY,MAAM,GAAG,MAAM;MACjB,OAAOZ,CAAC;IACZ,CAAC,CAAC;IACF,IAAI,IAAI,CAACtB,gBAAgB,EAAE;MACvB,MAAM,IAAI,CAACA,gBAAgB,CAAC8B,KAAK,CAAC,CAAC;IACvC;EACJ,CAAC;EAAArC,MAAA,CAIM4B,YAAY,GAAnB,SAAOA,YAAYA,CACfsB,OAA8B,EAChC;IACE,IAAI,CAAC5D,oBAAoB,CAAC6D,IAAI,CAACD,OAAO,CAAC;IACvC,IAAI,CAAC3D,iBAAiB,GAAG,IAAI,CAACA,iBAAiB,CAAC6D,IAAI,CAAC,YAAY;MAC7D,IAAI,IAAI,CAAC9D,oBAAoB,CAAC+D,MAAM,KAAK,CAAC,EAAE;QACxC;MACJ;MACA;MACA,IAAMC,WAAW,GAAG,IAAI,CAAChE,oBAAoB;MAC7C,IAAI,CAACA,oBAAoB,GAAG,EAAE;MAC9B,OAAO,IAAI,EAAE;QACT,IAAMqD,QAAQ,GAAG,MAAMnF,iBAAiB,CACpC,IAAI,CAACgC,QAAQ,CAACI,aAAa,EAC3B,IAAI,CAACF,WACT,CAAC;QACD,IAAI6D,MAAM,GAAGrG,KAAK,CAACyF,QAAQ,CAAC;QAC5B,IAAI,CAACA,QAAQ,EAAE;UACXY,MAAM,GAAG;YACLC,EAAE,EAAE,IAAI,CAAC9D,WAAW;YACpB+D,GAAG,EAAE,IAAI,CAAC1E,YAAY;YACtB2E,OAAO,EAAEnF,iCAAiC;YAC1CwB,IAAI,EAAE;cACFe,cAAc,EAAE,IAAI,CAACjC,UAAU,CAACG,IAAI;cACpCyD,MAAM,EAAE,SAAS;cACjBX,KAAK,EAAE;gBACHC,KAAK,EAAE,CAAC;gBACR4B,OAAO,EAAE,CAAC;gBACVC,OAAO,EAAE;cACb;YACJ,CAAC;YACDb,QAAQ,EAAE,KAAK;YACfc,KAAK,EAAEtG,wBAAwB,CAAC,CAAC;YACjCuG,IAAI,EAAExG,kBAAkB,CAAC,CAAC;YAC1ByG,YAAY,EAAE,CAAC;UACnB,CAAC;QACL;QAEA,IAAItB,MAAM,GAAGrF,cAAc,CAACmG,MAAM,CAAC,CAACxD,IAAI;QACxC,KAAK,IAAMiE,UAAU,IAAIV,WAAW,EAAE;UAClCb,MAAM,GAAGuB,UAAU,CAACvB,MAAM,CAAC;QAC/B;QACAA,MAAM,CAACX,KAAK,CAAC8B,OAAO,GAAGK,IAAI,CAACC,KAAK,CAAEzB,MAAM,CAACX,KAAK,CAAC6B,OAAO,GAAGlB,MAAM,CAACX,KAAK,CAACC,KAAK,GAAI,GAAG,CAAC;QAEpF,IACIwB,MAAM,IAAIZ,QAAQ,IAClBxF,SAAS,CAACoG,MAAM,CAACxD,IAAI,EAAE4C,QAAQ,CAAC5C,IAAI,CAAC,EACvC;UACE;QACJ;QAGA,IAAI;UACA,MAAMpC,WAAW,CACb,IAAI,CAAC6B,QAAQ,CAACI,aAAa,EAC3B;YACI+C,QAAQ;YACRC,QAAQ,EAAExF,cAAc,CAACmG,MAAM;UACnC,CAAC,EACDhF,iCACJ,CAAC;;UAED;UACA;QACJ,CAAC,CAAC,OAAOiE,GAAG,EAAE;UACV;UACA,IAAI,CAAC/F,wBAAwB,CAAC+F,GAAG,CAAC,EAAE;YAChC,MAAMA,GAAG;UACb;QACJ;MACJ;IACJ,CAAC,CAAC;IACF,OAAO,IAAI,CAACjD,iBAAiB;EACjC,CAAC;EAAAS,MAAA,CAGYoC,cAAc,GAA3B,eAAaA,cAAcA,CACvBT,UAA4C,EAC5CQ,UAA4C,EAC5C/B,SAAiB,EACnB;IAEE,IAAI,CAACvB,UAAU,CAACsF,OAAO,CAAChB,IAAI,CAAC,MAAM,IAAI,CAACiB,MAAM,CAAC,CAAC,CAAC;IACjD,IAAI,CAAC5E,QAAQ,CAAC2E,OAAO,CAAChB,IAAI,CAAC,MAAM,IAAI,CAACiB,MAAM,CAAC,CAAC,CAAC;IAC/C,IAAMC,8BAA8B,GAAG,MAAM,IAAI,CAAC7E,QAAQ,CAACmB,OAAO,CAACC,qBAAqB,CAAC;MACrFC,YAAY,EAAE,IAAI,CAACrB,QAAQ,CAACR,IAAI;MAChC8B,cAAc,EAAE,0BAA0B,GAAGa,UAAU,CAACb,cAAc,GAAG,GAAG,GAAGa,UAAU,CAAC1C,MAAM,CAACC,OAAO;MACxG6B,qBAAqB,EAAE,IAAI,CAACvB,QAAQ,CAACwB,KAAK;MAC1CV,aAAa,EAAE,IAAI,CAACd,QAAQ,CAACc,aAAa;MAC1CW,OAAO,EAAE,CAAC,CAAC;MACXhC,MAAM,EAAEd,kCAAkC,CAACwD,UAAU,CAAC1C,MAAM,EAAExB,aAAa,CAACkE,UAAU,CAAC1C,MAAM,CAAC,CAAC;MAC/FiC,QAAQ,EAAE,IAAI,CAAC1B,QAAQ,CAAC0B,QAAQ;MAChCC,OAAO,EAAE7C,YAAY,CAAC8C,SAAS,CAAC;IACpC,CAAC,CAAC;IAEF,IAAMkD,sBAAsB,GAAGjG,qCAAqC,CAChE8D,UAAU;IACV;AACZ;AACA;AACA;IACYjE,sBAAsB,EACtB,IAAI,CAACsB,QAAQ,CAACwB,KAAK,EACnB,IACJ,CAAC;IAED,IAAMuD,gBAAgB,GAAGnG,0BAA0B,CAAC;MAChDoG,QAAQ,EAAE,IAAI;MACdC,UAAU,EAAE,CACR,oBAAoB,EACpB9C,UAAU,CAACb,cAAc,EACzBa,UAAU,CAAC1C,MAAM,CAACC,OAAO,EACzB,IAAI,CAACL,UAAU,CAACI,MAAM,CAACC,OAAO,CACjC,CAACC,IAAI,CAAC,GAAG,CAAC;MACXuF,kBAAkB,EAAE;QAChBC,kBAAkBA,CAAA,EAAG;UACjB,OAAO3C,OAAO,CAAC4C,OAAO,CAAC;YACnBC,UAAU,EAAE,IAAI;YAChBC,SAAS,EAAE;UACf,CAAC,CAAC;QACN,CAAC;QACDC,WAAW,EAAE,MAAOC,IAAI,IAAK;UACzB,IAAIC,YAAY,GAAG,MAAMjD,OAAO,CAACC,GAAG,CAChC+C,IAAI,CACCzI,GAAG,CAAC,MAAO2I,GAAG,IAAK;YAChB,IAAIC,UAAU,GAAGD,GAAG,CAACE,gBAAgB;YACrC,IAAIjD,UAAU,CAAClD,MAAM,CAACoG,KAAK,KAAKvH,0BAA0B,EAAE;cACxDqH,UAAU,GAAGD,GAAG,CAACE,gBAAgB,CAACE,OAAO;cACzC,IAAIJ,GAAG,CAACE,gBAAgB,CAACG,YAAY,KAAK,GAAG,EAAE;gBAC3C,OAAO;kBACHC,kBAAkB,EAAEC,SAAS;kBAC7BL,gBAAgB,EAAEF,GAAG,CAACE;gBAC1B,CAAC;cACL;YACJ;YACA,IAAMM,eAAmD,GAAG,MAAM5I,mBAAmB,CACjF,IAAI,CAAC+B,UAAU,EACf8C,UAAU,CAAC1C,MAAM,CAACC,OAAO,EACzBiG,UACJ,CAAC;;YAED;AAChC;AACA;AACA;YACgC,IAAIO,eAAe,KAAK,IAAI,EAAE;cAC1B,OAAO,IAAI;YACf;YAEA,IAAMC,MAA0C,GAAG;cAC/C;cACAH,kBAAkB,EAAEC,SAAS;cAC7BL,gBAAgB,EAAEjD,UAAU,CAAClD,MAAM,CAACoG,KAAK,KAAKvH,0BAA0B,GAClE+E,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEoC,GAAG,CAACE,gBAAgB,EAAE;gBAAEE,OAAO,EAAEI;cAAgB,CAAC,CAAC,GACrEA;YACV,CAAC;YAED,OAAOC,MAAM;UACjB,CAAC,CACT,CAAC;;UAED;UACAV,YAAY,GAAGA,YAAY,CAAC5I,MAAM,CAAC6I,GAAG,IAAI,CAAC,CAACA,GAAG,IAAI,CAAC,CAACA,GAAG,CAACE,gBAAgB,CAAC;UAE1E,IAAMQ,MAAM,GAAG,MAAMtB,sBAAsB,CAACS,WAAW,CAACE,YAAmB,CAAC;UAC5E,OAAOW,MAAM;QACjB,CAAC;QACDC,mBAAmB,EAAE,IAAIzJ,OAAO,CAAM,CAAC,CAAC0J,YAAY,CAAC;MACzD,CAAC;MACDC,YAAY,EAAEpE,UAAU;MACxBqE,YAAY,EAAE3B,8BAA8B;MAC5C4B,aAAa,EAAE7F,SAAS;MACxB8F,aAAa,EAAE,CAAC;MAChBC,eAAe,EAAEjI,sBAAsB;MACvCkI,YAAY,EAAE,IAAI,CAAC5G,QAAQ,CAAC4G;IAChC,CAAC,CAAC;IAGF,IAAIC,QAAuC,GAAG,KAAK;IACnD9B,gBAAgB,CAAC+B,MAAM,CAAC5D,KAAK,CAAC6D,SAAS,CAAC/D,GAAG,IAAI6D,QAAQ,GAAG7D,GAAG,CAAC;;IAE9D;IACA+B,gBAAgB,CAAC+B,MAAM,CAACE,SAAS,CAACC,EAAE,CAACF,SAAS,CAAC,MAAM;MACjD,IAAI,CAAC3E,YAAY,CAACa,MAAM,IAAI;QACxBA,MAAM,CAACX,KAAK,CAAC6B,OAAO,GAAGlB,MAAM,CAACX,KAAK,CAAC6B,OAAO,GAAG,CAAC;QAC/C,OAAOlB,MAAM;MACjB,CAAC,CAAC;IACN,CAAC,CAAC;IAEF,MAAM1E,oCAAoC,CAACwG,gBAAgB,CAAC;IAC5D,MAAMvG,+BAA+B,CAACuG,gBAAgB,CAAC;IAEvD,MAAM,IAAI,CAAChF,iBAAiB;IAC5B,IAAI8G,QAAQ,EAAE;MACV,MAAMhC,8BAA8B,CAAChC,KAAK,CAAC,CAAC;MAC5C,MAAMgE,QAAQ;IAClB;;IAEA;IACA,MAAMrE,OAAO,CAACC,GAAG,CAAC,CACdN,UAAU,CAAC+E,MAAM,CAAC,CAAC,EACnBrC,8BAA8B,CAACqC,MAAM,CAAC,CAAC,CAC1C,CAAC;IAEF,MAAM,IAAI,CAACtC,MAAM,CAAC,CAAC;EACvB;;EAEA;AACJ;AACA;AACA;AACA,KAJI;EAAApE,MAAA,CAKaoE,MAAM,GAAnB,eAAaA,MAAMA,CAAA,EAAG;IAClB,IAAI,CAAC/E,QAAQ,GAAG,IAAI;IACpB,IAAI,IAAI,CAACkF,gBAAgB,EAAE;MACvB,MAAMtG,0BAA0B,CAAC,IAAI,CAACsG,gBAAgB,CAAC;IAC3D;IACA,IAAI,IAAI,CAAChE,gBAAgB,EAAE;MACvB,MAAM,IAAI,CAACA,gBAAgB,CAAC8B,KAAK,CAAC,CAAC;IACvC;EACJ,CAAC;EAAArC,MAAA,CAEYwB,iBAAiB,GAA9B,eAAaA,iBAAiBA,CAC1BmF,gBAAoD,EACrC;IACf,IAAIC,GAAG,GAAG,CAAC;IACX,MAAM5E,OAAO,CAACC,GAAG,CACb0E,gBAAgB,CAACpK,GAAG,CAAC,MAAOsK,QAAQ,IAAK;MAErC,IAAMC,aAAa,GAAGnI,YAAY,CAC9BkI,QAAQ,CAAC5H,MAAM,EACfP,mBAAmB,CACfmI,QAAQ,CAAC5H,MAAM,EACf;QACI8H,QAAQ,EAAE,CAAC;MACf,CACJ,CACJ,CAAC;MACD,IAAMC,WAAW,GAAG,MAAMH,QAAQ,CAAC/E,KAAK,CAACgF,aAAa,CAAC;MACvDF,GAAG,IAAII,WAAW,CAAClF,KAAK;IAC5B,CAAC,CACL,CAAC;IACD,OAAO8E,GAAG;EACd,CAAC;EAAA5G,MAAA,CAEYsB,4BAA4B,GAAzC,eAAaA,4BAA4BA,CAAA,EAAG;IACxC,IAAM7B,iBAAiB,GAAGrC,cAAc,CAAC,MAAM,IAAI,CAACqC,iBAAiB,CAAC;IACtE,IAAMmH,GAGH,GAAG,EAAE;IAER,MAAM5E,OAAO,CAACC,GAAG,CACb,MAAMD,OAAO,CAACC,GAAG,CACbxC,iBAAiB,CACZM,IAAI,CACJkH,iBAAiB,CACjB1K,GAAG,CAAC,MAAO2K,gBAAgB,IAAK;MAE7B;MACA,IAAIA,gBAAgB,CAACjI,MAAM,CAACoG,KAAK,KAAKvH,0BAA0B,EAAE;QAC9D,MAAM,IAAIqJ,KAAK,CAAC,uCAAuC,CAAC;MAC5D;MAEA,IAAMC,SAAS,GAAGjJ,kCAAkC,CAChDjB,KAAK,CAAC,IAAI,CAAC2B,UAAU,CAACI,MAAM,CAACoI,UAAU,CAAC,EACxC5J,aAAa,CAACyJ,gBAAgB,CAACjI,MAAM,CACzC,CAAC;MACDmI,SAAS,CAAClI,OAAO,GAAG,IAAI,CAACL,UAAU,CAACI,MAAM,CAACC,OAAO;MAClD,IAAM,CAACyC,UAAU,EAAEQ,UAAU,CAAC,GAAG,MAAMH,OAAO,CAACC,GAAG,CAAC,CAC/C,IAAI,CAACzC,QAAQ,CAACmB,OAAO,CAACC,qBAAqB,CAAC;QACxCG,qBAAqB,EAAE,IAAI,CAACvB,QAAQ,CAACwB,KAAK;QAC1CH,YAAY,EAAE,IAAI,CAACrB,QAAQ,CAACR,IAAI;QAChCmC,OAAO,EAAE7C,YAAY,CAAC8C,SAAS,CAAC,CAAC;QACjCd,aAAa,EAAE,IAAI,CAACd,QAAQ,CAACc,aAAa;QAC1CW,OAAO,EAAE,CAAC,CAAC;QACXhC,MAAM,EAAEiI,gBAAgB,CAACjI,MAAM;QAC/BiC,QAAQ,EAAE,IAAI,CAAC1B,QAAQ,CAAC0B,QAAQ;QAChCJ,cAAc,EAAEoG,gBAAgB,CAACpG;MACrC,CAAC,CAAC,EACF,IAAI,CAACtB,QAAQ,CAACmB,OAAO,CAACC,qBAAqB,CAAC;QACxCG,qBAAqB,EAAE,IAAI,CAACvB,QAAQ,CAACwB,KAAK;QAC1CH,YAAY,EAAE,IAAI,CAACrB,QAAQ,CAACR,IAAI;QAChCmC,OAAO,EAAE7C,YAAY,CAAC8C,SAAS,CAAC,CAAC;QACjCd,aAAa,EAAE,IAAI,CAACd,QAAQ,CAACc,aAAa;QAC1CW,OAAO,EAAE,CAAC,CAAC;QACXhC,MAAM,EAAEmI,SAAS;QACjBlG,QAAQ,EAAE,IAAI,CAAC1B,QAAQ,CAAC0B,QAAQ;QAChCJ,cAAc,EAAEoG,gBAAgB,CAACpG;MACrC,CAAC,CAAC,CACL,CAAC;MACF8F,GAAG,CAACzD,IAAI,CAAC;QAAExB,UAAU;QAAEQ;MAAW,CAAC,CAAC;IACxC,CAAC,CACT,CACJ,CAAC;IAED,OAAOyE,GAAG;EACd,CAAC;EAAA5G,MAAA,CAIKsH,cAAc,GAApB,eAAMA,cAAcA,CAAClH,SAAkB,EAA8B;IACjE,IAAI,CAACD,cAAc,CAACC,SAAS,CAAC;IAC9B,IAAMC,IAAI,GAAG,MAAM,IAAI,CAACtD,WAAW;IACnC,IAAI,CAACsD,IAAI,EAAE;MACP,OAAO;QACHoC,MAAM,EAAE,MAAM;QACd3B,cAAc,EAAE,IAAI,CAACjC,UAAU,CAACG,IAAI;QACpC8C,KAAK,EAAE;UACH6B,OAAO,EAAE,CAAC;UACVC,OAAO,EAAE,CAAC;UACV7B,KAAK,EAAE;QACX;MACJ,CAAC;IACL;IAEA,IAAM6D,MAAM,GAAG,MAAM5D,OAAO,CAACuF,IAAI,CAAC,CAC9BjL,cAAc,CACV,IAAI,CAACqD,CAAC,CAACE,IAAI,CACPxD,MAAM,CAACyD,CAAC,IAAIA,CAAC,CAAC2C,MAAM,KAAK,MAAM,CACnC,CACJ,CAAC,EACDnG,cAAc,CACV,IAAI,CAACqD,CAAC,CAACE,IAAI,CACPxD,MAAM,CAACyD,CAAC,IAAIA,CAAC,CAAC2C,MAAM,KAAK,OAAO,CACpC,CACJ,CAAC,CACJ,CAAC;IAEF,IAAImD,MAAM,CAACnD,MAAM,KAAK,OAAO,EAAE;MAC3B,MAAM/F,UAAU,CAAC,KAAK,EAAE;QACpBmC,UAAU,EAAE,IAAI,CAACA,UAAU,CAACG,IAAI;QAChC0D,KAAK,EAAEkD,MAAM,CAAClD;MAClB,CAAC,CAAC;IACN,CAAC,MAAM;MACH,OAAOkD,MAAM;IACjB;EAEJ,CAAC;EAAA,OAAAhH,gBAAA;AAAA","ignoreList":[]}