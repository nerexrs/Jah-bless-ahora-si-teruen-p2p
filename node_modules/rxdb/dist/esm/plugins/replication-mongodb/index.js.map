{"version":3,"file":"index.js","names":["ensureNotFalsy","flatClone","RxDBLeaderElectionPlugin","RxReplicationState","startReplicationOnLeaderShip","addRxPlugin","Subject","MongoClient","MONGO_OPTIONS_DRIVER_INFO","iterateCheckpoint","mongodbDocToRxDB","rxdbDocToMongo","startChangeStream","RxMongoDBReplicationState","_RxReplicationState","mongoClient","mongoDatabase","mongoCollection","options","replicationIdentifier","collection","pull","push","live","retryTime","autoStart","_this","call","_inheritsLoose","replicateMongoDB","primaryPath","schema","waitForLeadership","pullStream$","mongodb","connection","db","databaseName","collectionName","replicationPrimitivesPull","handler","lastPulledCheckpoint","batchSize","result","documents","docs","checkpoint","modifier","stream$","asObservable","replicationPrimitivesPush","rows","conflicts","session","startSession","startTransaction","pushTransactionOptions","ids","map","row","newDocumentState","currentDocsArray","find","$in","toArray","currentDocsMap","Map","forEach","doc","set","promises","toMongoDoc","docId","current","get","remoteDocState","undefined","assumedMaster","assumedMasterState","_deleted","conflictHandler","isEqual","deleteOne","updateOne","$set","upsert","conflicting","insertOne","Promise","all","commitTransaction","replicationState","startBefore","start","bind","cancelBefore","cancel","changestream","subjects","error","on","next","close"],"sources":["../../../../src/plugins/replication-mongodb/index.ts"],"sourcesContent":["import {\n    ensureNotFalsy,\n    flatClone\n} from '../../plugins/utils/index.ts';\n\nimport { RxDBLeaderElectionPlugin } from '../leader-election/index.ts';\nimport type {\n    RxCollection,\n    ReplicationPullOptions,\n    ReplicationPushOptions,\n    RxReplicationWriteToMasterRow,\n    RxReplicationPullStreamItem,\n    RxDocumentData\n} from '../../types/index.d.ts';\nimport {\n    RxReplicationState,\n    startReplicationOnLeaderShip\n} from '../replication/index.ts';\nimport {\n    addRxPlugin,\n    WithDeleted\n} from '../../index.ts';\n\nimport { Subject } from 'rxjs';\nimport type {\n    MongoDbCheckpointType,\n    SyncOptionsMongoDB\n} from './mongodb-types.ts';\n\nimport {\n    Db as MongoDatabase,\n    Collection as MongoCollection,\n    MongoClient,\n    ClientSession\n} from 'mongodb';\nimport { MONGO_OPTIONS_DRIVER_INFO } from '../storage-mongodb/mongodb-helper.ts';\nimport { iterateCheckpoint } from './mongodb-checkpoint.ts';\nimport { mongodbDocToRxDB, rxdbDocToMongo, startChangeStream } from './mongodb-helper.ts';\n\nexport * from './mongodb-helper.ts';\nexport * from './mongodb-checkpoint.ts';\nexport type * from './mongodb-types.ts';\n\nexport class RxMongoDBReplicationState<RxDocType> extends RxReplicationState<RxDocType, MongoDbCheckpointType> {\n\n    constructor(\n        public readonly mongoClient: MongoClient,\n        public readonly mongoDatabase: MongoDatabase,\n        public readonly mongoCollection: MongoCollection<RxDocumentData<RxDocType> | any>,\n        public readonly options: SyncOptionsMongoDB<RxDocType>,\n        public readonly replicationIdentifier: string,\n        public readonly collection: RxCollection<RxDocType, any, any>,\n        public readonly pull?: ReplicationPullOptions<RxDocType, MongoDbCheckpointType>,\n        public readonly push?: ReplicationPushOptions<RxDocType>,\n        public readonly live: boolean = true,\n        public retryTime: number = 1000 * 5,\n        public autoStart: boolean = true\n    ) {\n\n        super(\n            replicationIdentifier,\n            collection,\n            '_deleted',\n            pull,\n            push,\n            live,\n            retryTime,\n            autoStart\n        );\n    }\n}\n\nexport function replicateMongoDB<RxDocType>(options: SyncOptionsMongoDB<RxDocType>) {\n    addRxPlugin(RxDBLeaderElectionPlugin);\n    const primaryPath = options.collection.schema.primaryPath;\n    options.live = typeof options.live === 'undefined' ? true : options.live;\n    options.waitForLeadership = typeof options.waitForLeadership === 'undefined' ? true : options.waitForLeadership;\n    const pullStream$: Subject<RxReplicationPullStreamItem<RxDocType, MongoDbCheckpointType>> = new Subject();\n\n    const mongoClient = new MongoClient(options.mongodb.connection, MONGO_OPTIONS_DRIVER_INFO);\n    const mongoDatabase = mongoClient.db(options.mongodb.databaseName);\n    const mongoCollection = mongoDatabase.collection(options.mongodb.collectionName);\n\n    let replicationPrimitivesPull: ReplicationPullOptions<RxDocType, MongoDbCheckpointType> | undefined;\n    if (options.pull) {\n        replicationPrimitivesPull = {\n            async handler(\n                lastPulledCheckpoint: MongoDbCheckpointType | undefined,\n                batchSize: number\n            ) {\n                const result = await iterateCheckpoint<RxDocType>(primaryPath, mongoCollection, batchSize, lastPulledCheckpoint);\n                return {\n                    documents: result.docs,\n                    checkpoint: result.checkpoint\n                };\n            },\n            batchSize: ensureNotFalsy(options.pull).batchSize,\n            modifier: ensureNotFalsy(options.pull).modifier,\n            stream$: pullStream$.asObservable()\n        };\n    }\n\n    let replicationPrimitivesPush: ReplicationPushOptions<RxDocType> | undefined;\n    if (options.push) {\n        replicationPrimitivesPush = {\n            async handler(\n                rows: RxReplicationWriteToMasterRow<RxDocType>[]\n            ) {\n                const conflicts: WithDeleted<RxDocType>[] = [];\n                const session: ClientSession = mongoClient.startSession();\n                session.startTransaction(options.mongodb.pushTransactionOptions);\n                const ids = rows.map(row => (row.newDocumentState as any)[primaryPath]);\n                const currentDocsArray = await mongoCollection.find(\n                    { [primaryPath]: { $in: ids } },\n                    { session }\n                ).toArray();\n                const currentDocsMap = new Map<any, any>();\n                currentDocsArray.forEach(doc => {\n                    currentDocsMap.set(doc[primaryPath], doc);\n                });\n                let promises: Promise<any>[] = [];\n                rows.forEach(row => {\n                    const toMongoDoc = rxdbDocToMongo(row.newDocumentState as any);\n                    const docId = (row.newDocumentState as any)[primaryPath];\n                    const current = currentDocsMap.get(docId);\n                    const remoteDocState = current ? mongodbDocToRxDB(primaryPath, current) : undefined;\n\n                    /**\n                     * We do not want to require a deleted-flag or any RxDB specific stuff on the RxDB side.\n                     * So for deletes we have to hack around this.\n                     */\n                    let assumedMaster = row.assumedMasterState;\n                    if (row.newDocumentState._deleted) {\n                        if (remoteDocState) {\n                            if (!assumedMaster) {\n                                // remote exists but not assumed -> conflict\n                                conflicts.push(remoteDocState);\n                            } else if (assumedMaster._deleted) {\n                                // remote exists but assumed as deleted -> conflict\n                                conflicts.push(remoteDocState);\n                            } else {\n                                // remote exists and assumed to exist -> check for normal conflict or do the deletion-write\n                                if (options.collection.conflictHandler.isEqual(remoteDocState, assumedMaster, 'mongodb-pull-equal-check-deleted') === false) {\n                                    // conflict\n                                    conflicts.push(remoteDocState);\n                                } else {\n                                    promises.push(\n                                        mongoCollection.deleteOne(\n                                            {\n                                                [primaryPath]: docId\n                                            },\n                                            {\n                                                session\n                                            }\n                                        )\n                                    );\n                                }\n\n                            }\n                        } else {\n                            if (!assumedMaster) {\n                                // no remote and no assumed master -> insertion of deleted -> do nothing\n                            } else if (assumedMaster._deleted) {\n                                // no remote and assumed master also deleted -> insertion of deleted -> do nothing\n                            }\n                        }\n                    } else {\n                        /**\n                         * Non-deleted are handled normally like in every other\n                         * of the replication plugins.\n                         */\n                        if (\n                            remoteDocState &&\n                            (\n                                !row.assumedMasterState ||\n                                options.collection.conflictHandler.isEqual(remoteDocState, row.assumedMasterState, 'mongodb-pull-equal-check') === false\n                            )\n                        ) {\n                            // conflict\n                            conflicts.push(remoteDocState);\n                        } else {\n                            if (current) {\n                                if (row.newDocumentState._deleted) {\n                                    promises.push(\n                                        mongoCollection.deleteOne(\n                                            {\n                                                [primaryPath]: docId\n                                            },\n                                            {\n                                                session\n                                            }\n                                        )\n                                    );\n                                } else {\n                                    promises.push(\n                                        mongoCollection.updateOne(\n                                            { [primaryPath]: docId },\n                                            { $set: toMongoDoc },\n                                            {\n                                                upsert: true,\n                                                session\n                                            }\n                                        )\n                                    );\n                                }\n                            } else {\n                                /**\n                                 * No current but has assumed.\n                                 * This means the server state was deleted\n                                 * and we have a conflict.\n                                 */\n                                if (row.assumedMasterState) {\n                                    const conflicting = flatClone(row.assumedMasterState);\n                                    conflicting._deleted = true;\n                                    conflicts.push(conflicting);\n                                } else {\n                                    if (row.newDocumentState._deleted) {\n                                        // inserting deleted -> do nothing\n                                    } else {\n                                        promises.push(\n                                            mongoCollection.insertOne(toMongoDoc, { session })\n                                        );\n                                    }\n                                }\n                            }\n                        }\n                    }\n                });\n                await Promise.all(promises);\n                await session.commitTransaction();\n                return conflicts;\n            },\n            batchSize: options.push.batchSize,\n            modifier: options.push.modifier\n        };\n    }\n\n\n    const replicationState = new RxMongoDBReplicationState<RxDocType>(\n        mongoClient,\n        mongoDatabase,\n        mongoCollection,\n        options,\n        options.replicationIdentifier,\n        options.collection,\n        replicationPrimitivesPull,\n        replicationPrimitivesPush,\n        options.live,\n        options.retryTime,\n        options.autoStart\n    );\n\n    /**\n     * Subscribe to changes for the pull.stream$\n     */\n    if (options.live && options.pull) {\n        const startBefore = replicationState.start.bind(replicationState);\n        const cancelBefore = replicationState.cancel.bind(replicationState);\n        replicationState.start = async () => {\n            const changestream = await startChangeStream(mongoCollection, undefined, replicationState.subjects.error);\n            changestream.on('change', () => {\n                // TODO use the documents data of the change instead of emitting the RESYNC flag\n                pullStream$.next('RESYNC');\n            });\n            replicationState.cancel = async () => {\n                await changestream.close();\n                return cancelBefore();\n            };\n            return startBefore();\n        };\n    }\n\n    startReplicationOnLeaderShip(options.waitForLeadership, replicationState);\n    return replicationState;\n}\n"],"mappings":"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","ignoreList":[]}