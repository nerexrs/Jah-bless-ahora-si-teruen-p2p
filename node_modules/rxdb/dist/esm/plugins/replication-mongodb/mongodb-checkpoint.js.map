{"version":3,"file":"mongodb-checkpoint.js","names":["clone","ensureNotFalsy","lastOfArray","mongodbDocToRxDB","getCurrentResumeToken","mongoCollection","changeStream","watch","tryNext","catch","token","resumeToken","close","getDocsSinceChangestreamCheckpoint","primaryPath","limit","resultByDocId","Map","resumeAfter","fullDocument","fullDocumentBeforeChange","nextToken","Promise","res","rej","on","err","_loop","change","_id","docId","documentKey","operationType","beforeDocMongo","beforeDoc","_deleted","set","resolve","findOne","then","doc","docFromChange","ret","size","docs","all","Array","from","values","getDocsSinceDocumentCheckpoint","checkpointId","query","$gt","find","sort","toArray","map","d","iterateCheckpoint","checkpoint","iterate","changestreamResumeToken","last","result","length","ids","Set","forEach","add","fillUp","id","has","filter","push"],"sources":["../../../../src/plugins/replication-mongodb/mongodb-checkpoint.ts"],"sourcesContent":["import { WithDeleted } from '../../types/rx-storage';\nimport { clone, ensureNotFalsy, lastOfArray } from '../utils/index.ts';\nimport { mongodbDocToRxDB } from './mongodb-helper.ts';\nimport type {\n    MongoDBChangeStreamResumeToken,\n    MongoDBCheckpointIterationState,\n    MongoDbCheckpointType,\n} from './mongodb-types';\nimport {\n    Collection as MongoCollection\n} from 'mongodb';\n\n\nexport async function getCurrentResumeToken(\n    mongoCollection: MongoCollection\n): Promise<MongoDBChangeStreamResumeToken> {\n    const changeStream = mongoCollection.watch();\n\n    // Trigger the initial batch so postBatchResumeToken is available\n    await changeStream.tryNext().catch(() => { });\n\n    const token = changeStream.resumeToken;\n    changeStream.close();\n    return token as any;\n}\n\nexport async function getDocsSinceChangestreamCheckpoint<MongoDocType>(\n    primaryPath: string,\n    mongoCollection: MongoCollection,\n    /**\n     * MongoDB has no way to start the stream from 'timestamp zero',\n     * we always need a resumeToken\n     */\n    resumeToken: MongoDBChangeStreamResumeToken,\n    limit: number\n): Promise<{ docs: WithDeleted<MongoDocType>[], nextToken: MongoDBChangeStreamResumeToken }> {\n    const resultByDocId = new Map<string, Promise<WithDeleted<MongoDocType>>>();\n    const changeStream = mongoCollection.watch(\n        [],\n        {\n            resumeAfter: resumeToken,\n            fullDocument: 'required',\n            fullDocumentBeforeChange: 'required',\n        }\n    );\n\n\n    /**\n     * We cannot use changeStream.resumeToken for the\n     * updated token because depending on the batchSize of mongoCollection.watch()\n     * it might have changes but not emitting a new token.\n     */\n    let nextToken = resumeToken;\n\n    return new Promise(async (res, rej) => {\n        changeStream.on('error', (err: any) => {\n            rej(err);\n        });\n\n        while (resultByDocId.size < limit) {\n            const change = await changeStream.tryNext();\n            if (change) {\n                nextToken = change._id as any;\n                const docId = (change as any).documentKey._id;\n\n                if (change.operationType === 'delete') {\n                    const beforeDocMongo = ensureNotFalsy(\n                        change.fullDocumentBeforeChange,\n                        'change must have pre-deletion state'\n                    );\n                    const beforeDoc = mongodbDocToRxDB(primaryPath, beforeDocMongo as any);\n                    beforeDoc._deleted = true;\n                    resultByDocId.set(docId, Promise.resolve(beforeDoc as any));\n                } else if (\n                    change.operationType === 'insert' ||\n                    change.operationType === 'update' ||\n                    change.operationType === 'replace'\n                ) {\n                    resultByDocId.set(docId, mongoCollection.findOne({ _id: docId }).then(doc => {\n                        if (doc) {\n                            return mongodbDocToRxDB(primaryPath, doc);\n                        } else {\n                            const docFromChange = ensureNotFalsy(\n                                change.fullDocument as any,\n                                'change must have change.fullDocument'\n                            );\n                            const ret = mongodbDocToRxDB(primaryPath, docFromChange);\n                            ret._deleted = true;\n                            return ret;\n                        }\n                    }));\n                }\n            } else {\n                break;\n            }\n        }\n\n        changeStream.close();\n\n        const docs = await Promise.all(Array.from(resultByDocId.values()));\n        res({ docs, nextToken: nextToken as any });\n    });\n}\n\nexport async function getDocsSinceDocumentCheckpoint<MongoDocType>(\n    primaryPath: string,\n    mongoCollection: MongoCollection,\n    limit: number,\n    checkpointId?: string\n): Promise<WithDeleted<MongoDocType>[]> {\n    const query = checkpointId\n        ? { [primaryPath]: { $gt: checkpointId } }\n        : {};\n\n    const docs = await mongoCollection\n        .find(query as any)\n        .sort({ [primaryPath]: 1 })\n        .limit(limit)\n        .toArray();\n\n    return docs.map(d => mongodbDocToRxDB(primaryPath, d as any));\n}\n\n\nexport async function iterateCheckpoint<MongoDocType>(\n    primaryPath: string,\n    mongoCollection: MongoCollection,\n    limit: number,\n    checkpoint?: MongoDbCheckpointType,\n): Promise<MongoDBCheckpointIterationState<MongoDocType>> {\n    if (!checkpoint) {\n        const token = await getCurrentResumeToken(mongoCollection);\n        checkpoint = {\n            iterate: 'docs-by-id',\n            changestreamResumeToken: token\n        }\n    } else {\n        checkpoint = clone(checkpoint);\n    }\n\n    let docs: WithDeleted<MongoDocType>[] = [];\n    if (checkpoint.iterate === 'docs-by-id') {\n        docs = await getDocsSinceDocumentCheckpoint<MongoDocType>(primaryPath, mongoCollection, limit, checkpoint.docId);\n        const last = lastOfArray(docs);\n        if (last) {\n            checkpoint.docId = (last as any)[primaryPath];\n        }\n    } else {\n        const result = await getDocsSinceChangestreamCheckpoint<MongoDocType>(primaryPath, mongoCollection, checkpoint.changestreamResumeToken, limit);\n        docs = result.docs;\n        checkpoint.changestreamResumeToken = result.nextToken;\n    }\n\n    /**\n     * If we have to toggle from docs-by-id to changestream iteration\n     * mode, the docs array might not be full while we still have some docs left.\n     */\n    if (checkpoint.iterate === 'docs-by-id' && docs.length < limit) {\n        const ids = new Set<string>();\n        docs.forEach(d => ids.add((d as any)[primaryPath]));\n        const fillUp = await getDocsSinceChangestreamCheckpoint<MongoDocType>(\n            primaryPath,\n            mongoCollection,\n            checkpoint.changestreamResumeToken,\n            limit\n        );\n\n        checkpoint.iterate = 'changestream';\n        checkpoint.changestreamResumeToken = fillUp.nextToken;\n\n        fillUp.docs.forEach(doc => {\n            const id = (doc as any)[primaryPath];\n            if (ids.has(id)) {\n                docs = docs.filter(d => (d as any)[primaryPath] !== id);\n            }\n            docs.push(doc);\n        });\n    }\n\n    return {\n        docs,\n        checkpoint\n    };\n}\n"],"mappings":"AACA,SAASA,KAAK,EAAEC,cAAc,EAAEC,WAAW,QAAQ,mBAAmB;AACtE,SAASC,gBAAgB,QAAQ,qBAAqB;AAWtD,OAAO,eAAeC,qBAAqBA,CACvCC,eAAgC,EACO;EACvC,IAAMC,YAAY,GAAGD,eAAe,CAACE,KAAK,CAAC,CAAC;;EAE5C;EACA,MAAMD,YAAY,CAACE,OAAO,CAAC,CAAC,CAACC,KAAK,CAAC,MAAM,CAAE,CAAC,CAAC;EAE7C,IAAMC,KAAK,GAAGJ,YAAY,CAACK,WAAW;EACtCL,YAAY,CAACM,KAAK,CAAC,CAAC;EACpB,OAAOF,KAAK;AAChB;AAEA,OAAO,eAAeG,kCAAkCA,CACpDC,WAAmB,EACnBT,eAAgC;AAChC;AACJ;AACA;AACA;AACIM,WAA2C,EAC3CI,KAAa,EAC4E;EACzF,IAAMC,aAAa,GAAG,IAAIC,GAAG,CAA6C,CAAC;EAC3E,IAAMX,YAAY,GAAGD,eAAe,CAACE,KAAK,CACtC,EAAE,EACF;IACIW,WAAW,EAAEP,WAAW;IACxBQ,YAAY,EAAE,UAAU;IACxBC,wBAAwB,EAAE;EAC9B,CACJ,CAAC;;EAGD;AACJ;AACA;AACA;AACA;EACI,IAAIC,SAAS,GAAGV,WAAW;EAE3B,OAAO,IAAIW,OAAO,CAAC,OAAOC,GAAG,EAAEC,GAAG,KAAK;IACnClB,YAAY,CAACmB,EAAE,CAAC,OAAO,EAAGC,GAAQ,IAAK;MACnCF,GAAG,CAACE,GAAG,CAAC;IACZ,CAAC,CAAC;IAAC,IAAAC,KAAA,kBAAAA,CAAA,EAEgC;MAC/B,IAAMC,MAAM,GAAG,MAAMtB,YAAY,CAACE,OAAO,CAAC,CAAC;MAC3C,IAAIoB,MAAM,EAAE;QACRP,SAAS,GAAGO,MAAM,CAACC,GAAU;QAC7B,IAAMC,KAAK,GAAIF,MAAM,CAASG,WAAW,CAACF,GAAG;QAE7C,IAAID,MAAM,CAACI,aAAa,KAAK,QAAQ,EAAE;UACnC,IAAMC,cAAc,GAAGhC,cAAc,CACjC2B,MAAM,CAACR,wBAAwB,EAC/B,qCACJ,CAAC;UACD,IAAMc,SAAS,GAAG/B,gBAAgB,CAACW,WAAW,EAAEmB,cAAqB,CAAC;UACtEC,SAAS,CAACC,QAAQ,GAAG,IAAI;UACzBnB,aAAa,CAACoB,GAAG,CAACN,KAAK,EAAER,OAAO,CAACe,OAAO,CAACH,SAAgB,CAAC,CAAC;QAC/D,CAAC,MAAM,IACHN,MAAM,CAACI,aAAa,KAAK,QAAQ,IACjCJ,MAAM,CAACI,aAAa,KAAK,QAAQ,IACjCJ,MAAM,CAACI,aAAa,KAAK,SAAS,EACpC;UACEhB,aAAa,CAACoB,GAAG,CAACN,KAAK,EAAEzB,eAAe,CAACiC,OAAO,CAAC;YAAET,GAAG,EAAEC;UAAM,CAAC,CAAC,CAACS,IAAI,CAACC,GAAG,IAAI;YACzE,IAAIA,GAAG,EAAE;cACL,OAAOrC,gBAAgB,CAACW,WAAW,EAAE0B,GAAG,CAAC;YAC7C,CAAC,MAAM;cACH,IAAMC,aAAa,GAAGxC,cAAc,CAChC2B,MAAM,CAACT,YAAY,EACnB,sCACJ,CAAC;cACD,IAAMuB,GAAG,GAAGvC,gBAAgB,CAACW,WAAW,EAAE2B,aAAa,CAAC;cACxDC,GAAG,CAACP,QAAQ,GAAG,IAAI;cACnB,OAAOO,GAAG;YACd;UACJ,CAAC,CAAC,CAAC;QACP;MACJ,CAAC,MAAM;QAAA;MAEP;IACJ,CAAC;IApCD,OAAO1B,aAAa,CAAC2B,IAAI,GAAG5B,KAAK;MAAA,UAAAY,KAAA,IAkCzB;IAAM;IAIdrB,YAAY,CAACM,KAAK,CAAC,CAAC;IAEpB,IAAMgC,IAAI,GAAG,MAAMtB,OAAO,CAACuB,GAAG,CAACC,KAAK,CAACC,IAAI,CAAC/B,aAAa,CAACgC,MAAM,CAAC,CAAC,CAAC,CAAC;IAClEzB,GAAG,CAAC;MAAEqB,IAAI;MAAEvB,SAAS,EAAEA;IAAiB,CAAC,CAAC;EAC9C,CAAC,CAAC;AACN;AAEA,OAAO,eAAe4B,8BAA8BA,CAChDnC,WAAmB,EACnBT,eAAgC,EAChCU,KAAa,EACbmC,YAAqB,EACe;EACpC,IAAMC,KAAK,GAAGD,YAAY,GACpB;IAAE,CAACpC,WAAW,GAAG;MAAEsC,GAAG,EAAEF;IAAa;EAAE,CAAC,GACxC,CAAC,CAAC;EAER,IAAMN,IAAI,GAAG,MAAMvC,eAAe,CAC7BgD,IAAI,CAACF,KAAY,CAAC,CAClBG,IAAI,CAAC;IAAE,CAACxC,WAAW,GAAG;EAAE,CAAC,CAAC,CAC1BC,KAAK,CAACA,KAAK,CAAC,CACZwC,OAAO,CAAC,CAAC;EAEd,OAAOX,IAAI,CAACY,GAAG,CAACC,CAAC,IAAItD,gBAAgB,CAACW,WAAW,EAAE2C,CAAQ,CAAC,CAAC;AACjE;AAGA,OAAO,eAAeC,iBAAiBA,CACnC5C,WAAmB,EACnBT,eAAgC,EAChCU,KAAa,EACb4C,UAAkC,EACoB;EACtD,IAAI,CAACA,UAAU,EAAE;IACb,IAAMjD,KAAK,GAAG,MAAMN,qBAAqB,CAACC,eAAe,CAAC;IAC1DsD,UAAU,GAAG;MACTC,OAAO,EAAE,YAAY;MACrBC,uBAAuB,EAAEnD;IAC7B,CAAC;EACL,CAAC,MAAM;IACHiD,UAAU,GAAG3D,KAAK,CAAC2D,UAAU,CAAC;EAClC;EAEA,IAAIf,IAAiC,GAAG,EAAE;EAC1C,IAAIe,UAAU,CAACC,OAAO,KAAK,YAAY,EAAE;IACrChB,IAAI,GAAG,MAAMK,8BAA8B,CAAenC,WAAW,EAAET,eAAe,EAAEU,KAAK,EAAE4C,UAAU,CAAC7B,KAAK,CAAC;IAChH,IAAMgC,IAAI,GAAG5D,WAAW,CAAC0C,IAAI,CAAC;IAC9B,IAAIkB,IAAI,EAAE;MACNH,UAAU,CAAC7B,KAAK,GAAIgC,IAAI,CAAShD,WAAW,CAAC;IACjD;EACJ,CAAC,MAAM;IACH,IAAMiD,MAAM,GAAG,MAAMlD,kCAAkC,CAAeC,WAAW,EAAET,eAAe,EAAEsD,UAAU,CAACE,uBAAuB,EAAE9C,KAAK,CAAC;IAC9I6B,IAAI,GAAGmB,MAAM,CAACnB,IAAI;IAClBe,UAAU,CAACE,uBAAuB,GAAGE,MAAM,CAAC1C,SAAS;EACzD;;EAEA;AACJ;AACA;AACA;EACI,IAAIsC,UAAU,CAACC,OAAO,KAAK,YAAY,IAAIhB,IAAI,CAACoB,MAAM,GAAGjD,KAAK,EAAE;IAC5D,IAAMkD,GAAG,GAAG,IAAIC,GAAG,CAAS,CAAC;IAC7BtB,IAAI,CAACuB,OAAO,CAACV,CAAC,IAAIQ,GAAG,CAACG,GAAG,CAAEX,CAAC,CAAS3C,WAAW,CAAC,CAAC,CAAC;IACnD,IAAMuD,MAAM,GAAG,MAAMxD,kCAAkC,CACnDC,WAAW,EACXT,eAAe,EACfsD,UAAU,CAACE,uBAAuB,EAClC9C,KACJ,CAAC;IAED4C,UAAU,CAACC,OAAO,GAAG,cAAc;IACnCD,UAAU,CAACE,uBAAuB,GAAGQ,MAAM,CAAChD,SAAS;IAErDgD,MAAM,CAACzB,IAAI,CAACuB,OAAO,CAAC3B,GAAG,IAAI;MACvB,IAAM8B,EAAE,GAAI9B,GAAG,CAAS1B,WAAW,CAAC;MACpC,IAAImD,GAAG,CAACM,GAAG,CAACD,EAAE,CAAC,EAAE;QACb1B,IAAI,GAAGA,IAAI,CAAC4B,MAAM,CAACf,CAAC,IAAKA,CAAC,CAAS3C,WAAW,CAAC,KAAKwD,EAAE,CAAC;MAC3D;MACA1B,IAAI,CAAC6B,IAAI,CAACjC,GAAG,CAAC;IAClB,CAAC,CAAC;EACN;EAEA,OAAO;IACHI,IAAI;IACJe;EACJ,CAAC;AACL","ignoreList":[]}