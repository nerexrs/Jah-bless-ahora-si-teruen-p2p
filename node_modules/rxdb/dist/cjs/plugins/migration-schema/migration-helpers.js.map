{"version":3,"file":"migration-helpers.js","names":["_rxjs","require","_rxDatabaseInternalStore","_rxSchema","_index","getOldCollectionMeta","migrationState","collectionDocKeys","getPreviousVersions","collection","schema","jsonSchema","map","version","name","found","database","internalStore","findDocumentsById","key","getPrimaryKeyOfInternalDocument","INTERNAL_CONTEXT_COLLECTION","foundById","forEach","f","oldest","find","undefined","migrateDocumentData","docSchemaVersion","docData","attachmentsBefore","flatClone","_attachments","mutateableDocData","clone","meta","_meta","nextVersion","currentPromise","Promise","resolve","_loop","then","docOrNull","runStrategyIfNotNull","doc","PROMISE_RESOLVE_NULL","ret","migrationStrategies","retPromise","toPromise","mustMigrate","PROMISE_RESOLVE_FALSE","oldColDoc","MIGRATION_DEFAULT_BATCH_SIZE","exports","DATA_MIGRATION_STATE_SUBJECT_BY_DATABASE","WeakMap","addMigrationStateToDatabase","allSubject","getMigrationStateByDatabase","allList","getValue","slice","push","next","getFromMapOrCreate","BehaviorSubject","onDatabaseClose","subject","get","complete"],"sources":["../../../../src/plugins/migration-schema/migration-helpers.ts"],"sourcesContent":["import { BehaviorSubject } from 'rxjs';\nimport {\n    INTERNAL_CONTEXT_COLLECTION,\n    getPrimaryKeyOfInternalDocument\n} from '../../rx-database-internal-store.ts';\nimport { getPreviousVersions } from '../../rx-schema.ts';\nimport type {\n    ById,\n    InternalStoreCollectionDocType,\n    InternalStoreDocType,\n    RxCollection,\n    RxDatabase,\n    RxDocumentData\n} from '../../types/index.d.ts';\nimport {\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_NULL,\n    clone,\n    flatClone,\n    getFromMapOrCreate,\n    toPromise\n} from '../utils/index.ts';\nimport { RxMigrationState } from './rx-migration-state.ts';\n\nexport async function getOldCollectionMeta(\n    migrationState: RxMigrationState\n): Promise<RxDocumentData<InternalStoreCollectionDocType> | undefined> {\n    const collectionDocKeys = getPreviousVersions(migrationState.collection.schema.jsonSchema)\n        .map(version => migrationState.collection.name + '-' + version);\n\n    const found = await migrationState.database.internalStore.findDocumentsById(\n        collectionDocKeys.map(key => getPrimaryKeyOfInternalDocument(\n            key,\n            INTERNAL_CONTEXT_COLLECTION\n        )),\n        false\n    );\n\n\n    /**\n     * It can happen that a previous migration was canceled or the browser was reloaded\n     * and on the next startup a new migration was added.\n     * So we can have multiple collection states with different versions.\n     * In this case, use the one with the lowest version number and start\n     * migrating from this one upwards.\n     */\n    const foundById: ById<RxDocumentData<InternalStoreDocType>> = {};\n    found.forEach(f => foundById[f.key] = f);\n    const oldest = collectionDocKeys.find(key => foundById[key]);\n    return oldest ? foundById[oldest] : undefined;\n}\n\n\n/**\n * runs the doc-data through all following migrationStrategies\n * so it will match the newest schema.\n * @throws Error if final doc does not match final schema or migrationStrategy crashes\n * @return final object or null if migrationStrategy deleted it\n */\nexport function migrateDocumentData(\n    collection: RxCollection,\n    docSchemaVersion: number,\n    docData: any\n): Promise<any | null> {\n    /**\n     * We cannot deep-clone Blob or Buffer\n     * so we just flat clone it here\n     * and attach it to the deep cloned document data.\n     */\n    const attachmentsBefore = flatClone(docData._attachments);\n    const mutateableDocData = clone(docData);\n    const meta = mutateableDocData._meta;\n    delete mutateableDocData._meta;\n    mutateableDocData._attachments = attachmentsBefore;\n\n    let nextVersion = docSchemaVersion + 1;\n\n    // run the document through migrationStrategies\n    let currentPromise = Promise.resolve(mutateableDocData);\n    while (nextVersion <= collection.schema.version) {\n        const version = nextVersion;\n        currentPromise = currentPromise.then(docOrNull => runStrategyIfNotNull(\n            collection,\n            version,\n            docOrNull\n        ));\n        nextVersion++;\n    }\n\n    return currentPromise.then(doc => {\n        if (doc === null) {\n            return PROMISE_RESOLVE_NULL;\n        }\n\n        if (meta) {\n            doc._meta = meta;\n        }\n        return doc;\n    });\n}\n\nexport function runStrategyIfNotNull(\n    collection: RxCollection,\n    version: number,\n    docOrNull: any | null\n): Promise<any | null> {\n    if (docOrNull === null) {\n        return PROMISE_RESOLVE_NULL;\n    } else {\n        const ret = collection.migrationStrategies[version](docOrNull, collection);\n        const retPromise = toPromise(ret);\n        return retPromise;\n    }\n}\n\n/**\n * returns true if a migration is needed\n */\nexport async function mustMigrate(\n    migrationState: RxMigrationState\n): Promise<boolean> {\n    if (migrationState.collection.schema.version === 0) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n    const oldColDoc = await getOldCollectionMeta(migrationState);\n    return !!oldColDoc;\n}\nexport const MIGRATION_DEFAULT_BATCH_SIZE = 200;\n\n\nexport type MigrationStateWithCollection = {\n    collection: RxCollection;\n    migrationState: RxMigrationState;\n};\n\nexport const DATA_MIGRATION_STATE_SUBJECT_BY_DATABASE = new WeakMap<RxDatabase, BehaviorSubject<RxMigrationState[]>>();\nexport function addMigrationStateToDatabase(\n    migrationState: RxMigrationState\n) {\n    const allSubject = getMigrationStateByDatabase(migrationState.database);\n    const allList = allSubject.getValue().slice(0);\n    allList.push(migrationState);\n    allSubject.next(allList);\n}\nexport function getMigrationStateByDatabase(database: RxDatabase): BehaviorSubject<RxMigrationState[]> {\n    return getFromMapOrCreate(\n        DATA_MIGRATION_STATE_SUBJECT_BY_DATABASE,\n        database,\n        () => new BehaviorSubject<RxMigrationState[]>([])\n    );\n}\n\n/**\n * Complete on database close\n * so people do not have to unsubscribe\n */\nexport function onDatabaseClose(database: RxDatabase) {\n    const subject = DATA_MIGRATION_STATE_SUBJECT_BY_DATABASE.get(database);\n    if (subject) {\n        subject.complete();\n    }\n}\n"],"mappings":"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","ignoreList":[]}