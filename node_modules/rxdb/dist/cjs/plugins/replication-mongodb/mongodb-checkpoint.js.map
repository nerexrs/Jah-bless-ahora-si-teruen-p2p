{"version":3,"file":"mongodb-checkpoint.js","names":["_index","require","_mongodbHelper","getCurrentResumeToken","mongoCollection","changeStream","watch","tryNext","catch","token","resumeToken","close","getDocsSinceChangestreamCheckpoint","primaryPath","limit","resultByDocId","Map","resumeAfter","fullDocument","fullDocumentBeforeChange","nextToken","Promise","res","rej","on","err","_loop","change","_id","docId","documentKey","operationType","beforeDocMongo","ensureNotFalsy","beforeDoc","mongodbDocToRxDB","_deleted","set","resolve","findOne","then","doc","docFromChange","ret","size","docs","all","Array","from","values","getDocsSinceDocumentCheckpoint","checkpointId","query","$gt","find","sort","toArray","map","d","iterateCheckpoint","checkpoint","iterate","changestreamResumeToken","clone","last","lastOfArray","result","length","ids","Set","forEach","add","fillUp","id","has","filter","push"],"sources":["../../../../src/plugins/replication-mongodb/mongodb-checkpoint.ts"],"sourcesContent":["import { WithDeleted } from '../../types/rx-storage';\nimport { clone, ensureNotFalsy, lastOfArray } from '../utils/index.ts';\nimport { mongodbDocToRxDB } from './mongodb-helper.ts';\nimport type {\n    MongoDBChangeStreamResumeToken,\n    MongoDBCheckpointIterationState,\n    MongoDbCheckpointType,\n} from './mongodb-types';\nimport {\n    Collection as MongoCollection\n} from 'mongodb';\n\n\nexport async function getCurrentResumeToken(\n    mongoCollection: MongoCollection\n): Promise<MongoDBChangeStreamResumeToken> {\n    const changeStream = mongoCollection.watch();\n\n    // Trigger the initial batch so postBatchResumeToken is available\n    await changeStream.tryNext().catch(() => { });\n\n    const token = changeStream.resumeToken;\n    changeStream.close();\n    return token as any;\n}\n\nexport async function getDocsSinceChangestreamCheckpoint<MongoDocType>(\n    primaryPath: string,\n    mongoCollection: MongoCollection,\n    /**\n     * MongoDB has no way to start the stream from 'timestamp zero',\n     * we always need a resumeToken\n     */\n    resumeToken: MongoDBChangeStreamResumeToken,\n    limit: number\n): Promise<{ docs: WithDeleted<MongoDocType>[], nextToken: MongoDBChangeStreamResumeToken }> {\n    const resultByDocId = new Map<string, Promise<WithDeleted<MongoDocType>>>();\n    const changeStream = mongoCollection.watch(\n        [],\n        {\n            resumeAfter: resumeToken,\n            fullDocument: 'required',\n            fullDocumentBeforeChange: 'required',\n        }\n    );\n\n\n    /**\n     * We cannot use changeStream.resumeToken for the\n     * updated token because depending on the batchSize of mongoCollection.watch()\n     * it might have changes but not emitting a new token.\n     */\n    let nextToken = resumeToken;\n\n    return new Promise(async (res, rej) => {\n        changeStream.on('error', (err: any) => {\n            rej(err);\n        });\n\n        while (resultByDocId.size < limit) {\n            const change = await changeStream.tryNext();\n            if (change) {\n                nextToken = change._id as any;\n                const docId = (change as any).documentKey._id;\n\n                if (change.operationType === 'delete') {\n                    const beforeDocMongo = ensureNotFalsy(\n                        change.fullDocumentBeforeChange,\n                        'change must have pre-deletion state'\n                    );\n                    const beforeDoc = mongodbDocToRxDB(primaryPath, beforeDocMongo as any);\n                    beforeDoc._deleted = true;\n                    resultByDocId.set(docId, Promise.resolve(beforeDoc as any));\n                } else if (\n                    change.operationType === 'insert' ||\n                    change.operationType === 'update' ||\n                    change.operationType === 'replace'\n                ) {\n                    resultByDocId.set(docId, mongoCollection.findOne({ _id: docId }).then(doc => {\n                        if (doc) {\n                            return mongodbDocToRxDB(primaryPath, doc);\n                        } else {\n                            const docFromChange = ensureNotFalsy(\n                                change.fullDocument as any,\n                                'change must have change.fullDocument'\n                            );\n                            const ret = mongodbDocToRxDB(primaryPath, docFromChange);\n                            ret._deleted = true;\n                            return ret;\n                        }\n                    }));\n                }\n            } else {\n                break;\n            }\n        }\n\n        changeStream.close();\n\n        const docs = await Promise.all(Array.from(resultByDocId.values()));\n        res({ docs, nextToken: nextToken as any });\n    });\n}\n\nexport async function getDocsSinceDocumentCheckpoint<MongoDocType>(\n    primaryPath: string,\n    mongoCollection: MongoCollection,\n    limit: number,\n    checkpointId?: string\n): Promise<WithDeleted<MongoDocType>[]> {\n    const query = checkpointId\n        ? { [primaryPath]: { $gt: checkpointId } }\n        : {};\n\n    const docs = await mongoCollection\n        .find(query as any)\n        .sort({ [primaryPath]: 1 })\n        .limit(limit)\n        .toArray();\n\n    return docs.map(d => mongodbDocToRxDB(primaryPath, d as any));\n}\n\n\nexport async function iterateCheckpoint<MongoDocType>(\n    primaryPath: string,\n    mongoCollection: MongoCollection,\n    limit: number,\n    checkpoint?: MongoDbCheckpointType,\n): Promise<MongoDBCheckpointIterationState<MongoDocType>> {\n    if (!checkpoint) {\n        const token = await getCurrentResumeToken(mongoCollection);\n        checkpoint = {\n            iterate: 'docs-by-id',\n            changestreamResumeToken: token\n        }\n    } else {\n        checkpoint = clone(checkpoint);\n    }\n\n    let docs: WithDeleted<MongoDocType>[] = [];\n    if (checkpoint.iterate === 'docs-by-id') {\n        docs = await getDocsSinceDocumentCheckpoint<MongoDocType>(primaryPath, mongoCollection, limit, checkpoint.docId);\n        const last = lastOfArray(docs);\n        if (last) {\n            checkpoint.docId = (last as any)[primaryPath];\n        }\n    } else {\n        const result = await getDocsSinceChangestreamCheckpoint<MongoDocType>(primaryPath, mongoCollection, checkpoint.changestreamResumeToken, limit);\n        docs = result.docs;\n        checkpoint.changestreamResumeToken = result.nextToken;\n    }\n\n    /**\n     * If we have to toggle from docs-by-id to changestream iteration\n     * mode, the docs array might not be full while we still have some docs left.\n     */\n    if (checkpoint.iterate === 'docs-by-id' && docs.length < limit) {\n        const ids = new Set<string>();\n        docs.forEach(d => ids.add((d as any)[primaryPath]));\n        const fillUp = await getDocsSinceChangestreamCheckpoint<MongoDocType>(\n            primaryPath,\n            mongoCollection,\n            checkpoint.changestreamResumeToken,\n            limit\n        );\n\n        checkpoint.iterate = 'changestream';\n        checkpoint.changestreamResumeToken = fillUp.nextToken;\n\n        fillUp.docs.forEach(doc => {\n            const id = (doc as any)[primaryPath];\n            if (ids.has(id)) {\n                docs = docs.filter(d => (d as any)[primaryPath] !== id);\n            }\n            docs.push(doc);\n        });\n    }\n\n    return {\n        docs,\n        checkpoint\n    };\n}\n"],"mappings":"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","ignoreList":[]}