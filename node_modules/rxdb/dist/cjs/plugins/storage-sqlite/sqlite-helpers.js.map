{"version":3,"file":"sqlite-helpers.js","names":["_index","require","NON_IMPLEMENTED_OPERATOR_QUERY_BATCH_SIZE","exports","DATABASE_STATE_BY_NAME","Map","RX_STORAGE_NAME_SQLITE","SQLITE_IN_MEMORY_DB_NAME","getDatabaseConnection","sqliteBasics","databaseName","state","get","database","open","openConnections","set","Error","debugId","closeDatabaseConnection","delete","then","db","close","getDataFromResultRow","row","Array","isArray","data","getSQLiteInsertSQL","collectionName","primaryPath","docData","query","params","_rev","_deleted","_meta","lwt","JSON","stringify","context","method","getSQLiteUpdateSQL","tableName","writeRow","document","TX_QUEUE_BY_DATABASE","WeakMap","sqliteTransaction","handler","queue","PROMISE_RESOLVE_VOID","openSqliteTransaction","handlerResult","finishSqliteTransaction","openedTransaction","run","err","console","log","errorAsJson","errorToPlainJson","dir","message","includes","promiseWait","mode","catch","error","PARAM_KEY","ensureParamsCountIsCorrect","queryWithParams","paramsCount","length","paramKeyCount","split","boolParamsToInt","map","p"],"sources":["../../../../src/plugins/storage-sqlite/sqlite-helpers.ts"],"sourcesContent":["import {\n    BulkWriteRow,\n    RxDocumentData,\n    PROMISE_RESOLVE_VOID,\n    promiseWait,\n    errorToPlainJson,\n    MaybePromise\n} from '../../index.ts';\nimport type {\n    SQLResultRow,\n    SQLiteBasics,\n    SQLiteDatabaseClass,\n    SQLiteQueryWithParams\n} from './sqlite-types.ts';\n\nexport const NON_IMPLEMENTED_OPERATOR_QUERY_BATCH_SIZE = 50;\nexport type DatabaseState = {\n    database: Promise<SQLiteDatabaseClass>;\n    openConnections: number;\n    sqliteBasics: SQLiteBasics<SQLiteDatabaseClass>;\n}\nexport const DATABASE_STATE_BY_NAME: Map<string, DatabaseState> = new Map();\nexport const RX_STORAGE_NAME_SQLITE = 'sqlite';\n\n\n/**\n * @link https://www.sqlite.org/inmemorydb.html\n */\nexport const SQLITE_IN_MEMORY_DB_NAME = ':memory:';\n\nexport function getDatabaseConnection(\n    sqliteBasics: SQLiteBasics<any>,\n    databaseName: string\n): Promise<SQLiteDatabaseClass> {\n    let state = DATABASE_STATE_BY_NAME.get(databaseName);\n    if (!state) {\n        state = {\n            database: sqliteBasics.open(databaseName),\n            sqliteBasics,\n            openConnections: 1\n        };\n        DATABASE_STATE_BY_NAME.set(databaseName, state);\n    } else {\n        if (state.sqliteBasics !== sqliteBasics && databaseName !== SQLITE_IN_MEMORY_DB_NAME) {\n            throw new Error('opened db with different creator method ' + databaseName + ' ' + state.sqliteBasics.debugId + ' ' + sqliteBasics.debugId);\n        }\n        state.openConnections = state.openConnections + 1;\n    }\n    return state.database;\n}\n\nexport function closeDatabaseConnection(\n    databaseName: string,\n    sqliteBasics: SQLiteBasics<any>\n): MaybePromise<void> {\n    const state = DATABASE_STATE_BY_NAME.get(databaseName);\n    if (state) {\n        state.openConnections = state.openConnections - 1;\n        if (state.openConnections === 0) {\n            DATABASE_STATE_BY_NAME.delete(databaseName);\n            return state.database.then(db => sqliteBasics.close(db));\n        }\n    }\n}\n\nexport function getDataFromResultRow(row: SQLResultRow): string {\n    if (!row) {\n        return row;\n    }\n    if (Array.isArray(row)) {\n        if (row[4]) {\n            return row[4];\n        } else {\n            return row[0];\n        }\n    } else {\n        return row.data;\n    }\n}\n\nexport function getSQLiteInsertSQL<RxDocType>(\n    collectionName: string,\n    primaryPath: keyof RxDocType,\n    docData: RxDocumentData<RxDocType>\n): SQLiteQueryWithParams {\n    // language=SQL\n    const query = `\n        INSERT INTO \"${collectionName}\" (\n            id,\n            revision,\n            deleted,\n            lastWriteTime,\n            data\n        ) VALUES (\n            ?,\n            ?,\n            ?,\n            ?,\n            ?\n        );\n    `;\n    const params = [\n        docData[primaryPath] as string,\n        docData._rev,\n        docData._deleted ? 1 : 0,\n        docData._meta.lwt,\n        JSON.stringify(docData)\n    ];\n    return {\n        query,\n        params,\n        context: {\n            method: 'getSQLiteInsertSQL',\n            data: {\n                collectionName,\n                primaryPath\n            }\n        }\n    };\n}\n\nexport function getSQLiteUpdateSQL<RxDocType>(\n    tableName: string,\n    primaryPath: keyof RxDocType,\n    writeRow: BulkWriteRow<RxDocType>\n): SQLiteQueryWithParams {\n    const docData = writeRow.document;\n    // language=SQL\n    const query = `\n    UPDATE \"${tableName}\"\n    SET \n        revision = ?,\n        deleted = ?,\n        lastWriteTime = ?,\n        data = json(?)\n    WHERE\n        id = ?\n    `;\n    const params = [\n        docData._rev,\n        docData._deleted ? 1 : 0,\n        docData._meta.lwt,\n        JSON.stringify(docData),\n        docData[primaryPath] as string,\n    ];\n    return {\n        query,\n        params,\n        context: {\n            method: 'getSQLiteUpdateSQL',\n            data: {\n                tableName,\n                primaryPath\n            }\n        }\n    };\n};\n\n\nexport const TX_QUEUE_BY_DATABASE: WeakMap<SQLiteDatabaseClass, Promise<void>> = new WeakMap();\nexport function sqliteTransaction(\n    database: SQLiteDatabaseClass,\n    sqliteBasics: SQLiteBasics<any>,\n    handler: () => Promise<'COMMIT' | 'ROLLBACK'>,\n    /**\n     * Context will be logged\n     * if the commit does error.\n     */\n    context?: any\n) {\n    let queue = TX_QUEUE_BY_DATABASE.get(database);\n    if (!queue) {\n        queue = PROMISE_RESOLVE_VOID;\n    }\n    queue = queue.then(async () => {\n        await openSqliteTransaction(database, sqliteBasics);\n        const handlerResult = await handler();\n        await finishSqliteTransaction(database, sqliteBasics, handlerResult, context);\n    });\n    TX_QUEUE_BY_DATABASE.set(database, queue);\n    return queue;\n}\n\n/**\n * TODO instead of doing a while loop, we should find a way to listen when the\n * other transaction is committed.\n */\nexport async function openSqliteTransaction(\n    database: SQLiteDatabaseClass,\n    sqliteBasics: SQLiteBasics<any>\n) {\n    let openedTransaction = false;\n    while (!openedTransaction) {\n        try {\n            await sqliteBasics.run(\n                database,\n                {\n                    query: 'BEGIN;',\n                    params: [],\n                    context: {\n                        method: 'openSqliteTransaction',\n                        data: ''\n                    }\n                }\n            );\n            openedTransaction = true;\n        } catch (err: any) {\n            console.log('open transaction error (will retry):');\n            const errorAsJson = errorToPlainJson(err);\n            console.log(errorAsJson);\n            console.dir(err);\n            if (\n                err.message && (\n                    err.message.includes('Database is closed') ||\n                    err.message.includes('API misuse')\n                )\n            ) {\n                throw err;\n            }\n            // wait one tick to not fully block the cpu on errors.\n            await promiseWait(0);\n        }\n    }\n    return;\n}\nexport function finishSqliteTransaction(\n    database: SQLiteDatabaseClass,\n    sqliteBasics: SQLiteBasics<any>,\n    mode: 'COMMIT' | 'ROLLBACK',\n    /**\n     * Context will be logged\n     * if the commit does error.\n     */\n    context?: any\n) {\n    return sqliteBasics.run(\n        database,\n        {\n            query: mode + ';',\n            params: [],\n            context: {\n                method: 'finishSqliteTransaction',\n                data: mode\n            }\n        }\n    ).catch(err => {\n        if (context) {\n            console.error('cannot close transaction (mode: ' + mode + ')');\n            console.log(JSON.stringify(context, null, 4));\n        }\n        throw err;\n    });\n}\n\n\nexport const PARAM_KEY = '?';\n\n\nexport function ensureParamsCountIsCorrect(queryWithParams: SQLiteQueryWithParams) {\n    const paramsCount = queryWithParams.params.length;\n    const paramKeyCount = queryWithParams.query.split(PARAM_KEY).length - 1;\n    if (paramsCount !== paramKeyCount) {\n        throw new Error('ensureParamsCountIsCorrect() wrong param count: ' + JSON.stringify(queryWithParams));\n    }\n}\n\n/**\n * SQLite itself does not know about boolean types\n * and uses integers instead.\n * So some libraries need to bind integers and fail on booleans.\n * @link https://stackoverflow.com/a/2452569/3443137\n * This method transforms all boolean params to the\n * correct int representation.\n */\nexport function boolParamsToInt(params: any[]): any[] {\n    return params.map(p => {\n        if (typeof p === 'boolean') {\n            if (p) {\n                return 1;\n            } else {\n                return 0;\n            }\n        } else {\n            return p;\n        }\n    });\n}\n"],"mappings":"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","ignoreList":[]}