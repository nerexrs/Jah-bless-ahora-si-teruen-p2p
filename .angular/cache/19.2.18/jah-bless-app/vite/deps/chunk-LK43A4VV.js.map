{
  "version": 3,
  "sources": ["../../../../../../node_modules/rxdb/dist/esm/rx-schema.js", "../../../../../../node_modules/rxdb/dist/esm/rx-change-event.js", "../../../../../../node_modules/rxdb/dist/esm/incremental-write.js", "../../../../../../node_modules/rxdb/dist/esm/rx-document.js", "../../../../../../node_modules/rxdb/dist/esm/query-cache.js", "../../../../../../node_modules/rxdb/dist/esm/doc-cache.js", "../../../../../../node_modules/rxdb/dist/esm/rx-query-single-result.js", "../../../../../../node_modules/event-reduce-js/dist/esm/src/util.js", "../../../../../../node_modules/event-reduce-js/dist/esm/src/states/state-resolver.js", "../../../../../../node_modules/event-reduce-js/dist/esm/src/states/index.js", "../../../../../../node_modules/array-push-at-sort-position/dist/esm/index.js", "../../../../../../node_modules/event-reduce-js/dist/esm/src/actions/action-functions.js", "../../../../../../node_modules/event-reduce-js/dist/esm/src/actions/index.js", "../../../../../../node_modules/binary-decision-diagram/dist/esm/src/minimal-string/string-format.js", "../../../../../../node_modules/binary-decision-diagram/dist/esm/src/util.js", "../../../../../../node_modules/binary-decision-diagram/dist/esm/src/minimal-string/minimal-string-to-simple-bdd.js", "../../../../../../node_modules/binary-decision-diagram/dist/esm/src/minimal-string/resolve-with-simple-bdd.js", "../../../../../../node_modules/event-reduce-js/dist/esm/src/bdd/bdd.generated.js", "../../../../../../node_modules/event-reduce-js/dist/esm/src/index.js", "../../../../../../node_modules/rxdb/dist/esm/event-reduce.js", "../../../../../../node_modules/rxdb/dist/esm/rx-query.js", "../../../../../../node_modules/rxdb/dist/esm/rx-database-internal-store.js", "../../../../../../node_modules/rxdb/dist/esm/rx-collection-helper.js", "../../../../../../node_modules/rxdb/dist/esm/rx-document-prototype-merge.js", "../../../../../../node_modules/rxdb/dist/esm/replication-protocol/default-conflict-handler.js", "../../../../../../node_modules/rxdb/dist/esm/change-event-buffer.js", "../../../../../../node_modules/rxdb/dist/esm/rx-collection.js", "../../../../../../node_modules/custom-idle-queue/dist/es/index.js", "../../../../../../node_modules/rxdb/dist/esm/rx-database.js"],
  "sourcesContent": ["import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { overwriteGetterForCaching, isMaybeReadonlyArray, deepEqual } from \"./plugins/utils/index.js\";\nimport { newRxError } from \"./rx-error.js\";\nimport { runPluginHooks } from \"./hooks.js\";\nimport { fillWithDefaultSettings, getComposedPrimaryKeyOfDocumentData, getFinalFields, getPrimaryFieldOfPrimaryKey, getSchemaByObjectPath, normalizeRxJsonSchema } from \"./rx-schema-helper.js\";\nimport { overwritable } from \"./overwritable.js\";\nexport var RxSchema = /*#__PURE__*/function () {\n  function RxSchema(jsonSchema, hashFunction) {\n    this.jsonSchema = jsonSchema;\n    this.hashFunction = hashFunction;\n    this.indexes = getIndexes(this.jsonSchema);\n\n    // primary is always required\n    this.primaryPath = getPrimaryFieldOfPrimaryKey(this.jsonSchema.primaryKey);\n\n    /**\n     * Many people accidentally put in wrong schema state\n     * without the dev-mode plugin, so we need this check here\n     * even in non-dev-mode.\n     */\n    if (!jsonSchema.properties[this.primaryPath].maxLength) {\n      throw newRxError('SC39', {\n        schema: jsonSchema\n      });\n    }\n    this.finalFields = getFinalFields(this.jsonSchema);\n  }\n  var _proto = RxSchema.prototype;\n  /**\n   * checks if a given change on a document is allowed\n   * Ensures that:\n   * - final fields are not modified\n   * @throws {Error} if not valid\n   */\n  _proto.validateChange = function validateChange(dataBefore, dataAfter) {\n    this.finalFields.forEach(fieldName => {\n      if (!deepEqual(dataBefore[fieldName], dataAfter[fieldName])) {\n        throw newRxError('DOC9', {\n          dataBefore,\n          dataAfter,\n          fieldName,\n          schema: this.jsonSchema\n        });\n      }\n    });\n  }\n\n  /**\n   * creates the schema-based document-prototype,\n   * see RxCollection.getDocumentPrototype()\n   */;\n  _proto.getDocumentPrototype = function getDocumentPrototype() {\n    var proto = {};\n\n    /**\n     * On the top level, we know all keys\n     * and therefore do not have to create a new Proxy object\n     * for each document. Instead we define the getter in the prototype once.\n     */\n    var pathProperties = getSchemaByObjectPath(this.jsonSchema, '');\n    Object.keys(pathProperties).forEach(key => {\n      var fullPath = key;\n\n      // getter - value\n      proto.__defineGetter__(key, function () {\n        if (!this.get || typeof this.get !== 'function') {\n          /**\n           * When an object gets added to the state of a vuejs-component,\n           * it happens that this getter is called with another scope.\n           * To prevent errors, we have to return undefined in this case\n           */\n          return undefined;\n        }\n        var ret = this.get(fullPath);\n        return ret;\n      });\n      // getter - observable$\n      Object.defineProperty(proto, key + '$', {\n        get: function () {\n          return this.get$(fullPath);\n        },\n        enumerable: false,\n        configurable: false\n      });\n      // getter - reactivity$$\n      Object.defineProperty(proto, key + '$$', {\n        get: function () {\n          return this.get$$(fullPath);\n        },\n        enumerable: false,\n        configurable: false\n      });\n      // getter - populate_\n      Object.defineProperty(proto, key + '_', {\n        get: function () {\n          return this.populate(fullPath);\n        },\n        enumerable: false,\n        configurable: false\n      });\n    });\n    overwriteGetterForCaching(this, 'getDocumentPrototype', () => proto);\n    return proto;\n  };\n  _proto.getPrimaryOfDocumentData = function getPrimaryOfDocumentData(documentData) {\n    return getComposedPrimaryKeyOfDocumentData(this.jsonSchema, documentData);\n  };\n  return _createClass(RxSchema, [{\n    key: \"version\",\n    get: function () {\n      return this.jsonSchema.version;\n    }\n  }, {\n    key: \"defaultValues\",\n    get: function () {\n      var values = {};\n      Object.entries(this.jsonSchema.properties).filter(([, v]) => Object.prototype.hasOwnProperty.call(v, 'default')).forEach(([k, v]) => values[k] = v.default);\n      return overwriteGetterForCaching(this, 'defaultValues', values);\n    }\n\n    /**\n     * @overrides itself on the first call\n     */\n  }, {\n    key: \"hash\",\n    get: function () {\n      return overwriteGetterForCaching(this, 'hash', this.hashFunction(JSON.stringify(this.jsonSchema)));\n    }\n  }]);\n}();\nexport function getIndexes(jsonSchema) {\n  return (jsonSchema.indexes || []).map(index => isMaybeReadonlyArray(index) ? index : [index]);\n}\n\n/**\n * array with previous version-numbers\n */\nexport function getPreviousVersions(schema) {\n  var version = schema.version ? schema.version : 0;\n  var c = 0;\n  return new Array(version).fill(0).map(() => c++);\n}\nexport function createRxSchema(jsonSchema, hashFunction, runPreCreateHooks = true) {\n  if (runPreCreateHooks) {\n    runPluginHooks('preCreateRxSchema', jsonSchema);\n  }\n  var useJsonSchema = fillWithDefaultSettings(jsonSchema);\n  useJsonSchema = normalizeRxJsonSchema(useJsonSchema);\n  overwritable.deepFreezeWhenDevMode(useJsonSchema);\n  var schema = new RxSchema(useJsonSchema, hashFunction);\n  runPluginHooks('createRxSchema', schema);\n  return schema;\n}\nexport function isRxSchema(obj) {\n  return obj instanceof RxSchema;\n}\n\n/**\n * Used as helper function the generate the document type out of the schema via typescript.\n * @link https://github.com/pubkey/rxdb/discussions/3467\n */\nexport function toTypedRxJsonSchema(schema) {\n  return schema;\n}\n", "/**\n * RxChangeEvents a emitted when something in the database changes\n * they can be grabbed by the observables of database, collection and document\n */\n\nimport { overwritable } from \"./overwritable.js\";\nimport { appendToArray, getFromMapOrCreate } from \"./plugins/utils/index.js\";\nexport function getDocumentDataOfRxChangeEvent(rxChangeEvent) {\n  if (rxChangeEvent.documentData) {\n    return rxChangeEvent.documentData;\n  } else {\n    return rxChangeEvent.previousDocumentData;\n  }\n}\n\n/**\n * Might return null which means an\n * already deleted document got modified but still is deleted.\n * These kind of events are not relevant for the event-reduce algorithm\n * and must be filtered out.\n */\nexport function rxChangeEventToEventReduceChangeEvent(rxChangeEvent) {\n  switch (rxChangeEvent.operation) {\n    case 'INSERT':\n      return {\n        operation: rxChangeEvent.operation,\n        id: rxChangeEvent.documentId,\n        doc: rxChangeEvent.documentData,\n        previous: null\n      };\n    case 'UPDATE':\n      return {\n        operation: rxChangeEvent.operation,\n        id: rxChangeEvent.documentId,\n        doc: overwritable.deepFreezeWhenDevMode(rxChangeEvent.documentData),\n        previous: rxChangeEvent.previousDocumentData ? rxChangeEvent.previousDocumentData : 'UNKNOWN'\n      };\n    case 'DELETE':\n      return {\n        operation: rxChangeEvent.operation,\n        id: rxChangeEvent.documentId,\n        doc: null,\n        previous: rxChangeEvent.previousDocumentData\n      };\n  }\n}\n\n/**\n * Flattens the given events into a single array of events.\n * Used mostly in tests.\n */\nexport function flattenEvents(input) {\n  var output = [];\n  if (Array.isArray(input)) {\n    input.forEach(inputItem => {\n      var add = flattenEvents(inputItem);\n      appendToArray(output, add);\n    });\n  } else {\n    if (input.id && input.events) {\n      // is bulk\n      input.events.forEach(ev => output.push(ev));\n    } else {\n      output.push(input);\n    }\n  }\n  var usedIds = new Set();\n  var nonDuplicate = [];\n  function getEventId(ev) {\n    return [ev.documentId, ev.documentData ? ev.documentData._rev : '', ev.previousDocumentData ? ev.previousDocumentData._rev : ''].join('|');\n  }\n  output.forEach(ev => {\n    var eventId = getEventId(ev);\n    if (!usedIds.has(eventId)) {\n      usedIds.add(eventId);\n      nonDuplicate.push(ev);\n    }\n  });\n  return nonDuplicate;\n}\nvar EVENT_BULK_CACHE = new Map();\nexport function rxChangeEventBulkToRxChangeEvents(eventBulk) {\n  return getFromMapOrCreate(EVENT_BULK_CACHE, eventBulk, () => {\n    var events = new Array(eventBulk.events.length);\n    var rawEvents = eventBulk.events;\n    var collectionName = eventBulk.collectionName;\n    var isLocal = eventBulk.isLocal;\n    var deepFreezeWhenDevMode = overwritable.deepFreezeWhenDevMode;\n    for (var index = 0; index < rawEvents.length; index++) {\n      var event = rawEvents[index];\n      events[index] = {\n        documentId: event.documentId,\n        collectionName,\n        isLocal,\n        operation: event.operation,\n        documentData: deepFreezeWhenDevMode(event.documentData),\n        previousDocumentData: deepFreezeWhenDevMode(event.previousDocumentData)\n      };\n    }\n    return events;\n  });\n}\n", "import { isBulkWriteConflictError, rxStorageWriteErrorToRxError } from \"./rx-error.js\";\nimport { clone, ensureNotFalsy, getFromMapOrCreate, getFromMapOrThrow, getHeightOfRevision, stripMetaDataFromDocument } from \"./plugins/utils/index.js\";\nimport { getWrittenDocumentsFromBulkWriteResponse } from \"./rx-storage-helper.js\";\n/**\n * The incremental write queue\n * batches up all incremental writes to a collection\n * so that performance can be improved by:\n * - Running only one write even when there are multiple modifications to the same document.\n * - Run all writes ins a single bulkWrite() call even when there are writes to many documents.\n */\nexport var IncrementalWriteQueue = /*#__PURE__*/function () {\n  function IncrementalWriteQueue(storageInstance, primaryPath,\n  // can be used to run hooks etc.\n  preWrite, postWrite) {\n    this.queueByDocId = new Map();\n    this.isRunning = false;\n    this.storageInstance = storageInstance;\n    this.primaryPath = primaryPath;\n    this.preWrite = preWrite;\n    this.postWrite = postWrite;\n  }\n  var _proto = IncrementalWriteQueue.prototype;\n  _proto.addWrite = function addWrite(lastKnownDocumentState, modifier) {\n    var docId = lastKnownDocumentState[this.primaryPath];\n    var ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);\n    var ret = new Promise((resolve, reject) => {\n      var item = {\n        lastKnownDocumentState,\n        modifier,\n        resolve,\n        reject\n      };\n      ensureNotFalsy(ar).push(item);\n      this.triggerRun();\n    });\n    return ret;\n  };\n  _proto.triggerRun = async function triggerRun() {\n    if (this.isRunning === true || this.queueByDocId.size === 0) {\n      // already running\n      return;\n    }\n    this.isRunning = true;\n    var writeRows = [];\n\n    /**\n     * 'take over' so that while the async functions runs,\n     * new incremental updates could be added from the outside.\n     */\n    var itemsById = this.queueByDocId;\n    this.queueByDocId = new Map();\n    await Promise.all(Array.from(itemsById.entries()).map(async ([_docId, items]) => {\n      var oldData = findNewestOfDocumentStates(items.map(i => i.lastKnownDocumentState));\n      var newData = oldData;\n      for (var item of items) {\n        try {\n          newData = await item.modifier(\n          /**\n           * We have to clone() each time because the modifier\n           * might throw while it already changed some properties\n           * of the document.\n           */\n          clone(newData));\n        } catch (err) {\n          item.reject(err);\n          item.reject = () => {};\n          item.resolve = () => {};\n        }\n      }\n      try {\n        await this.preWrite(newData, oldData);\n      } catch (err) {\n        /**\n         * If the before-hooks fail,\n         * we reject all of the writes because it is\n         * not possible to determine which one is to blame.\n         */\n        items.forEach(item => item.reject(err));\n        return;\n      }\n      writeRows.push({\n        previous: oldData,\n        document: newData\n      });\n    }));\n    var writeResult = writeRows.length > 0 ? await this.storageInstance.bulkWrite(writeRows, 'incremental-write') : {\n      error: []\n    };\n\n    // process success\n    await Promise.all(getWrittenDocumentsFromBulkWriteResponse(this.primaryPath, writeRows, writeResult).map(result => {\n      var docId = result[this.primaryPath];\n      this.postWrite(result);\n      var items = getFromMapOrThrow(itemsById, docId);\n      items.forEach(item => item.resolve(result));\n    }));\n\n    // process errors\n    writeResult.error.forEach(error => {\n      var docId = error.documentId;\n      var items = getFromMapOrThrow(itemsById, docId);\n      var isConflict = isBulkWriteConflictError(error);\n      if (isConflict) {\n        // had conflict -> retry afterwards\n        var ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);\n        /**\n         * Add the items back to this.queueByDocId\n         * by maintaining the original order.\n         */\n        items.reverse().forEach(item => {\n          item.lastKnownDocumentState = ensureNotFalsy(isConflict.documentInDb);\n          ensureNotFalsy(ar).unshift(item);\n        });\n      } else {\n        // other error -> must be thrown\n        var rxError = rxStorageWriteErrorToRxError(error);\n        items.forEach(item => item.reject(rxError));\n      }\n    });\n    this.isRunning = false;\n\n    /**\n     * Always trigger another run\n     * because in between there might be new items\n     * been added to the queue.\n     */\n    return this.triggerRun();\n  };\n  return IncrementalWriteQueue;\n}();\nexport function modifierFromPublicToInternal(publicModifier) {\n  var ret = async docData => {\n    var withoutMeta = stripMetaDataFromDocument(docData);\n    withoutMeta._deleted = docData._deleted;\n    var modified = await publicModifier(withoutMeta);\n    var reattachedMeta = Object.assign({}, modified, {\n      _meta: docData._meta,\n      _attachments: docData._attachments,\n      _rev: docData._rev,\n      _deleted: typeof modified._deleted !== 'undefined' ? modified._deleted : docData._deleted\n    });\n    if (typeof reattachedMeta._deleted === 'undefined') {\n      reattachedMeta._deleted = false;\n    }\n    return reattachedMeta;\n  };\n  return ret;\n}\nexport function findNewestOfDocumentStates(docs) {\n  var newest = docs[0];\n  var newestRevisionHeight = getHeightOfRevision(newest._rev);\n  docs.forEach(doc => {\n    var height = getHeightOfRevision(doc._rev);\n    if (height > newestRevisionHeight) {\n      newest = doc;\n      newestRevisionHeight = height;\n    }\n  });\n  return newest;\n}\n", "import { distinctUntilChanged, filter, map, shareReplay, startWith } from 'rxjs/operators';\nimport { clone, trimDots, pluginMissing, flatClone, PROMISE_RESOLVE_NULL, RXJS_SHARE_REPLAY_DEFAULTS, getProperty, getFromMapOrCreate, ensureNotFalsy } from \"./plugins/utils/index.js\";\nimport { newRxError } from \"./rx-error.js\";\nimport { runPluginHooks } from \"./hooks.js\";\nimport { getDocumentDataOfRxChangeEvent } from \"./rx-change-event.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { getSchemaByObjectPath } from \"./rx-schema-helper.js\";\nimport { getWrittenDocumentsFromBulkWriteResponse, throwIfIsStorageWriteError } from \"./rx-storage-helper.js\";\nimport { modifierFromPublicToInternal } from \"./incremental-write.js\";\nexport var basePrototype = {\n  get primaryPath() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this.collection.schema.primaryPath;\n  },\n  get primary() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this._data[_this.primaryPath];\n  },\n  get revision() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this._data._rev;\n  },\n  get deleted$() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this.$.pipe(map(d => d._data._deleted));\n  },\n  get deleted$$() {\n    var _this = this;\n    var reactivity = _this.collection.database.getReactivityFactory();\n    return reactivity.fromObservable(_this.deleted$, _this.getLatest().deleted, _this.collection.database);\n  },\n  get deleted() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this._data._deleted;\n  },\n  getLatest() {\n    var latestDocData = this.collection._docCache.getLatestDocumentData(this.primary);\n    return this.collection._docCache.getCachedRxDocument(latestDocData);\n  },\n  /**\n   * returns the observable which emits the plain-data of this document\n   */\n  get $() {\n    var _this = this;\n    var id = this.primary;\n    return _this.collection.eventBulks$.pipe(filter(bulk => !bulk.isLocal), map(bulk => bulk.events.find(ev => ev.documentId === id)), filter(event => !!event), map(changeEvent => getDocumentDataOfRxChangeEvent(ensureNotFalsy(changeEvent))), startWith(_this.collection._docCache.getLatestDocumentData(id)), distinctUntilChanged((prev, curr) => prev._rev === curr._rev), map(docData => this.collection._docCache.getCachedRxDocument(docData)), shareReplay(RXJS_SHARE_REPLAY_DEFAULTS));\n  },\n  get $$() {\n    var _this = this;\n    var reactivity = _this.collection.database.getReactivityFactory();\n    return reactivity.fromObservable(_this.$, _this.getLatest()._data, _this.collection.database);\n  },\n  /**\n   * returns observable of the value of the given path\n   */\n  get$(path) {\n    if (overwritable.isDevMode()) {\n      if (path.includes('.item.')) {\n        throw newRxError('DOC1', {\n          path\n        });\n      }\n      if (path === this.primaryPath) {\n        throw newRxError('DOC2');\n      }\n\n      // final fields cannot be modified and so also not observed\n      if (this.collection.schema.finalFields.includes(path)) {\n        throw newRxError('DOC3', {\n          path\n        });\n      }\n      var schemaObj = getSchemaByObjectPath(this.collection.schema.jsonSchema, path);\n      if (!schemaObj) {\n        throw newRxError('DOC4', {\n          path\n        });\n      }\n    }\n    return this.$.pipe(map(data => getProperty(data, path)), distinctUntilChanged());\n  },\n  get$$(path) {\n    var obs = this.get$(path);\n    var reactivity = this.collection.database.getReactivityFactory();\n    return reactivity.fromObservable(obs, this.getLatest().get(path), this.collection.database);\n  },\n  /**\n   * populate the given path\n   */\n  populate(path) {\n    var schemaObj = getSchemaByObjectPath(this.collection.schema.jsonSchema, path);\n    var value = this.get(path);\n    if (!value) {\n      return PROMISE_RESOLVE_NULL;\n    }\n    if (!schemaObj) {\n      throw newRxError('DOC5', {\n        path\n      });\n    }\n    if (!schemaObj.ref) {\n      throw newRxError('DOC6', {\n        path,\n        schemaObj\n      });\n    }\n    var refCollection = this.collection.database.collections[schemaObj.ref];\n    if (!refCollection) {\n      throw newRxError('DOC7', {\n        ref: schemaObj.ref,\n        path,\n        schemaObj\n      });\n    }\n    if (schemaObj.type === 'array') {\n      return refCollection.findByIds(value).exec().then(res => {\n        var valuesIterator = res.values();\n        return Array.from(valuesIterator);\n      });\n    } else {\n      return refCollection.findOne(value).exec();\n    }\n  },\n  /**\n   * get data by objectPath\n   * @hotPath Performance here is really important,\n   * run some tests before changing anything.\n   */\n  get(objPath) {\n    return getDocumentProperty(this, objPath);\n  },\n  toJSON(withMetaFields = false) {\n    if (!withMetaFields) {\n      var data = flatClone(this._data);\n      delete data._rev;\n      delete data._attachments;\n      delete data._deleted;\n      delete data._meta;\n      return overwritable.deepFreezeWhenDevMode(data);\n    } else {\n      return overwritable.deepFreezeWhenDevMode(this._data);\n    }\n  },\n  toMutableJSON(withMetaFields = false) {\n    return clone(this.toJSON(withMetaFields));\n  },\n  /**\n   * updates document\n   * @overwritten by plugin (optional)\n   * @param updateObj mongodb-like syntax\n   */\n  update(_updateObj) {\n    throw pluginMissing('update');\n  },\n  incrementalUpdate(_updateObj) {\n    throw pluginMissing('update');\n  },\n  updateCRDT(_updateObj) {\n    throw pluginMissing('crdt');\n  },\n  putAttachment() {\n    throw pluginMissing('attachments');\n  },\n  putAttachmentBase64() {\n    throw pluginMissing('attachments');\n  },\n  getAttachment() {\n    throw pluginMissing('attachments');\n  },\n  allAttachments() {\n    throw pluginMissing('attachments');\n  },\n  get allAttachments$() {\n    throw pluginMissing('attachments');\n  },\n  async modify(mutationFunction,\n  // used by some plugins that wrap the method\n  _context) {\n    var oldData = this._data;\n    var newData = await modifierFromPublicToInternal(mutationFunction)(oldData);\n    return this._saveData(newData, oldData);\n  },\n  /**\n   * runs an incremental update over the document\n   * @param function that takes the document-data and returns a new data-object\n   */\n  incrementalModify(mutationFunction,\n  // used by some plugins that wrap the method\n  _context) {\n    return this.collection.incrementalWriteQueue.addWrite(this._data, modifierFromPublicToInternal(mutationFunction)).then(result => this.collection._docCache.getCachedRxDocument(result));\n  },\n  patch(patch) {\n    var oldData = this._data;\n    var newData = clone(oldData);\n    Object.entries(patch).forEach(([k, v]) => {\n      newData[k] = v;\n    });\n    return this._saveData(newData, oldData);\n  },\n  /**\n   * patches the given properties\n   */\n  incrementalPatch(patch) {\n    return this.incrementalModify(docData => {\n      Object.entries(patch).forEach(([k, v]) => {\n        docData[k] = v;\n      });\n      return docData;\n    });\n  },\n  /**\n   * saves the new document-data\n   * and handles the events\n   */\n  async _saveData(newData, oldData) {\n    newData = flatClone(newData);\n\n    // deleted documents cannot be changed\n    if (this._data._deleted) {\n      throw newRxError('DOC11', {\n        id: this.primary,\n        document: this\n      });\n    }\n    await beforeDocumentUpdateWrite(this.collection, newData, oldData);\n    var writeRows = [{\n      previous: oldData,\n      document: newData\n    }];\n    var writeResult = await this.collection.storageInstance.bulkWrite(writeRows, 'rx-document-save-data');\n    var isError = writeResult.error[0];\n    throwIfIsStorageWriteError(this.collection, this.primary, newData, isError);\n    await this.collection._runHooks('post', 'save', newData, this);\n    return this.collection._docCache.getCachedRxDocument(getWrittenDocumentsFromBulkWriteResponse(this.collection.schema.primaryPath, writeRows, writeResult)[0]);\n  },\n  /**\n   * Remove the document.\n   * Notice that there is no hard delete,\n   * instead deleted documents get flagged with _deleted=true.\n   */\n  async remove() {\n    if (this.deleted) {\n      return Promise.reject(newRxError('DOC13', {\n        document: this,\n        id: this.primary\n      }));\n    }\n    var removeResult = await this.collection.bulkRemove([this]);\n    if (removeResult.error.length > 0) {\n      var error = removeResult.error[0];\n      throwIfIsStorageWriteError(this.collection, this.primary, this._data, error);\n    }\n    return removeResult.success[0];\n  },\n  incrementalRemove() {\n    return this.incrementalModify(async docData => {\n      await this.collection._runHooks('pre', 'remove', docData, this);\n      docData._deleted = true;\n      return docData;\n    }).then(async newDoc => {\n      await this.collection._runHooks('post', 'remove', newDoc._data, newDoc);\n      return newDoc;\n    });\n  },\n  close() {\n    throw newRxError('DOC14');\n  }\n};\nexport function createRxDocumentConstructor(proto = basePrototype) {\n  var constructor = function RxDocumentConstructor(collection, docData) {\n    this.collection = collection;\n\n    // assume that this is always equal to the doc-data in the database\n    this._data = docData;\n    this._propertyCache = new Map();\n\n    /**\n     * because of the prototype-merge,\n     * we can not use the native instanceof operator\n     */\n    this.isInstanceOfRxDocument = true;\n  };\n  constructor.prototype = proto;\n  return constructor;\n}\nexport function createWithConstructor(constructor, collection, jsonData) {\n  var doc = new constructor(collection, jsonData);\n  runPluginHooks('createRxDocument', doc);\n  return doc;\n}\nexport function isRxDocument(obj) {\n  return typeof obj === 'object' && obj !== null && 'isInstanceOfRxDocument' in obj;\n}\nexport function beforeDocumentUpdateWrite(collection, newData, oldData) {\n  /**\n   * Meta values must always be merged\n   * instead of overwritten.\n   * This ensures that different plugins do not overwrite\n   * each others meta properties.\n   */\n  newData._meta = Object.assign({}, oldData._meta, newData._meta);\n\n  // ensure modifications are ok\n  if (overwritable.isDevMode()) {\n    collection.schema.validateChange(oldData, newData);\n  }\n  return collection._runHooks('pre', 'save', newData, oldData);\n}\nfunction getDocumentProperty(doc, objPath) {\n  return getFromMapOrCreate(doc._propertyCache, objPath, () => {\n    var valueObj = getProperty(doc._data, objPath);\n\n    // direct return if array or non-object\n    if (typeof valueObj !== 'object' || valueObj === null || Array.isArray(valueObj)) {\n      return overwritable.deepFreezeWhenDevMode(valueObj);\n    }\n    var proxy = new Proxy(\n    /**\n     * In dev-mode, the _data is deep-frozen\n     * so we have to flat clone here so that\n     * the proxy can work.\n     */\n    flatClone(valueObj), {\n      /**\n       * @performance is really important here\n       * because people access nested properties very often\n       * and might not be aware that this is internally using a Proxy\n       */\n      get(target, property) {\n        if (typeof property !== 'string') {\n          return target[property];\n        }\n        var lastChar = property.charAt(property.length - 1);\n        if (lastChar === '$') {\n          if (property.endsWith('$$')) {\n            var key = property.slice(0, -2);\n            return doc.get$$(trimDots(objPath + '.' + key));\n          } else {\n            var _key = property.slice(0, -1);\n            return doc.get$(trimDots(objPath + '.' + _key));\n          }\n        } else if (lastChar === '_') {\n          var _key2 = property.slice(0, -1);\n          return doc.populate(trimDots(objPath + '.' + _key2));\n        } else {\n          /**\n           * Performance shortcut\n           * In most cases access to nested properties\n           * will only access simple values which can be directly returned\n           * without creating a new Proxy or utilizing the cache.\n           */\n          var plainValue = target[property];\n          if (typeof plainValue === 'number' || typeof plainValue === 'string' || typeof plainValue === 'boolean') {\n            return plainValue;\n          }\n          return getDocumentProperty(doc, trimDots(objPath + '.' + property));\n        }\n      }\n    });\n    return proxy;\n  });\n}\n;\n", "/**\n * the query-cache makes sure that on every query-state, exactly one instance can exist\n * if you use the same mango-query more then once, it will reuse the first RxQuery\n */\n\nimport { getFromMapOrCreate, nextTick, now, requestIdlePromise } from \"./plugins/utils/index.js\";\nexport var QueryCache = /*#__PURE__*/function () {\n  function QueryCache() {\n    this._map = new Map();\n  }\n  var _proto = QueryCache.prototype;\n  /**\n   * check if an equal query is in the cache,\n   * if true, return the cached one,\n   * if false, save the given one and return it\n   */\n  _proto.getByQuery = function getByQuery(rxQuery) {\n    var stringRep = rxQuery.toString();\n    var ret = getFromMapOrCreate(this._map, stringRep, () => rxQuery);\n    return ret;\n  };\n  return QueryCache;\n}();\nexport function createQueryCache() {\n  return new QueryCache();\n}\nexport function uncacheRxQuery(queryCache, rxQuery) {\n  rxQuery.uncached = true;\n  var stringRep = rxQuery.toString();\n  queryCache._map.delete(stringRep);\n}\nexport function countRxQuerySubscribers(rxQuery) {\n  return rxQuery.refCount$.observers.length;\n}\nexport var DEFAULT_TRY_TO_KEEP_MAX = 100;\nexport var DEFAULT_UNEXECUTED_LIFETIME = 30 * 1000;\n\n/**\n * The default cache replacement policy\n * See docs-src/query-cache.md to learn how it should work.\n * Notice that this runs often and should block the cpu as less as possible\n * This is a monad which makes it easier to unit test\n */\nexport var defaultCacheReplacementPolicyMonad = (tryToKeepMax, unExecutedLifetime) => (_collection, queryCache) => {\n  if (queryCache._map.size < tryToKeepMax) {\n    return;\n  }\n  var minUnExecutedLifetime = now() - unExecutedLifetime;\n  var maybeUncache = [];\n  var queriesInCache = Array.from(queryCache._map.values());\n  for (var rxQuery of queriesInCache) {\n    // filter out queries with subscribers\n    if (countRxQuerySubscribers(rxQuery) > 0) {\n      continue;\n    }\n    // directly uncache queries that never executed and are older than unExecutedLifetime\n    if (rxQuery._lastEnsureEqual === 0 && rxQuery._creationTime < minUnExecutedLifetime) {\n      uncacheRxQuery(queryCache, rxQuery);\n      continue;\n    }\n    maybeUncache.push(rxQuery);\n  }\n  var mustUncache = maybeUncache.length - tryToKeepMax;\n  if (mustUncache <= 0) {\n    return;\n  }\n  var sortedByLastUsage = maybeUncache.sort((a, b) => a._lastEnsureEqual - b._lastEnsureEqual);\n  var toRemove = sortedByLastUsage.slice(0, mustUncache);\n  toRemove.forEach(rxQuery => uncacheRxQuery(queryCache, rxQuery));\n};\nexport var defaultCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(DEFAULT_TRY_TO_KEEP_MAX, DEFAULT_UNEXECUTED_LIFETIME);\nexport var COLLECTIONS_WITH_RUNNING_CLEANUP = new WeakSet();\n\n/**\n * Triggers the cache replacement policy after waitTime has passed.\n * We do not run this directly because at exactly the time a query is created,\n * we need all CPU to minimize latency.\n * Also this should not be triggered multiple times when waitTime is still waiting.\n */\nexport function triggerCacheReplacement(rxCollection) {\n  if (COLLECTIONS_WITH_RUNNING_CLEANUP.has(rxCollection)) {\n    // already started\n    return;\n  }\n  COLLECTIONS_WITH_RUNNING_CLEANUP.add(rxCollection);\n\n  /**\n   * Do not run directly to not reduce result latency of a new query\n   */\n  nextTick() // wait at least one tick\n  .then(() => requestIdlePromise(200)) // and then wait for the CPU to be idle\n  .then(() => {\n    if (!rxCollection.closed) {\n      rxCollection.cacheReplacementPolicy(rxCollection, rxCollection._queryCache);\n    }\n    COLLECTIONS_WITH_RUNNING_CLEANUP.delete(rxCollection);\n  });\n}\n", "import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { getFromMapOrThrow, getHeightOfRevision, overwriteGetterForCaching, requestIdlePromiseNoQueue } from \"./plugins/utils/index.js\";\nimport { overwritable } from \"./overwritable.js\";\n\n/**\n * Because we have to create many cache items,\n * we use an array instead of an object with properties\n * for better performance and less memory usage.\n * @link https://stackoverflow.com/questions/17295056/array-vs-object-efficiency-in-javascript\n */\n\n/**\n * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n */\n\n/**\n * The DocumentCache stores RxDocument objects\n * by their primary key and revision.\n * This is useful on client side applications where\n * it is not known how much memory can be used, so\n * we de-duplicate RxDocument states to save memory.\n * To not fill up the memory with old document states, the DocumentCache\n * only contains weak references to the RxDocuments themself.\n * @link https://caniuse.com/?search=weakref\n */\nexport var DocumentCache = /*#__PURE__*/function () {\n  /**\n   * Process stuff lazy to not block the CPU\n   * on critical paths.\n   */\n\n  /**\n   * Some JavaScript runtimes like QuickJS,\n   * so not have a FinalizationRegistry or WeakRef.\n   * Therefore we need a workaround which might waste a lot of memory,\n   * but at least works.\n   */\n\n  function DocumentCache(primaryPath, changes$,\n  /**\n   * A method that can create a RxDocument by the given document data.\n   */\n  documentCreator) {\n    this.cacheItemByDocId = new Map();\n    this.tasks = new Set();\n    this.registry = typeof FinalizationRegistry === 'function' ? new FinalizationRegistry(docMeta => {\n      var docId = docMeta.docId;\n      var cacheItem = this.cacheItemByDocId.get(docId);\n      if (cacheItem) {\n        cacheItem[0].delete(docMeta.revisionHeight + docMeta.lwt + '');\n        if (cacheItem[0].size === 0) {\n          /**\n           * No state of the document is cached anymore,\n           * so we can clean up.\n           */\n          this.cacheItemByDocId.delete(docId);\n        }\n      }\n    }) : undefined;\n    this.primaryPath = primaryPath;\n    this.changes$ = changes$;\n    this.documentCreator = documentCreator;\n    changes$.subscribe(events => {\n      this.tasks.add(() => {\n        var cacheItemByDocId = this.cacheItemByDocId;\n        for (var index = 0; index < events.length; index++) {\n          var event = events[index];\n          var cacheItem = cacheItemByDocId.get(event.documentId);\n          if (cacheItem) {\n            var documentData = event.documentData;\n            if (!documentData) {\n              documentData = event.previousDocumentData;\n            }\n            cacheItem[1] = documentData;\n          }\n        }\n      });\n      if (this.tasks.size <= 1) {\n        requestIdlePromiseNoQueue().then(() => {\n          this.processTasks();\n        });\n      }\n    });\n  }\n  var _proto = DocumentCache.prototype;\n  _proto.processTasks = function processTasks() {\n    if (this.tasks.size === 0) {\n      return;\n    }\n    var tasks = Array.from(this.tasks);\n    tasks.forEach(task => task());\n    this.tasks.clear();\n  }\n\n  /**\n   * Get the RxDocument from the cache\n   * and create a new one if not exits before.\n   * @overwrites itself with the actual function\n   * because this is @performance relevant.\n   * It is called on each document row for each write and read.\n   */;\n  /**\n   * Throws if not exists\n   */\n  _proto.getLatestDocumentData = function getLatestDocumentData(docId) {\n    this.processTasks();\n    var cacheItem = getFromMapOrThrow(this.cacheItemByDocId, docId);\n    return cacheItem[1];\n  };\n  _proto.getLatestDocumentDataIfExists = function getLatestDocumentDataIfExists(docId) {\n    this.processTasks();\n    var cacheItem = this.cacheItemByDocId.get(docId);\n    if (cacheItem) {\n      return cacheItem[1];\n    }\n  };\n  return _createClass(DocumentCache, [{\n    key: \"getCachedRxDocuments\",\n    get: function () {\n      var fn = getCachedRxDocumentMonad(this);\n      return overwriteGetterForCaching(this, 'getCachedRxDocuments', fn);\n    }\n  }, {\n    key: \"getCachedRxDocument\",\n    get: function () {\n      var fn = getCachedRxDocumentMonad(this);\n      return overwriteGetterForCaching(this, 'getCachedRxDocument', doc => fn([doc])[0]);\n    }\n  }]);\n}();\n\n/**\n * This function is called very very often.\n * @hotPath This is one of the most important methods for performance.\n * It is used in many places to transform the raw document data into RxDocuments.\n */\nfunction getCachedRxDocumentMonad(docCache) {\n  var primaryPath = docCache.primaryPath;\n  var cacheItemByDocId = docCache.cacheItemByDocId;\n  var registry = docCache.registry;\n  var deepFreezeWhenDevMode = overwritable.deepFreezeWhenDevMode;\n  var documentCreator = docCache.documentCreator;\n  var fn = docsData => {\n    var ret = new Array(docsData.length);\n    var registryTasks = [];\n    for (var index = 0; index < docsData.length; index++) {\n      var docData = docsData[index];\n      var docId = docData[primaryPath];\n      var revisionHeight = getHeightOfRevision(docData._rev);\n      var byRev = void 0;\n      var cachedRxDocumentWeakRef = void 0;\n      var cacheItem = cacheItemByDocId.get(docId);\n      if (!cacheItem) {\n        byRev = new Map();\n        cacheItem = [byRev, docData];\n        cacheItemByDocId.set(docId, cacheItem);\n      } else {\n        byRev = cacheItem[0];\n        cachedRxDocumentWeakRef = byRev.get(revisionHeight + docData._meta.lwt + '');\n      }\n      var cachedRxDocument = cachedRxDocumentWeakRef ? cachedRxDocumentWeakRef.deref() : undefined;\n      if (!cachedRxDocument) {\n        docData = deepFreezeWhenDevMode(docData);\n        cachedRxDocument = documentCreator(docData);\n        byRev.set(revisionHeight + docData._meta.lwt + '', createWeakRefWithFallback(cachedRxDocument));\n        if (registry) {\n          registryTasks.push(cachedRxDocument);\n        }\n      }\n      ret[index] = cachedRxDocument;\n    }\n    if (registryTasks.length > 0 && registry) {\n      /**\n       * Calling registry.register() has shown to have\n       * really bad performance. So we add the cached documents\n       * lazily.\n       */\n      docCache.tasks.add(() => {\n        for (var _index = 0; _index < registryTasks.length; _index++) {\n          var doc = registryTasks[_index];\n          registry.register(doc, {\n            docId: doc.primary,\n            revisionHeight: getHeightOfRevision(doc.revision),\n            lwt: doc._data._meta.lwt\n          });\n        }\n      });\n      if (docCache.tasks.size <= 1) {\n        requestIdlePromiseNoQueue().then(() => {\n          docCache.processTasks();\n        });\n      }\n    }\n    return ret;\n  };\n  return fn;\n}\nexport function mapDocumentsDataToCacheDocs(docCache, docsData) {\n  var getCachedRxDocuments = docCache.getCachedRxDocuments;\n  return getCachedRxDocuments(docsData);\n}\n\n/**\n * Fallback for JavaScript runtimes that do not support WeakRef.\n * The fallback will keep the items in cache forever,\n * but at least works.\n */\nvar HAS_WEAK_REF = typeof WeakRef === 'function';\nvar createWeakRefWithFallback = HAS_WEAK_REF ? createWeakRef : createWeakRefFallback;\nfunction createWeakRef(obj) {\n  return new WeakRef(obj);\n}\nfunction createWeakRefFallback(obj) {\n  return {\n    deref() {\n      return obj;\n    }\n  };\n}\n", "import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { mapDocumentsDataToCacheDocs } from \"./doc-cache.js\";\nimport { now, overwriteGetterForCaching } from \"./plugins/utils/index.js\";\nimport { newRxError } from \"./rx-error.js\";\n/**\n * RxDB needs the query results in multiple formats.\n * Sometimes as a Map or an array with only the documentData.\n * For better performance we work with this class\n * that initializes stuff lazily so that\n * we can directly work with the query results after RxQuery.exec()\n */\nexport var RxQuerySingleResult = /*#__PURE__*/function () {\n  /**\n   * Time at which the current _result state was created.\n   * Used to determine if the result set has changed since X\n   * so that we do not emit the same result multiple times on subscription.\n   */\n\n  function RxQuerySingleResult(query,\n  // only used internally, do not use outside, use this.docsData instead\n  docsDataFromStorageInstance,\n  // can be overwritten for count-queries\n  count) {\n    this.time = now();\n    this.query = query;\n    this.count = count;\n    this.documents = mapDocumentsDataToCacheDocs(this.query.collection._docCache, docsDataFromStorageInstance);\n  }\n\n  /**\n   * Instead of using the newResultData in the result cache,\n   * we directly use the objects that are stored in the RxDocument\n   * to ensure we do not store the same data twice and fill up the memory.\n   * @overwrites itself with the actual value\n   */\n  var _proto = RxQuerySingleResult.prototype;\n  _proto.getValue = function getValue(throwIfMissing) {\n    var op = this.query.op;\n    if (op === 'count') {\n      return this.count;\n    } else if (op === 'findOne') {\n      // findOne()-queries emit RxDocument or null\n      var doc = this.documents.length === 0 ? null : this.documents[0];\n      if (!doc && throwIfMissing) {\n        throw newRxError('QU10', {\n          collection: this.query.collection.name,\n          query: this.query.mangoQuery,\n          op\n        });\n      } else {\n        return doc;\n      }\n    } else if (op === 'findByIds') {\n      return this.docsMap;\n    } else {\n      // find()-queries emit RxDocument[]\n      // Flat copy the array so it won't matter if the user modifies it.\n      return this.documents.slice(0);\n    }\n  };\n  return _createClass(RxQuerySingleResult, [{\n    key: \"docsData\",\n    get: function () {\n      return overwriteGetterForCaching(this, 'docsData', this.documents.map(d => d._data));\n    }\n\n    // A key->document map, used in the event reduce optimization.\n  }, {\n    key: \"docsDataMap\",\n    get: function () {\n      var map = new Map();\n      this.documents.forEach(d => {\n        map.set(d.primary, d._data);\n      });\n      return overwriteGetterForCaching(this, 'docsDataMap', map);\n    }\n  }, {\n    key: \"docsMap\",\n    get: function () {\n      var map = new Map();\n      var documents = this.documents;\n      for (var i = 0; i < documents.length; i++) {\n        var doc = documents[i];\n        map.set(doc.primary, doc);\n      }\n      return overwriteGetterForCaching(this, 'docsMap', map);\n    }\n  }]);\n}();\n", "export function lastOfArray(ar) {\n  return ar[ar.length - 1];\n}\n/**\n * @link https://stackoverflow.com/a/5915122\n */\nexport function randomOfArray(items) {\n  return items[Math.floor(Math.random() * items.length)];\n}\nexport function shuffleArray(arr) {\n  return arr.slice().sort(() => Math.random() - 0.5);\n}\n/**\n * normalizes sort-field\n * in: '-age'\n * out: 'age'\n */\nexport function normalizeSortField(field) {\n  if (field.startsWith('-')) {\n    return field.substr(1);\n  } else {\n    return field;\n  }\n}\nexport function getSortFieldsOfQuery(query) {\n  if (!query.sort) {\n    // if no sort-order is set, use the primary key\n    return ['_id'];\n  }\n  return query.sort.map(maybeArray => {\n    if (Array.isArray(maybeArray)) {\n      return maybeArray[0].map(field => normalizeSortField(field));\n    } else {\n      return normalizeSortField(maybeArray);\n    }\n  });\n}\n/**\n *  @link https://stackoverflow.com/a/1431113\n */\nexport function replaceCharAt(str, index, replacement) {\n  return str.substr(0, index) + replacement + str.substr(index + replacement.length);\n}\nexport function mapToObject(map) {\n  const ret = {};\n  map.forEach((value, key) => {\n    ret[key] = value;\n  });\n  return ret;\n}\nexport function objectToMap(object) {\n  const ret = new Map();\n  Object.entries(object).forEach(([k, v]) => {\n    ret.set(k, v);\n  });\n  return ret;\n}\nexport function cloneMap(map) {\n  const ret = new Map();\n  map.forEach((value, key) => {\n    ret[key] = value;\n  });\n  return ret;\n}\n/**\n * does a flat copy on the objects,\n * is about 3 times faster then using deepClone\n * @link https://jsperf.com/object-rest-spread-vs-clone/2\n */\nexport function flatClone(obj) {\n  return Object.assign({}, obj);\n}\nexport function ensureNotFalsy(obj) {\n  if (!obj) {\n    throw new Error('ensureNotFalsy() is falsy');\n  }\n  return obj;\n}\nexport function mergeSets(sets) {\n  let ret = new Set();\n  sets.forEach(set => {\n    ret = new Set([...ret, ...set]);\n  });\n  return ret;\n}\n/**\n * @link https://stackoverflow.com/a/12830454/3443137\n */\nexport function roundToTwoDecimals(num) {\n  return parseFloat(num.toFixed(2));\n}\nexport function isObject(value) {\n  const type = typeof value;\n  return value !== null && (type === 'object' || type === 'function');\n}\nexport function getProperty(object, path, value) {\n  if (Array.isArray(path)) {\n    path = path.join('.');\n  }\n  if (!isObject(object) || typeof path !== 'string') {\n    return value === undefined ? object : value;\n  }\n  const pathArray = path.split('.');\n  if (pathArray.length === 0) {\n    return value;\n  }\n  for (let index = 0; index < pathArray.length; index++) {\n    const key = pathArray[index];\n    if (isStringIndex(object, key)) {\n      object = index === pathArray.length - 1 ? undefined : null;\n    } else {\n      object = object[key];\n    }\n    if (object === undefined || object === null) {\n      // `object` is either `undefined` or `null` so we want to stop the loop, and\n      // if this is not the last bit of the path, and\n      // if it didn't return `undefined`\n      // it would return `null` if `object` is `null`\n      // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n      if (index !== pathArray.length - 1) {\n        return value;\n      }\n      break;\n    }\n  }\n  return object === undefined ? value : object;\n}\nfunction isStringIndex(object, key) {\n  if (typeof key !== 'number' && Array.isArray(object)) {\n    const index = Number.parseInt(key, 10);\n    return Number.isInteger(index) && object[index] === object[key];\n  }\n  return false;\n}\n", "import { getProperty, lastOfArray } from '../util.js';\nexport const hasLimit = input => {\n  return !!input.queryParams.limit;\n};\nexport const isFindOne = input => {\n  return input.queryParams.limit === 1;\n};\nexport const hasSkip = input => {\n  if (input.queryParams.skip && input.queryParams.skip > 0) {\n    return true;\n  } else {\n    return false;\n  }\n};\nexport const isDelete = input => {\n  return input.changeEvent.operation === 'DELETE';\n};\nexport const isInsert = input => {\n  return input.changeEvent.operation === 'INSERT';\n};\nexport const isUpdate = input => {\n  return input.changeEvent.operation === 'UPDATE';\n};\nexport const wasLimitReached = input => {\n  return hasLimit(input) && input.previousResults.length >= input.queryParams.limit;\n};\nexport const sortParamsChanged = input => {\n  const sortFields = input.queryParams.sortFields;\n  const prev = input.changeEvent.previous;\n  const doc = input.changeEvent.doc;\n  if (!doc) {\n    return false;\n  }\n  if (!prev) {\n    return true;\n  }\n  for (let i = 0; i < sortFields.length; i++) {\n    const field = sortFields[i];\n    const beforeData = getProperty(prev, field);\n    const afterData = getProperty(doc, field);\n    if (beforeData !== afterData) {\n      return true;\n    }\n  }\n  return false;\n};\nexport const wasInResult = input => {\n  const id = input.changeEvent.id;\n  if (input.keyDocumentMap) {\n    const has = input.keyDocumentMap.has(id);\n    return has;\n  } else {\n    const primary = input.queryParams.primaryKey;\n    const results = input.previousResults;\n    for (let i = 0; i < results.length; i++) {\n      const item = results[i];\n      if (item[primary] === id) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\nexport const wasFirst = input => {\n  const first = input.previousResults[0];\n  if (first && first[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  } else {\n    return false;\n  }\n};\nexport const wasLast = input => {\n  const last = lastOfArray(input.previousResults);\n  if (last && last[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  } else {\n    return false;\n  }\n};\nexport const wasSortedBeforeFirst = input => {\n  const prev = input.changeEvent.previous;\n  if (!prev) {\n    return false;\n  }\n  const first = input.previousResults[0];\n  if (!first) {\n    return false;\n  }\n  /**\n   * If the changed document is the same as the first,\n   * we cannot sort-compare them, because it might end in a non-deterministic\n   * sort order. Because both document could be equal.\n   * So instead we have to return true.\n   */\n  if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  }\n  const comp = input.queryParams.sortComparator(prev, first);\n  return comp < 0;\n};\nexport const wasSortedAfterLast = input => {\n  const prev = input.changeEvent.previous;\n  if (!prev) {\n    return false;\n  }\n  const last = lastOfArray(input.previousResults);\n  if (!last) {\n    return false;\n  }\n  if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  }\n  const comp = input.queryParams.sortComparator(prev, last);\n  return comp > 0;\n};\nexport const isSortedBeforeFirst = input => {\n  const doc = input.changeEvent.doc;\n  if (!doc) {\n    return false;\n  }\n  const first = input.previousResults[0];\n  if (!first) {\n    return false;\n  }\n  if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  }\n  const comp = input.queryParams.sortComparator(doc, first);\n  return comp < 0;\n};\nexport const isSortedAfterLast = input => {\n  const doc = input.changeEvent.doc;\n  if (!doc) {\n    return false;\n  }\n  const last = lastOfArray(input.previousResults);\n  if (!last) {\n    return false;\n  }\n  if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  }\n  const comp = input.queryParams.sortComparator(doc, last);\n  return comp > 0;\n};\nexport const wasMatching = input => {\n  const prev = input.changeEvent.previous;\n  if (!prev) {\n    return false;\n  }\n  return input.queryParams.queryMatcher(prev);\n};\nexport const doesMatchNow = input => {\n  const doc = input.changeEvent.doc;\n  if (!doc) {\n    return false;\n  }\n  const ret = input.queryParams.queryMatcher(doc);\n  return ret;\n};\nexport const wasResultsEmpty = input => {\n  return input.previousResults.length === 0;\n};\n", "import { hasLimit, isFindOne, hasSkip, wasResultsEmpty, isDelete, isInsert, isUpdate, wasLimitReached, sortParamsChanged, wasInResult, wasFirst, wasLast, wasSortedBeforeFirst, wasSortedAfterLast, isSortedBeforeFirst, isSortedAfterLast, wasMatching, doesMatchNow } from './state-resolver.js';\nexport * from './state-resolver.js';\n/**\n * all states ordered by performance-cost\n * cheapest first\n * TODO run tests on which is really the fastest\n */\nexport const orderedStateList = ['isInsert', 'isUpdate', 'isDelete', 'hasLimit', 'isFindOne', 'hasSkip', 'wasResultsEmpty', 'wasLimitReached', 'wasFirst', 'wasLast', 'sortParamsChanged', 'wasInResult', 'wasSortedBeforeFirst', 'wasSortedAfterLast', 'isSortedBeforeFirst', 'isSortedAfterLast', 'wasMatching', 'doesMatchNow'];\nexport const stateResolveFunctions = {\n  isInsert,\n  isUpdate,\n  isDelete,\n  hasLimit,\n  isFindOne,\n  hasSkip,\n  wasResultsEmpty,\n  wasLimitReached,\n  wasFirst,\n  wasLast,\n  sortParamsChanged,\n  wasInResult,\n  wasSortedBeforeFirst,\n  wasSortedAfterLast,\n  isSortedBeforeFirst,\n  isSortedAfterLast,\n  wasMatching,\n  doesMatchNow\n};\nexport const stateResolveFunctionByIndex = {\n  0: isInsert,\n  1: isUpdate,\n  2: isDelete,\n  3: hasLimit,\n  4: isFindOne,\n  5: hasSkip,\n  6: wasResultsEmpty,\n  7: wasLimitReached,\n  8: wasFirst,\n  9: wasLast,\n  10: sortParamsChanged,\n  11: wasInResult,\n  12: wasSortedBeforeFirst,\n  13: wasSortedAfterLast,\n  14: isSortedBeforeFirst,\n  15: isSortedAfterLast,\n  16: wasMatching,\n  17: doesMatchNow\n};\nexport function resolveState(stateName, input) {\n  const fn = stateResolveFunctions[stateName];\n  if (!fn) {\n    throw new Error('resolveState() has no function for ' + stateName);\n  }\n  return fn(input);\n}\nexport function getStateSet(input) {\n  let set = '';\n  for (let i = 0; i < orderedStateList.length; i++) {\n    const name = orderedStateList[i];\n    const value = resolveState(name, input);\n    const add = value ? '1' : '0';\n    set += add;\n  }\n  return set;\n}\nexport function logStateSet(stateSet) {\n  orderedStateList.forEach((state, index) => {\n    console.log('state: ' + state + ' : ' + stateSet[index]);\n  });\n}\n", "/**\n * copied and adapted from npm 'binary-search-insert'\n * @link https://www.npmjs.com/package/binary-search-insert\n */\nexport function pushAtSortPosition(array, item, compareFunction, low) {\n  var length = array.length;\n  var high = length - 1;\n  var mid = 0;\n\n  /**\n   * Optimization shortcut.\n   */\n  if (length === 0) {\n    array.push(item);\n    return 0;\n  }\n\n  /**\n   * So we do not have to get the ret[mid] doc again\n   * at the last we store it here.\n   */\n  var lastMidDoc;\n  while (low <= high) {\n    // https://github.com/darkskyapp/binary-search\n    // http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html\n    mid = low + (high - low >> 1);\n    lastMidDoc = array[mid];\n    if (compareFunction(lastMidDoc, item) <= 0.0) {\n      // searching too low\n      low = mid + 1;\n    } else {\n      // searching too high\n      high = mid - 1;\n    }\n  }\n  if (compareFunction(lastMidDoc, item) <= 0.0) {\n    mid++;\n  }\n\n  /**\n   * Insert at correct position\n   */\n  array.splice(mid, 0, item);\n  return mid;\n}", "import { pushAtSortPosition } from 'array-push-at-sort-position';\nexport const doNothing = _input => {};\nexport const insertFirst = input => {\n  input.previousResults.unshift(input.changeEvent.doc);\n  if (input.keyDocumentMap) {\n    input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);\n  }\n};\nexport const insertLast = input => {\n  input.previousResults.push(input.changeEvent.doc);\n  if (input.keyDocumentMap) {\n    input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);\n  }\n};\nexport const removeFirstItem = input => {\n  const first = input.previousResults.shift();\n  if (input.keyDocumentMap && first) {\n    input.keyDocumentMap.delete(first[input.queryParams.primaryKey]);\n  }\n};\nexport const removeLastItem = input => {\n  const last = input.previousResults.pop();\n  if (input.keyDocumentMap && last) {\n    input.keyDocumentMap.delete(last[input.queryParams.primaryKey]);\n  }\n};\nexport const removeFirstInsertLast = input => {\n  removeFirstItem(input);\n  insertLast(input);\n};\nexport const removeLastInsertFirst = input => {\n  removeLastItem(input);\n  insertFirst(input);\n};\nexport const removeFirstInsertFirst = input => {\n  removeFirstItem(input);\n  insertFirst(input);\n};\nexport const removeLastInsertLast = input => {\n  removeLastItem(input);\n  insertLast(input);\n};\nexport const removeExisting = input => {\n  if (input.keyDocumentMap) {\n    input.keyDocumentMap.delete(input.changeEvent.id);\n  }\n  // find index of document\n  const primary = input.queryParams.primaryKey;\n  const results = input.previousResults;\n  for (let i = 0; i < results.length; i++) {\n    const item = results[i];\n    // remove\n    if (item[primary] === input.changeEvent.id) {\n      results.splice(i, 1);\n      break;\n    }\n  }\n};\nexport const replaceExisting = input => {\n  // find index of document\n  const doc = input.changeEvent.doc;\n  const primary = input.queryParams.primaryKey;\n  const results = input.previousResults;\n  for (let i = 0; i < results.length; i++) {\n    const item = results[i];\n    // replace\n    if (item[primary] === input.changeEvent.id) {\n      results[i] = doc;\n      if (input.keyDocumentMap) {\n        input.keyDocumentMap.set(input.changeEvent.id, doc);\n      }\n      break;\n    }\n  }\n};\n/**\n * this function always returns wrong results\n * it must be later optimised out\n * otherwise there is something broken\n */\nexport const alwaysWrong = input => {\n  const wrongHuman = {\n    _id: 'wrongHuman' + new Date().getTime()\n  };\n  input.previousResults.length = 0; // clear array\n  input.previousResults.push(wrongHuman);\n  if (input.keyDocumentMap) {\n    input.keyDocumentMap.clear();\n    input.keyDocumentMap.set(wrongHuman._id, wrongHuman);\n  }\n};\nexport const insertAtSortPosition = input => {\n  const docId = input.changeEvent.id;\n  const doc = input.changeEvent.doc;\n  if (input.keyDocumentMap) {\n    if (input.keyDocumentMap.has(docId)) {\n      /**\n       * If document is already in results,\n       * we cannot add it again because it would throw on non-deterministic ordering.\n       */\n      return;\n    }\n    input.keyDocumentMap.set(docId, doc);\n  } else {\n    const isDocInResults = input.previousResults.find(d => d[input.queryParams.primaryKey] === docId);\n    /**\n     * If document is already in results,\n     * we cannot add it again because it would throw on non-deterministic ordering.\n     */\n    if (isDocInResults) {\n      return;\n    }\n  }\n  pushAtSortPosition(input.previousResults, doc, input.queryParams.sortComparator, 0);\n};\nexport const removeExistingAndInsertAtSortPosition = input => {\n  removeExisting(input);\n  insertAtSortPosition(input);\n};\nexport const runFullQueryAgain = _input => {\n  throw new Error('Action runFullQueryAgain must be implemented by yourself');\n};\nexport const unknownAction = _input => {\n  throw new Error('Action unknownAction should never be called');\n};\n", "import { doNothing, insertFirst, insertLast, removeFirstItem, removeLastItem, removeFirstInsertLast, removeLastInsertFirst, removeExisting, replaceExisting, alwaysWrong, insertAtSortPosition, removeExistingAndInsertAtSortPosition, runFullQueryAgain, unknownAction, removeFirstInsertFirst, removeLastInsertLast } from './action-functions.js';\nexport * from './action-functions.js';\n/**\n * all actions ordered by performance-cost\n * cheapest first\n * TODO run tests on which is really the fastest\n */\nexport const orderedActionList = ['doNothing', 'insertFirst', 'insertLast', 'removeFirstItem', 'removeLastItem', 'removeFirstInsertLast', 'removeLastInsertFirst', 'removeFirstInsertFirst', 'removeLastInsertLast', 'removeExisting', 'replaceExisting', 'alwaysWrong', 'insertAtSortPosition', 'removeExistingAndInsertAtSortPosition', 'runFullQueryAgain', 'unknownAction'];\nexport const actionFunctions = {\n  doNothing,\n  insertFirst,\n  insertLast,\n  removeFirstItem,\n  removeLastItem,\n  removeFirstInsertLast,\n  removeLastInsertFirst,\n  removeFirstInsertFirst,\n  removeLastInsertLast,\n  removeExisting,\n  replaceExisting,\n  alwaysWrong,\n  insertAtSortPosition,\n  removeExistingAndInsertAtSortPosition,\n  runFullQueryAgain,\n  unknownAction\n};\n", "/*\nlet t = 0;\nwhile (t < 10000) {\n    const char = String.fromCharCode(t);\n    console.log(t + ' : ' + char);\n    t++;\n}\n*/\n/*\n\nTo have a really small string representation, we have to hack some stuff\nwhich makes is complicated but effective.\n\nRules for the string:\n- The string starts with a number like '23' that defines how many leaf-nodes we have\n- leaf nodes consist of two chars like 'ab'\n    - the first char is the id\n    - the second the value is a number you can get via String.charCodeAt()\n- Internal nodes have four chars like 'abcd'\n    - the first char is the id\n    - the second char is the id of the 0-branch\n    - the third char is the id of the 1-branch\n    - the last char is the id of the boolean-function (= level)\n- The last 3 chars of the string is the root node like 'abc'\n    - it looks like the internal-node but without the id (first char)\n\n*/\n// we use this because 39 is the quotes which causes problems\nexport const CHAR_CODE_OFFSET = 40; // String.fromCharCode(33) === ')'\nexport function getCharOfLevel(level) {\n  const charCode = CHAR_CODE_OFFSET + level;\n  return String.fromCharCode(charCode);\n}\nexport function getNumberOfChar(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode - CHAR_CODE_OFFSET;\n}\nexport function getCharOfValue(value) {\n  const charCode = CHAR_CODE_OFFSET + value;\n  return String.fromCharCode(charCode);\n}\nexport const FIRST_CHAR_CODE_FOR_ID = 97; // String.fromCharCode(97) === 'a'\nexport function getNextCharId(lastCode) {\n  // jump these codes because they look strange\n  if (lastCode >= 128 && lastCode <= 160) {\n    lastCode = 161;\n  }\n  const char = String.fromCharCode(lastCode);\n  return {\n    char,\n    nextCode: lastCode + 1\n  };\n}\n", "export function booleanStringToBoolean(str) {\n  if (str === '1') {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function booleanToBooleanString(b) {\n  if (b) {\n    return '1';\n  } else {\n    return '0';\n  }\n}\nexport function oppositeBoolean(input) {\n  if (input === '1') {\n    return '0';\n  } else {\n    return '1';\n  }\n}\nexport function lastChar(str) {\n  return str.slice(-1);\n}\n/**\n * @link https://stackoverflow.com/a/1349426\n */\nfunction makeid(length = 6) {\n  let result = '';\n  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  const charactersLength = characters.length;\n  for (let i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n}\nconst nodeIdPrefix = makeid(4);\nlet lastIdGen = 0;\nexport function nextNodeId() {\n  const ret = 'node_' + nodeIdPrefix + '_' + lastIdGen;\n  lastIdGen++;\n  return ret;\n}\n/**\n * @link https://stackoverflow.com/a/16155417\n */\nexport function decimalToPaddedBinary(decimal, padding) {\n  const binary = (decimal >>> 0).toString(2);\n  const padded = binary.padStart(padding, '0');\n  return padded;\n}\nexport function oppositeBinary(i) {\n  if (i === '1') {\n    return '0';\n  } else if (i === '0') {\n    return '1';\n  } else {\n    throw new Error('non-binary given');\n  }\n}\nexport function binaryToDecimal(binary) {\n  return parseInt(binary, 2);\n}\nexport function minBinaryWithLength(length) {\n  return new Array(length).fill(0).map(() => '0').join('');\n}\nexport function maxBinaryWithLength(length) {\n  return new Array(length).fill(0).map(() => '1').join('');\n}\nexport function getNextStateSet(stateSet) {\n  const decimal = binaryToDecimal(stateSet);\n  const increase = decimal + 1;\n  const binary = decimalToPaddedBinary(increase, stateSet.length);\n  return binary;\n}\nexport function firstKeyOfMap(map) {\n  const iterator1 = map.keys();\n  return iterator1.next().value;\n}\n/**\n * Shuffles array in place. ES6 version\n * @link https://stackoverflow.com/a/6274381\n */\nexport function shuffleArray(a) {\n  for (let i = a.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [a[i], a[j]] = [a[j], a[i]];\n  }\n  return a;\n}\nexport function lastOfArray(ar) {\n  return ar[ar.length - 1];\n}\n/**\n * @link https://stackoverflow.com/a/6259536\n */\nexport function splitStringToChunks(str, chunkSize) {\n  const chunks = [];\n  for (let i = 0, charsLength = str.length; i < charsLength; i += chunkSize) {\n    chunks.push(str.substring(i, i + chunkSize));\n  }\n  return chunks;\n}\n", "import { splitStringToChunks } from '../util.js';\nimport { getNumberOfChar } from './string-format.js';\nexport function minimalStringToSimpleBdd(str) {\n  const nodesById = new Map();\n  // parse leaf nodes\n  const leafNodeAmount = parseInt(str.charAt(0) + str.charAt(1), 10);\n  const lastLeafNodeChar = 2 + leafNodeAmount * 2;\n  const leafNodeChars = str.substring(2, lastLeafNodeChar);\n  const leafNodeChunks = splitStringToChunks(leafNodeChars, 2);\n  for (let i = 0; i < leafNodeChunks.length; i++) {\n    const chunk = leafNodeChunks[i];\n    const id = chunk.charAt(0);\n    const value = getNumberOfChar(chunk.charAt(1));\n    nodesById.set(id, value);\n  }\n  // parse internal nodes\n  const internalNodeChars = str.substring(lastLeafNodeChar, str.length - 3);\n  const internalNodeChunks = splitStringToChunks(internalNodeChars, 4);\n  for (let i = 0; i < internalNodeChunks.length; i++) {\n    const chunk = internalNodeChunks[i];\n    const id = chunk.charAt(0);\n    const idOf0Branch = chunk.charAt(1);\n    const idOf1Branch = chunk.charAt(2);\n    const level = getNumberOfChar(chunk.charAt(3));\n    if (!nodesById.has(idOf0Branch)) {\n      throw new Error('missing node with id ' + idOf0Branch);\n    }\n    if (!nodesById.has(idOf1Branch)) {\n      throw new Error('missing node with id ' + idOf1Branch);\n    }\n    const node0 = nodesById.get(idOf0Branch);\n    const node1 = nodesById.get(idOf1Branch);\n    const node = {\n      l: level,\n      // level is first for prettier json output\n      0: node0,\n      1: node1\n    };\n    nodesById.set(id, node);\n  }\n  // parse root node\n  const last3 = str.slice(-3);\n  const idOf0 = last3.charAt(0);\n  const idOf1 = last3.charAt(1);\n  const levelOfRoot = getNumberOfChar(last3.charAt(2));\n  const nodeOf0 = nodesById.get(idOf0);\n  const nodeOf1 = nodesById.get(idOf1);\n  const rootNode = {\n    l: levelOfRoot,\n    0: nodeOf0,\n    1: nodeOf1\n  };\n  return rootNode;\n}\n", "import { booleanToBooleanString } from '../util.js';\nexport function resolveWithSimpleBdd(simpleBdd, fns, input) {\n  let currentNode = simpleBdd;\n  let currentLevel = simpleBdd.l;\n  while (true) {\n    const booleanResult = fns[currentLevel](input);\n    const branchKey = booleanToBooleanString(booleanResult);\n    currentNode = currentNode[branchKey];\n    if (typeof currentNode === 'number' || typeof currentNode === 'string') {\n      return currentNode;\n    } else {\n      currentLevel = currentNode.l;\n    }\n  }\n}\n", "import { minimalStringToSimpleBdd, resolveWithSimpleBdd } from 'binary-decision-diagram';\nimport { stateResolveFunctionByIndex } from '../states/index.js';\nexport const minimalBddString = '14a1b,c+d2e5f0g/h.i4j*k-l)m(n6oeh6pnm6qen6ril6snh6tin6ubo9vce9wmh9xns9yne9zmi9{cm9|ad9}cp9~aq9ae9¡bf9¢bq9£cg9¤ck9¥cn9¦nd9§np9¨nq9©nf9ªng9«nm9¬nk9­mr9®ms9¯mt9°mj9±mk9²ml9³mn9´mc8µ³{8¶¯}8·°¤8¸³§8¹mn8º³«8»³m8¼m´4½z²4¾³w4¿zµ4À¯¶4Á°·4Â³º4Ã³¸4Äm¹4Åv¤7Æyn7ÇÀÁ7È~7É¥¤7ÊÃÄ7Ë¨n7Ìº¹7Í­°7Î®m7Ï¯°7Ð±m7Ñ³m7Ò¼m5ÓÄm5Ô¹m5Õ½°5Ö¾m5×¿°5ØÇÏ5ÙÂm5ÚÊÑ5Û±m5Üºm5ÝÌÑ5ÞÕÍ2ß|2à¡u2á£Å2âÖÎ2ã¦Æ2ä©x2åªÆ2æ×Ø2ç|È2è¡¢2é£É2ê¤¥2ëÙÚ2ì¦Ë2í©n2îªn2ïÛÐ2ðÜÝ2ñ¬n2òÒÓ/óan/ôbn/õcn/öÞâ/÷ßã/øàä/ùáå/úæë/ûçì/üèí/ýéî/þÍÎ/ÿÏÑ/ĀòÔ,ācn,Ăöï,ă¤ñ,Ąúð,ąêñ,ĆþÐ,ćÿÑ,Ĉac0ĉbc0Ċóõ0ċôā0Čßá0čà¤0Ďçé0ďèê0Đ÷ù0đøă0Ēûý0ēüą0ĔmÒ-ĕmĀ-ĖÞæ-ėČĎ-Ęčď-ęĂĄ-ĚĐĒ-ěđē-Ĝ²»-ĝÍÏ-ĞĆć-ğ²³-ĠĔĈ3ġĕĊ3ĢĖė3ģęĚ3ĤĢĝ(ĥĜğ(ĦģĞ(ħĠġ+Ĩĉċ+ĩĤĦ+ĪĘě+īħĨ1ĬĩĪ1ĭĬī*Įĥm*ĭĮ.';\nlet simpleBdd;\nexport function getSimpleBdd() {\n  if (!simpleBdd) {\n    simpleBdd = minimalStringToSimpleBdd(minimalBddString);\n  }\n  return simpleBdd;\n}\nexport const resolveInput = input => {\n  return resolveWithSimpleBdd(getSimpleBdd(), stateResolveFunctionByIndex, input);\n};\n", "import { getStateSet } from './states/index.js';\nimport { actionFunctions, orderedActionList } from './actions/index.js';\nimport { resolveInput } from './bdd/bdd.generated.js';\nexport * from './states/index.js';\nexport * from './util.js';\nexport * from './actions/index.js';\nexport function calculateActionFromMap(stateSetToActionMap, input) {\n  const stateSet = getStateSet(input);\n  const actionName = stateSetToActionMap.get(stateSet);\n  if (!actionName) {\n    return {\n      action: 'runFullQueryAgain',\n      stateSet\n    };\n  } else {\n    return {\n      action: actionName,\n      stateSet\n    };\n  }\n}\nexport function calculateActionName(input) {\n  const resolvedActionId = resolveInput(input);\n  return orderedActionList[resolvedActionId];\n}\nexport function calculateActionFunction(input) {\n  const actionName = calculateActionName(input);\n  return actionFunctions[actionName];\n}\n/**\n * for performance reasons,\n * @mutates the input\n * @returns the new results\n */\nexport function runAction(action, queryParams, changeEvent, previousResults, keyDocumentMap) {\n  const fn = actionFunctions[action];\n  fn({\n    queryParams,\n    changeEvent,\n    previousResults,\n    keyDocumentMap\n  });\n  return previousResults;\n}\n", "import { calculateActionName, runAction } from 'event-reduce-js';\nimport { rxChangeEventToEventReduceChangeEvent } from \"./rx-change-event.js\";\nimport { clone, ensureNotFalsy, getFromMapOrCreate } from \"./plugins/utils/index.js\";\nimport { getQueryMatcher, getSortComparator, normalizeMangoQuery } from \"./rx-query-helper.js\";\nexport function getSortFieldsOfQuery(primaryKey, query) {\n  if (!query.sort || query.sort.length === 0) {\n    return [primaryKey];\n  } else {\n    return query.sort.map(part => Object.keys(part)[0]);\n  }\n}\nexport var RXQUERY_QUERY_PARAMS_CACHE = new WeakMap();\nexport function getQueryParams(rxQuery) {\n  return getFromMapOrCreate(RXQUERY_QUERY_PARAMS_CACHE, rxQuery, () => {\n    var collection = rxQuery.collection;\n    var normalizedMangoQuery = normalizeMangoQuery(collection.storageInstance.schema, clone(rxQuery.mangoQuery));\n    var primaryKey = collection.schema.primaryPath;\n\n    /**\n     * Create a custom sort comparator\n     * that uses the hooks to ensure\n     * we send for example compressed documents to be sorted by compressed queries.\n     */\n    var sortComparator = getSortComparator(collection.schema.jsonSchema, normalizedMangoQuery);\n    var useSortComparator = (docA, docB) => {\n      var sortComparatorData = {\n        docA,\n        docB,\n        rxQuery\n      };\n      return sortComparator(sortComparatorData.docA, sortComparatorData.docB);\n    };\n\n    /**\n     * Create a custom query matcher\n     * that uses the hooks to ensure\n     * we send for example compressed documents to match compressed queries.\n     */\n    var queryMatcher = getQueryMatcher(collection.schema.jsonSchema, normalizedMangoQuery);\n    var useQueryMatcher = doc => {\n      var queryMatcherData = {\n        doc,\n        rxQuery\n      };\n      return queryMatcher(queryMatcherData.doc);\n    };\n    var ret = {\n      primaryKey: rxQuery.collection.schema.primaryPath,\n      skip: normalizedMangoQuery.skip,\n      limit: normalizedMangoQuery.limit,\n      sortFields: getSortFieldsOfQuery(primaryKey, normalizedMangoQuery),\n      sortComparator: useSortComparator,\n      queryMatcher: useQueryMatcher\n    };\n    return ret;\n  });\n}\nexport function calculateNewResults(rxQuery, rxChangeEvents) {\n  if (!rxQuery.collection.database.eventReduce) {\n    return {\n      runFullQueryAgain: true\n    };\n  }\n  var queryParams = getQueryParams(rxQuery);\n  var previousResults = ensureNotFalsy(rxQuery._result).docsData.slice(0);\n  var previousResultsMap = ensureNotFalsy(rxQuery._result).docsDataMap;\n  var changed = false;\n  var eventReduceEvents = [];\n  for (var index = 0; index < rxChangeEvents.length; index++) {\n    var cE = rxChangeEvents[index];\n    var eventReduceEvent = rxChangeEventToEventReduceChangeEvent(cE);\n    if (eventReduceEvent) {\n      eventReduceEvents.push(eventReduceEvent);\n    }\n  }\n  var foundNonOptimizeable = eventReduceEvents.find(eventReduceEvent => {\n    var stateResolveFunctionInput = {\n      queryParams,\n      changeEvent: eventReduceEvent,\n      previousResults,\n      keyDocumentMap: previousResultsMap\n    };\n    var actionName = calculateActionName(stateResolveFunctionInput);\n    if (actionName === 'runFullQueryAgain') {\n      return true;\n    } else if (actionName !== 'doNothing') {\n      changed = true;\n      runAction(actionName, queryParams, eventReduceEvent, previousResults, previousResultsMap);\n      return false;\n    }\n  });\n  if (foundNonOptimizeable) {\n    return {\n      runFullQueryAgain: true\n    };\n  } else {\n    return {\n      runFullQueryAgain: false,\n      changed,\n      newResults: previousResults\n    };\n  }\n}\n", "import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { BehaviorSubject, merge } from 'rxjs';\nimport { mergeMap, filter, map, startWith, distinctUntilChanged, shareReplay } from 'rxjs/operators';\nimport { sortObject, pluginMissing, overwriteGetterForCaching, now, PROMISE_RESOLVE_FALSE, RXJS_SHARE_REPLAY_DEFAULTS, ensureNotFalsy, areRxDocumentArraysEqual, appendToArray } from \"./plugins/utils/index.js\";\nimport { newRxError, rxStorageWriteErrorToRxError } from \"./rx-error.js\";\nimport { runPluginHooks } from \"./hooks.js\";\nimport { calculateNewResults } from \"./event-reduce.js\";\nimport { triggerCacheReplacement } from \"./query-cache.js\";\nimport { getQueryMatcher, normalizeMangoQuery, prepareQuery, runQueryUpdateFunction } from \"./rx-query-helper.js\";\nimport { RxQuerySingleResult } from \"./rx-query-single-result.js\";\nvar _queryCount = 0;\nvar newQueryID = function () {\n  return ++_queryCount;\n};\nexport var RxQueryBase = /*#__PURE__*/function () {\n  /**\n   * Some stats then are used for debugging and cache replacement policies\n   */\n\n  // used in the query-cache to determine if the RxQuery can be cleaned up.\n\n  // used to count the subscribers to the query\n\n  /**\n   * Contains the current result state\n   * or null if query has not run yet.\n   */\n\n  function RxQueryBase(op, mangoQuery, collection,\n  // used by some plugins\n  other = {}) {\n    this.id = newQueryID();\n    this._execOverDatabaseCount = 0;\n    this._creationTime = now();\n    this._lastEnsureEqual = 0;\n    this.uncached = false;\n    this.refCount$ = new BehaviorSubject(null);\n    this._result = null;\n    this._latestChangeEvent = -1;\n    this._ensureEqualQueue = PROMISE_RESOLVE_FALSE;\n    this.op = op;\n    this.mangoQuery = mangoQuery;\n    this.collection = collection;\n    this.other = other;\n    if (!mangoQuery) {\n      this.mangoQuery = _getDefaultQuery();\n    }\n    this.isFindOneByIdQuery = isFindOneByIdQuery(this.collection.schema.primaryPath, mangoQuery);\n  }\n  var _proto = RxQueryBase.prototype;\n  /**\n   * Returns an observable that emits the results\n   * This should behave like an rxjs-BehaviorSubject which means:\n   * - Emit the current result-set on subscribe\n   * - Emit the new result-set when an RxChangeEvent comes in\n   * - Do not emit anything before the first result-set was created (no null)\n   */\n  /**\n   * set the new result-data as result-docs of the query\n   * @param newResultData json-docs that were received from the storage\n   */\n  _proto._setResultData = function _setResultData(newResultData) {\n    if (typeof newResultData === 'undefined') {\n      throw newRxError('QU18', {\n        database: this.collection.database.name,\n        collection: this.collection.name\n      });\n    }\n    if (typeof newResultData === 'number') {\n      this._result = new RxQuerySingleResult(this, [], newResultData);\n      return;\n    } else if (newResultData instanceof Map) {\n      newResultData = Array.from(newResultData.values());\n    }\n    var newQueryResult = new RxQuerySingleResult(this, newResultData, newResultData.length);\n    this._result = newQueryResult;\n  }\n\n  /**\n   * executes the query on the database\n   * @return results-array with document-data\n   */;\n  _proto._execOverDatabase = async function _execOverDatabase() {\n    this._execOverDatabaseCount = this._execOverDatabaseCount + 1;\n    if (this.op === 'count') {\n      var preparedQuery = this.getPreparedQuery();\n      var result = await this.collection.storageInstance.count(preparedQuery);\n      if (result.mode === 'slow' && !this.collection.database.allowSlowCount) {\n        throw newRxError('QU14', {\n          collection: this.collection,\n          queryObj: this.mangoQuery\n        });\n      } else {\n        return result.count;\n      }\n    }\n    if (this.op === 'findByIds') {\n      var ids = ensureNotFalsy(this.mangoQuery.selector)[this.collection.schema.primaryPath].$in;\n      var ret = new Map();\n      var mustBeQueried = [];\n      // first try to fill from docCache\n      ids.forEach(id => {\n        var docData = this.collection._docCache.getLatestDocumentDataIfExists(id);\n        if (docData) {\n          if (!docData._deleted) {\n            var doc = this.collection._docCache.getCachedRxDocument(docData);\n            ret.set(id, doc);\n          }\n        } else {\n          mustBeQueried.push(id);\n        }\n      });\n      // everything which was not in docCache must be fetched from the storage\n      if (mustBeQueried.length > 0) {\n        var docs = await this.collection.storageInstance.findDocumentsById(mustBeQueried, false);\n        docs.forEach(docData => {\n          var doc = this.collection._docCache.getCachedRxDocument(docData);\n          ret.set(doc.primary, doc);\n        });\n      }\n      return ret;\n    }\n    var docsPromise = queryCollection(this);\n    return docsPromise.then(docs => {\n      return docs;\n    });\n  }\n\n  /**\n   * Execute the query\n   * To have an easier implementations,\n   * just subscribe and use the first result\n   */;\n  _proto.exec = async function exec(throwIfMissing) {\n    if (throwIfMissing && this.op !== 'findOne') {\n      throw newRxError('QU9', {\n        collection: this.collection.name,\n        query: this.mangoQuery,\n        op: this.op\n      });\n    }\n\n    /**\n     * run _ensureEqual() here,\n     * this will make sure that errors in the query which throw inside of the RxStorage,\n     * will be thrown at this execution context and not in the background.\n     */\n    await _ensureEqual(this);\n    var useResult = ensureNotFalsy(this._result);\n    return useResult.getValue(throwIfMissing);\n  }\n\n  /**\n   * cached call to get the queryMatcher\n   * @overwrites itself with the actual value\n   */;\n  /**\n   * returns a string that is used for equal-comparisons\n   * @overwrites itself with the actual value\n   */\n  _proto.toString = function toString() {\n    var stringObj = sortObject({\n      op: this.op,\n      query: normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery),\n      other: this.other\n    }, true);\n    var value = JSON.stringify(stringObj);\n    this.toString = () => value;\n    return value;\n  }\n\n  /**\n   * returns the prepared query\n   * which can be send to the storage instance to query for documents.\n   * @overwrites itself with the actual value.\n   */;\n  _proto.getPreparedQuery = function getPreparedQuery() {\n    var hookInput = {\n      rxQuery: this,\n      // can be mutated by the hooks so we have to deep clone first.\n      mangoQuery: normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery)\n    };\n    hookInput.mangoQuery.selector._deleted = {\n      $eq: false\n    };\n    if (hookInput.mangoQuery.index) {\n      hookInput.mangoQuery.index.unshift('_deleted');\n    }\n    runPluginHooks('prePrepareQuery', hookInput);\n    var value = prepareQuery(this.collection.schema.jsonSchema, hookInput.mangoQuery);\n    this.getPreparedQuery = () => value;\n    return value;\n  }\n\n  /**\n   * returns true if the document matches the query,\n   * does not use the 'skip' and 'limit'\n   */;\n  _proto.doesDocumentDataMatch = function doesDocumentDataMatch(docData) {\n    // if doc is deleted, it cannot match\n    if (docData._deleted) {\n      return false;\n    }\n    return this.queryMatcher(docData);\n  }\n\n  /**\n   * deletes all found documents\n   * @return promise with deleted documents\n   */;\n  _proto.remove = async function remove() {\n    var docs = await this.exec();\n    if (Array.isArray(docs)) {\n      var result = await this.collection.bulkRemove(docs);\n      if (result.error.length > 0) {\n        throw rxStorageWriteErrorToRxError(result.error[0]);\n      } else {\n        return result.success;\n      }\n    } else {\n      return docs.remove();\n    }\n  };\n  _proto.incrementalRemove = function incrementalRemove() {\n    return runQueryUpdateFunction(this.asRxQuery, doc => doc.incrementalRemove());\n  }\n\n  /**\n   * helper function to transform RxQueryBase to RxQuery type\n   */;\n  /**\n   * updates all found documents\n   * @overwritten by plugin (optional)\n   */\n  _proto.update = function update(_updateObj) {\n    throw pluginMissing('update');\n  };\n  _proto.patch = function patch(_patch) {\n    return runQueryUpdateFunction(this.asRxQuery, doc => doc.patch(_patch));\n  };\n  _proto.incrementalPatch = function incrementalPatch(patch) {\n    return runQueryUpdateFunction(this.asRxQuery, doc => doc.incrementalPatch(patch));\n  };\n  _proto.modify = function modify(mutationFunction) {\n    return runQueryUpdateFunction(this.asRxQuery, doc => doc.modify(mutationFunction));\n  };\n  _proto.incrementalModify = function incrementalModify(mutationFunction) {\n    return runQueryUpdateFunction(this.asRxQuery, doc => doc.incrementalModify(mutationFunction));\n  }\n\n  // we only set some methods of query-builder here\n  // because the others depend on these ones\n  ;\n  _proto.where = function where(_queryObj) {\n    throw pluginMissing('query-builder');\n  };\n  _proto.sort = function sort(_params) {\n    throw pluginMissing('query-builder');\n  };\n  _proto.skip = function skip(_amount) {\n    throw pluginMissing('query-builder');\n  };\n  _proto.limit = function limit(_amount) {\n    throw pluginMissing('query-builder');\n  };\n  return _createClass(RxQueryBase, [{\n    key: \"$\",\n    get: function () {\n      if (!this._$) {\n        var results$ = this.collection.eventBulks$.pipe(\n        /**\n         * Performance shortcut.\n         * Changes to local documents are not relevant for the query.\n         */\n        filter(bulk => !bulk.isLocal),\n        /**\n         * Start once to ensure the querying also starts\n         * when there where no changes.\n         */\n        startWith(null),\n        // ensure query results are up to date.\n        mergeMap(() => _ensureEqual(this)),\n        // use the current result set, written by _ensureEqual().\n        map(() => this._result),\n        // do not run stuff above for each new subscriber, only once.\n        shareReplay(RXJS_SHARE_REPLAY_DEFAULTS),\n        // do not proceed if result set has not changed.\n        distinctUntilChanged((prev, curr) => {\n          if (prev && prev.time === ensureNotFalsy(curr).time) {\n            return true;\n          } else {\n            return false;\n          }\n        }), filter(result => !!result),\n        /**\n         * Map the result set to a single RxDocument or an array,\n         * depending on query type\n         */\n        map(result => {\n          return ensureNotFalsy(result).getValue();\n        }));\n        this._$ = merge(results$,\n        /**\n         * Also add the refCount$ to the query observable\n         * to allow us to count the amount of subscribers.\n         */\n        this.refCount$.pipe(filter(() => false)));\n      }\n      return this._$;\n    }\n  }, {\n    key: \"$$\",\n    get: function () {\n      var reactivity = this.collection.database.getReactivityFactory();\n      return reactivity.fromObservable(this.$, undefined, this.collection.database);\n    }\n\n    // stores the changeEvent-number of the last handled change-event\n\n    /**\n     * ensures that the exec-runs\n     * are not run in parallel\n     */\n  }, {\n    key: \"queryMatcher\",\n    get: function () {\n      var schema = this.collection.schema.jsonSchema;\n      var normalizedQuery = normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery);\n      return overwriteGetterForCaching(this, 'queryMatcher', getQueryMatcher(schema, normalizedQuery));\n    }\n  }, {\n    key: \"asRxQuery\",\n    get: function () {\n      return this;\n    }\n  }]);\n}();\nexport function _getDefaultQuery() {\n  return {\n    selector: {}\n  };\n}\n\n/**\n * run this query through the QueryCache\n */\nexport function tunnelQueryCache(rxQuery) {\n  return rxQuery.collection._queryCache.getByQuery(rxQuery);\n}\nexport function createRxQuery(op, queryObj, collection, other) {\n  runPluginHooks('preCreateRxQuery', {\n    op,\n    queryObj,\n    collection,\n    other\n  });\n  var ret = new RxQueryBase(op, queryObj, collection, other);\n\n  // ensure when created with same params, only one is created\n  ret = tunnelQueryCache(ret);\n  triggerCacheReplacement(collection);\n  return ret;\n}\n\n/**\n * Check if the current results-state is in sync with the database\n * which means that no write event happened since the last run.\n * @return false if not which means it should re-execute\n */\nfunction _isResultsInSync(rxQuery) {\n  var currentLatestEventNumber = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();\n  if (rxQuery._latestChangeEvent >= currentLatestEventNumber) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * wraps __ensureEqual()\n * to ensure it does not run in parallel\n * @return true if has changed, false if not\n */\nasync function _ensureEqual(rxQuery) {\n  if (rxQuery.collection.awaitBeforeReads.size > 0) {\n    await Promise.all(Array.from(rxQuery.collection.awaitBeforeReads).map(fn => fn()));\n  }\n\n  // Optimisation shortcut\n  if (rxQuery.collection.database.closed || _isResultsInSync(rxQuery)) {\n    return false;\n  }\n  rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue.then(() => __ensureEqual(rxQuery));\n  return rxQuery._ensureEqualQueue;\n}\n\n/**\n * ensures that the results of this query is equal to the results which a query over the database would give\n * @return true if results have changed\n */\nfunction __ensureEqual(rxQuery) {\n  rxQuery._lastEnsureEqual = now();\n\n  /**\n   * Optimisation shortcuts\n   */\n  if (\n  // db is closed\n  rxQuery.collection.database.closed ||\n  // nothing happened since last run\n  _isResultsInSync(rxQuery)) {\n    return PROMISE_RESOLVE_FALSE;\n  }\n  var ret = false;\n  var mustReExec = false; // if this becomes true, a whole execution over the database is made\n  if (rxQuery._latestChangeEvent === -1) {\n    // have not executed yet -> must run\n    mustReExec = true;\n  }\n\n  /**\n   * try to use EventReduce to calculate the new results\n   */\n  if (!mustReExec) {\n    var missedChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);\n    if (missedChangeEvents === null) {\n      // changeEventBuffer is of bounds -> we must re-execute over the database\n      mustReExec = true;\n    } else {\n      rxQuery._latestChangeEvent = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();\n      var runChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.reduceByLastOfDoc(missedChangeEvents);\n      if (rxQuery.op === 'count') {\n        // 'count' query\n        var previousCount = ensureNotFalsy(rxQuery._result).count;\n        var newCount = previousCount;\n        runChangeEvents.forEach(cE => {\n          var didMatchBefore = cE.previousDocumentData && rxQuery.doesDocumentDataMatch(cE.previousDocumentData);\n          var doesMatchNow = rxQuery.doesDocumentDataMatch(cE.documentData);\n          if (!didMatchBefore && doesMatchNow) {\n            newCount++;\n          }\n          if (didMatchBefore && !doesMatchNow) {\n            newCount--;\n          }\n        });\n        if (newCount !== previousCount) {\n          ret = true; // true because results changed\n          rxQuery._setResultData(newCount);\n        }\n      } else {\n        // 'find' or 'findOne' query\n        var eventReduceResult = calculateNewResults(rxQuery, runChangeEvents);\n        if (eventReduceResult.runFullQueryAgain) {\n          // could not calculate the new results, execute must be done\n          mustReExec = true;\n        } else if (eventReduceResult.changed) {\n          // we got the new results, we do not have to re-execute, mustReExec stays false\n          ret = true; // true because results changed\n          rxQuery._setResultData(eventReduceResult.newResults);\n        }\n      }\n    }\n  }\n\n  // oh no we have to re-execute the whole query over the database\n  if (mustReExec) {\n    return rxQuery._execOverDatabase().then(newResultData => {\n      /**\n       * The RxStorage is defined to always first emit events and then return\n       * on bulkWrite() calls. So here we have to use the counter AFTER the execOverDatabase()\n       * has been run, not the one from before.\n       */\n      rxQuery._latestChangeEvent = rxQuery.collection._changeEventBuffer.getCounter();\n\n      // A count query needs a different has-changed check.\n      if (typeof newResultData === 'number') {\n        if (!rxQuery._result || newResultData !== rxQuery._result.count) {\n          ret = true;\n          rxQuery._setResultData(newResultData);\n        }\n        return ret;\n      }\n      if (!rxQuery._result || !areRxDocumentArraysEqual(rxQuery.collection.schema.primaryPath, newResultData, rxQuery._result.docsData)) {\n        ret = true; // true because results changed\n        rxQuery._setResultData(newResultData);\n      }\n      return ret;\n    });\n  }\n  return Promise.resolve(ret); // true if results have changed\n}\n\n/**\n * Runs the query over the storage instance\n * of the collection.\n * Does some optimizations to ensure findById is used\n * when specific queries are used.\n */\nexport async function queryCollection(rxQuery) {\n  var docs = [];\n  var collection = rxQuery.collection;\n\n  /**\n   * Optimizations shortcut.\n   * If query is find-one-document-by-id,\n   * then we do not have to use the slow query() method\n   * but instead can use findDocumentsById()\n   */\n  if (rxQuery.isFindOneByIdQuery) {\n    if (Array.isArray(rxQuery.isFindOneByIdQuery)) {\n      var docIds = rxQuery.isFindOneByIdQuery;\n      docIds = docIds.filter(docId => {\n        // first try to fill from docCache\n        var docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n        if (docData) {\n          if (!docData._deleted) {\n            docs.push(docData);\n          }\n          return false;\n        } else {\n          return true;\n        }\n      });\n      // otherwise get from storage\n      if (docIds.length > 0) {\n        var docsFromStorage = await collection.storageInstance.findDocumentsById(docIds, false);\n        appendToArray(docs, docsFromStorage);\n      }\n    } else {\n      var docId = rxQuery.isFindOneByIdQuery;\n\n      // first try to fill from docCache\n      var docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n      if (!docData) {\n        // otherwise get from storage\n        var fromStorageList = await collection.storageInstance.findDocumentsById([docId], false);\n        if (fromStorageList[0]) {\n          docData = fromStorageList[0];\n        }\n      }\n      if (docData && !docData._deleted) {\n        docs.push(docData);\n      }\n    }\n  } else {\n    var preparedQuery = rxQuery.getPreparedQuery();\n    var queryResult = await collection.storageInstance.query(preparedQuery);\n    docs = queryResult.documents;\n  }\n  return docs;\n}\n\n/**\n * Returns true if the given query\n * selects exactly one document by its id.\n * Used to optimize performance because these kind of\n * queries do not have to run over an index and can use get-by-id instead.\n * Returns false if no query of that kind.\n * Returns the document id otherwise.\n */\nexport function isFindOneByIdQuery(primaryPath, query) {\n  // must have exactly one operator which must be $eq || $in\n  if (!query.skip && query.selector && Object.keys(query.selector).length === 1 && query.selector[primaryPath]) {\n    var value = query.selector[primaryPath];\n    if (typeof value === 'string') {\n      return value;\n    } else if (Object.keys(value).length === 1 && typeof value.$eq === 'string') {\n      return value.$eq;\n    }\n\n    // same with $in string arrays\n    if (Object.keys(value).length === 1 && Array.isArray(value.$eq) &&\n    // must only contain strings\n    !value.$eq.find(r => typeof r !== 'string')) {\n      return value.$eq;\n    }\n  }\n  return false;\n}\nexport function isRxQuery(obj) {\n  return obj instanceof RxQueryBase;\n}\n", "import { isBulkWriteConflictError, newRxError } from \"./rx-error.js\";\nimport { fillWithDefaultSettings, getComposedPrimaryKeyOfDocumentData } from \"./rx-schema-helper.js\";\nimport { getSingleDocument, getWrittenDocumentsFromBulkWriteResponse, writeSingle } from \"./rx-storage-helper.js\";\nimport { clone, ensureNotFalsy, getDefaultRevision, getDefaultRxDocumentMeta, randomToken } from \"./plugins/utils/index.js\";\nimport { prepareQuery } from \"./rx-query-helper.js\";\nexport var INTERNAL_CONTEXT_COLLECTION = 'collection';\nexport var INTERNAL_CONTEXT_STORAGE_TOKEN = 'storage-token';\nexport var INTERNAL_CONTEXT_MIGRATION_STATUS = 'rx-migration-status';\nexport var INTERNAL_CONTEXT_PIPELINE_CHECKPOINT = 'rx-pipeline-checkpoint';\n\n/**\n * Do not change the title,\n * we have to flag the internal schema so that\n * some RxStorage implementations are able\n * to detect if the created RxStorageInstance\n * is from the internals or not,\n * to do some optimizations in some cases.\n */\nexport var INTERNAL_STORE_SCHEMA_TITLE = 'RxInternalDocument';\nexport var INTERNAL_STORE_SCHEMA = fillWithDefaultSettings({\n  version: 0,\n  title: INTERNAL_STORE_SCHEMA_TITLE,\n  primaryKey: {\n    key: 'id',\n    fields: ['context', 'key'],\n    separator: '|'\n  },\n  type: 'object',\n  properties: {\n    id: {\n      type: 'string',\n      maxLength: 200\n    },\n    key: {\n      type: 'string'\n    },\n    context: {\n      type: 'string',\n      enum: [INTERNAL_CONTEXT_COLLECTION, INTERNAL_CONTEXT_STORAGE_TOKEN, INTERNAL_CONTEXT_MIGRATION_STATUS, INTERNAL_CONTEXT_PIPELINE_CHECKPOINT, 'OTHER']\n    },\n    data: {\n      type: 'object',\n      additionalProperties: true\n    }\n  },\n  indexes: [],\n  required: ['key', 'context', 'data'],\n  additionalProperties: false,\n  /**\n   * If the sharding plugin is used,\n   * it must not shard on the internal RxStorageInstance\n   * because that one anyway has only a small amount of documents\n   * and also its creation is in the hot path of the initial page load,\n   * so we should spend less time creating multiple RxStorageInstances.\n   */\n  sharding: {\n    shards: 1,\n    mode: 'collection'\n  }\n});\nexport function getPrimaryKeyOfInternalDocument(key, context) {\n  return getComposedPrimaryKeyOfDocumentData(INTERNAL_STORE_SCHEMA, {\n    key,\n    context\n  });\n}\n\n/**\n * Returns all internal documents\n * with context 'collection'\n */\nexport async function getAllCollectionDocuments(storageInstance) {\n  var getAllQueryPrepared = prepareQuery(storageInstance.schema, {\n    selector: {\n      context: INTERNAL_CONTEXT_COLLECTION,\n      _deleted: {\n        $eq: false\n      }\n    },\n    sort: [{\n      id: 'asc'\n    }],\n    skip: 0\n  });\n  var queryResult = await storageInstance.query(getAllQueryPrepared);\n  var allDocs = queryResult.documents;\n  return allDocs;\n}\n\n/**\n * to not confuse multiInstance-messages with other databases that have the same\n * name and adapter, but do not share state with this one (for example in-memory-instances),\n * we set a storage-token and use it in the broadcast-channel\n */\nexport var STORAGE_TOKEN_DOCUMENT_KEY = 'storageToken';\nexport var STORAGE_TOKEN_DOCUMENT_ID = getPrimaryKeyOfInternalDocument(STORAGE_TOKEN_DOCUMENT_KEY, INTERNAL_CONTEXT_STORAGE_TOKEN);\nexport async function ensureStorageTokenDocumentExists(rxDatabase) {\n  /**\n   * To have less read-write cycles,\n   * we just try to insert a new document\n   * and only fetch the existing one if a conflict happened.\n   */\n  var storageToken = randomToken(10);\n  var passwordHash = rxDatabase.password ? await rxDatabase.hashFunction(JSON.stringify(rxDatabase.password)) : undefined;\n  var docData = {\n    id: STORAGE_TOKEN_DOCUMENT_ID,\n    context: INTERNAL_CONTEXT_STORAGE_TOKEN,\n    key: STORAGE_TOKEN_DOCUMENT_KEY,\n    data: {\n      rxdbVersion: rxDatabase.rxdbVersion,\n      token: storageToken,\n      /**\n       * We add the instance token here\n       * to be able to detect if a given RxDatabase instance\n       * is the first instance that was ever created\n       * or if databases have existed earlier on that storage\n       * with the same database name.\n       */\n      instanceToken: rxDatabase.token,\n      passwordHash\n    },\n    _deleted: false,\n    _meta: getDefaultRxDocumentMeta(),\n    _rev: getDefaultRevision(),\n    _attachments: {}\n  };\n  var writeRows = [{\n    document: docData\n  }];\n  var writeResult = await rxDatabase.internalStore.bulkWrite(writeRows, 'internal-add-storage-token');\n  if (!writeResult.error[0]) {\n    return getWrittenDocumentsFromBulkWriteResponse('id', writeRows, writeResult)[0];\n  }\n\n  /**\n   * If we get a 409 error,\n   * it means another instance already inserted the storage token.\n   * So we get that token from the database and return that one.\n   */\n  var error = ensureNotFalsy(writeResult.error[0]);\n  if (error.isError && isBulkWriteConflictError(error)) {\n    var conflictError = error;\n    if (!isDatabaseStateVersionCompatibleWithDatabaseCode(conflictError.documentInDb.data.rxdbVersion, rxDatabase.rxdbVersion)) {\n      throw newRxError('DM5', {\n        args: {\n          database: rxDatabase.name,\n          databaseStateVersion: conflictError.documentInDb.data.rxdbVersion,\n          codeVersion: rxDatabase.rxdbVersion\n        }\n      });\n    }\n    if (passwordHash && passwordHash !== conflictError.documentInDb.data.passwordHash) {\n      throw newRxError('DB1', {\n        passwordHash,\n        existingPasswordHash: conflictError.documentInDb.data.passwordHash\n      });\n    }\n    var storageTokenDocInDb = conflictError.documentInDb;\n    return ensureNotFalsy(storageTokenDocInDb);\n  }\n  throw error;\n}\nexport function isDatabaseStateVersionCompatibleWithDatabaseCode(databaseStateVersion, codeVersion) {\n  if (!databaseStateVersion) {\n    return false;\n  }\n  var stateMajor = databaseStateVersion.split('.')[0];\n  var codeMajor = codeVersion.split('.')[0];\n\n  /**\n   * Version v15 data must be upwards compatible to v16\n   */\n  if (stateMajor === '15' && codeMajor === '16') {\n    return true;\n  }\n  if (stateMajor !== codeMajor) {\n    return false;\n  }\n  return true;\n}\nexport async function addConnectedStorageToCollection(collection, storageCollectionName, schema) {\n  if (collection.schema.version !== schema.version) {\n    throw newRxError('SNH', {\n      schema,\n      version: collection.schema.version,\n      name: collection.name,\n      collection,\n      args: {\n        storageCollectionName\n      }\n    });\n  }\n  var collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\n  var collectionDocId = getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION);\n  while (true) {\n    var collectionDoc = await getSingleDocument(collection.database.internalStore, collectionDocId);\n    var saveData = clone(ensureNotFalsy(collectionDoc));\n\n    // do nothing if already in array\n    var alreadyThere = saveData.data.connectedStorages.find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\n    if (alreadyThere) {\n      return;\n    }\n\n    // otherwise add to array and save\n    saveData.data.connectedStorages.push({\n      collectionName: storageCollectionName,\n      schema\n    });\n    try {\n      await writeSingle(collection.database.internalStore, {\n        previous: ensureNotFalsy(collectionDoc),\n        document: saveData\n      }, 'add-connected-storage-to-collection');\n    } catch (err) {\n      if (!isBulkWriteConflictError(err)) {\n        throw err;\n      }\n      // retry on conflict\n    }\n  }\n}\nexport async function removeConnectedStorageFromCollection(collection, storageCollectionName, schema) {\n  if (collection.schema.version !== schema.version) {\n    throw newRxError('SNH', {\n      schema,\n      version: collection.schema.version,\n      name: collection.name,\n      collection,\n      args: {\n        storageCollectionName\n      }\n    });\n  }\n  var collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\n  var collectionDocId = getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION);\n  while (true) {\n    var collectionDoc = await getSingleDocument(collection.database.internalStore, collectionDocId);\n    var saveData = clone(ensureNotFalsy(collectionDoc));\n\n    // do nothing if not there\n    var isThere = saveData.data.connectedStorages.find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\n    if (!isThere) {\n      return;\n    }\n\n    // otherwise remove from array and save\n    saveData.data.connectedStorages = saveData.data.connectedStorages.filter(item => item.collectionName !== storageCollectionName);\n    try {\n      await writeSingle(collection.database.internalStore, {\n        previous: ensureNotFalsy(collectionDoc),\n        document: saveData\n      }, 'remove-connected-storage-from-collection');\n    } catch (err) {\n      if (!isBulkWriteConflictError(err)) {\n        throw err;\n      }\n      // retry on conflict\n    }\n  }\n}\n\n/**\n * returns the primary for a given collection-data\n * used in the internal store of a RxDatabase\n */\nexport function _collectionNamePrimary(name, schema) {\n  return name + '-' + schema.version;\n}\n", "import { createRevision, flatClone, getDefaultRevision, getDefaultRxDocumentMeta, now } from \"./plugins/utils/index.js\";\nimport { fillObjectWithDefaults, fillPrimaryKey } from \"./rx-schema-helper.js\";\nimport { runAsyncPluginHooks } from \"./hooks.js\";\nimport { getAllCollectionDocuments } from \"./rx-database-internal-store.js\";\nimport { flatCloneDocWithMeta } from \"./rx-storage-helper.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { newRxError } from \"./rx-error.js\";\n\n/**\n * fills in the default data.\n * This also clones the data.\n */\nexport function fillObjectDataBeforeInsert(schema, data) {\n  data = flatClone(data);\n  data = fillObjectWithDefaults(schema, data);\n  if (typeof schema.jsonSchema.primaryKey !== 'string') {\n    data = fillPrimaryKey(schema.primaryPath, schema.jsonSchema, data);\n  }\n  data._meta = getDefaultRxDocumentMeta();\n  if (!Object.prototype.hasOwnProperty.call(data, '_deleted')) {\n    data._deleted = false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(data, '_attachments')) {\n    data._attachments = {};\n  }\n  if (!Object.prototype.hasOwnProperty.call(data, '_rev')) {\n    data._rev = getDefaultRevision();\n  }\n  return data;\n}\n\n/**\n * Creates the storage instances that are used internally in the collection\n */\nexport async function createRxCollectionStorageInstance(rxDatabase, storageInstanceCreationParams) {\n  storageInstanceCreationParams.multiInstance = rxDatabase.multiInstance;\n  var storageInstance = await rxDatabase.storage.createStorageInstance(storageInstanceCreationParams);\n  return storageInstance;\n}\n\n/**\n * Removes the main storage of the collection\n * and all connected storages like the ones from the replication meta etc.\n */\nexport async function removeCollectionStorages(storage, databaseInternalStorage, databaseInstanceToken, databaseName, collectionName, multiInstance, password,\n/**\n * If no hash function is provided,\n * we assume that the whole internal store is removed anyway\n * so we do not have to delete the meta documents.\n */\nhashFunction) {\n  var allCollectionMetaDocs = await getAllCollectionDocuments(databaseInternalStorage);\n  var relevantCollectionMetaDocs = allCollectionMetaDocs.filter(metaDoc => metaDoc.data.name === collectionName);\n  var removeStorages = [];\n  relevantCollectionMetaDocs.forEach(metaDoc => {\n    removeStorages.push({\n      collectionName: metaDoc.data.name,\n      schema: metaDoc.data.schema,\n      isCollection: true\n    });\n    metaDoc.data.connectedStorages.forEach(row => removeStorages.push({\n      collectionName: row.collectionName,\n      isCollection: false,\n      schema: row.schema\n    }));\n  });\n\n  // ensure uniqueness\n  var alreadyAdded = new Set();\n  removeStorages = removeStorages.filter(row => {\n    var key = row.collectionName + '||' + row.schema.version;\n    if (alreadyAdded.has(key)) {\n      return false;\n    } else {\n      alreadyAdded.add(key);\n      return true;\n    }\n  });\n\n  // remove all the storages\n  await Promise.all(removeStorages.map(async row => {\n    var storageInstance = await storage.createStorageInstance({\n      collectionName: row.collectionName,\n      databaseInstanceToken,\n      databaseName,\n      /**\n       * multiInstance must be set to true if multiInstance\n       * was true on the database\n       * so that the storageInstance can inform other\n       * instances about being removed.\n       */\n      multiInstance,\n      options: {},\n      schema: row.schema,\n      password,\n      devMode: overwritable.isDevMode()\n    });\n    await storageInstance.remove();\n    if (row.isCollection) {\n      await runAsyncPluginHooks('postRemoveRxCollection', {\n        storage,\n        databaseName: databaseName,\n        collectionName\n      });\n    }\n  }));\n\n  // remove the meta documents\n  if (hashFunction) {\n    var writeRows = relevantCollectionMetaDocs.map(doc => {\n      var writeDoc = flatCloneDocWithMeta(doc);\n      writeDoc._deleted = true;\n      writeDoc._meta.lwt = now();\n      writeDoc._rev = createRevision(databaseInstanceToken, doc);\n      return {\n        previous: doc,\n        document: writeDoc\n      };\n    });\n    await databaseInternalStorage.bulkWrite(writeRows, 'rx-database-remove-collection-all');\n  }\n}\nexport function ensureRxCollectionIsNotClosed(collection) {\n  if (collection.closed) {\n    throw newRxError('COL21', {\n      collection: collection.name,\n      version: collection.schema.version\n    });\n  }\n}\n", "/**\n * For the ORM capabilities,\n * we have to merge the document prototype\n * with the ORM functions and the data\n * We do this iterating over the properties and\n * adding them to a new object.\n * In the future we should do this by chaining the __proto__ objects\n */\n\nimport { createRxDocumentConstructor, basePrototype, createWithConstructor as createRxDocumentWithConstructor } from \"./rx-document.js\";\nimport { runPluginHooks } from \"./hooks.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { getFromMapOrCreate } from \"./plugins/utils/index.js\";\nvar constructorForCollection = new WeakMap();\nexport function getDocumentPrototype(rxCollection) {\n  var schemaProto = rxCollection.schema.getDocumentPrototype();\n  var ormProto = getDocumentOrmPrototype(rxCollection);\n  var baseProto = basePrototype;\n  var proto = {};\n  [schemaProto, ormProto, baseProto].forEach(obj => {\n    var props = Object.getOwnPropertyNames(obj);\n    props.forEach(key => {\n      var desc = Object.getOwnPropertyDescriptor(obj, key);\n      /**\n       * When enumerable is true, it will show on console dir(instance)\n       * To not pollute the output, only getters and methods are enumerable\n       */\n      var enumerable = true;\n      if (key.startsWith('_') || key.endsWith('_') || key.startsWith('$') || key.endsWith('$')) enumerable = false;\n      if (typeof desc.value === 'function') {\n        // when getting a function, we automatically do a .bind(this)\n        Object.defineProperty(proto, key, {\n          get() {\n            return desc.value.bind(this);\n          },\n          enumerable,\n          configurable: false\n        });\n      } else {\n        desc.enumerable = enumerable;\n        desc.configurable = false;\n        if (desc.writable) desc.writable = false;\n        Object.defineProperty(proto, key, desc);\n      }\n    });\n  });\n  return proto;\n}\nexport function getRxDocumentConstructor(rxCollection) {\n  return getFromMapOrCreate(constructorForCollection, rxCollection, () => createRxDocumentConstructor(getDocumentPrototype(rxCollection)));\n}\n\n/**\n * Create a RxDocument-instance from the jsonData\n * and the prototype merge.\n * You should never call this method directly,\n * instead you should get the document from collection._docCache.getCachedRxDocument().\n */\nexport function createNewRxDocument(rxCollection, documentConstructor, docData) {\n  var doc = createRxDocumentWithConstructor(documentConstructor, rxCollection, overwritable.deepFreezeWhenDevMode(docData));\n  rxCollection._runHooksSync('post', 'create', docData, doc);\n  runPluginHooks('postCreateRxDocument', doc);\n  return doc;\n}\n\n/**\n * returns the prototype-object\n * that contains the orm-methods,\n * used in the proto-merge\n */\nexport function getDocumentOrmPrototype(rxCollection) {\n  var proto = {};\n  Object.entries(rxCollection.methods).forEach(([k, v]) => {\n    proto[k] = v;\n  });\n  return proto;\n}\n", "import { deepEqual, flatClone } from \"../plugins/utils/index.js\";\nimport { stripAttachmentsDataFromDocument } from \"../rx-storage-helper.js\";\nexport var defaultConflictHandler = {\n  isEqual(a, b, _ctx) {\n    a = addAttachmentsIfNotExists(a);\n    b = addAttachmentsIfNotExists(b);\n\n    /**\n     * If the documents are deep equal,\n     * we have no conflict.\n     * On your custom conflict handler you might only\n     * check some properties, like the updatedAt time,\n     * for better performance, because deepEqual is expensive.\n    */\n    var ret = deepEqual(stripAttachmentsDataFromDocument(a), stripAttachmentsDataFromDocument(b));\n    return ret;\n  },\n  resolve(i) {\n    /**\n     * The default conflict handler will always\n     * drop the fork state and use the master state instead.\n     */\n    return i.realMasterState;\n  }\n};\nfunction addAttachmentsIfNotExists(d) {\n  if (!d._attachments) {\n    d = flatClone(d);\n    d._attachments = {};\n  }\n  return d;\n}\n", "/**\n * a buffer-cache which holds the last X changeEvents of the collection\n */\n\nimport { filter } from 'rxjs/operators';\nimport { appendToArray, requestIdlePromiseNoQueue } from \"./plugins/utils/index.js\";\n\n/**\n * This buffer rembemers previous change events\n * so that queries can use them on .exec()\n * to calculate the new result set via event-reduce instead\n * of running the query against the storage.\n */\nexport var ChangeEventBuffer = /*#__PURE__*/function () {\n  /**\n   * These properties are private to ensure they cannot\n   * be read without first processing the lazy tasks.\n   */\n\n  /**\n   * array with changeEvents\n   * starts with oldest known event, ends with newest\n  */\n\n  function ChangeEventBuffer(collection) {\n    this.subs = [];\n    this.counter = 0;\n    this.eventCounterMap = new WeakMap();\n    this.buffer = [];\n    this.limit = 100;\n    this.tasks = new Set();\n    this.collection = collection;\n    this.subs.push(this.collection.eventBulks$.pipe(filter(bulk => !bulk.isLocal)).subscribe(eventBulk => {\n      this.tasks.add(() => this._handleChangeEvents(eventBulk.events));\n      if (this.tasks.size <= 1) {\n        requestIdlePromiseNoQueue().then(() => {\n          this.processTasks();\n        });\n      }\n    }));\n  }\n  var _proto = ChangeEventBuffer.prototype;\n  _proto.processTasks = function processTasks() {\n    if (this.tasks.size === 0) {\n      return;\n    }\n    var tasks = Array.from(this.tasks);\n    tasks.forEach(task => task());\n    this.tasks.clear();\n  };\n  _proto._handleChangeEvents = function _handleChangeEvents(events) {\n    var counterBefore = this.counter;\n    this.counter = this.counter + events.length;\n    if (events.length > this.limit) {\n      this.buffer = events.slice(events.length * -1);\n    } else {\n      appendToArray(this.buffer, events);\n      this.buffer = this.buffer.slice(this.limit * -1);\n    }\n    var counterBase = counterBefore + 1;\n    var eventCounterMap = this.eventCounterMap;\n    for (var index = 0; index < events.length; index++) {\n      var event = events[index];\n      eventCounterMap.set(event, counterBase + index);\n    }\n  };\n  _proto.getCounter = function getCounter() {\n    this.processTasks();\n    return this.counter;\n  };\n  _proto.getBuffer = function getBuffer() {\n    this.processTasks();\n    return this.buffer;\n  }\n\n  /**\n   * gets the array-index for the given pointer\n   * @return arrayIndex which can be used to iterate from there. If null, pointer is out of lower bound\n   */;\n  _proto.getArrayIndexByPointer = function getArrayIndexByPointer(pointer) {\n    this.processTasks();\n    var oldestEvent = this.buffer[0];\n    var oldestCounter = this.eventCounterMap.get(oldestEvent);\n    if (pointer < oldestCounter) return null; // out of bounds\n\n    var rest = pointer - oldestCounter;\n    return rest;\n  }\n\n  /**\n   * get all changeEvents which came in later than the pointer-event\n   * @return array with change-events. If null, pointer out of bounds\n   */;\n  _proto.getFrom = function getFrom(pointer) {\n    this.processTasks();\n    var ret = [];\n    var currentIndex = this.getArrayIndexByPointer(pointer);\n    if (currentIndex === null)\n      // out of bounds\n      return null;\n    while (true) {\n      var nextEvent = this.buffer[currentIndex];\n      currentIndex++;\n      if (!nextEvent) {\n        return ret;\n      } else {\n        ret.push(nextEvent);\n      }\n    }\n  };\n  _proto.runFrom = function runFrom(pointer, fn) {\n    this.processTasks();\n    var ret = this.getFrom(pointer);\n    if (ret === null) {\n      throw new Error('out of bounds');\n    } else {\n      ret.forEach(cE => fn(cE));\n    }\n  }\n\n  /**\n   * no matter how many operations are done on one document,\n   * only the last operation has to be checked to calculate the new state\n   * this function reduces the events to the last ChangeEvent of each doc.\n   * This functionality is currently disabled. It is questionable if\n   * pre-merging the events would really be faster or actually slower.\n   */;\n  _proto.reduceByLastOfDoc = function reduceByLastOfDoc(changeEvents) {\n    this.processTasks();\n    return changeEvents.slice(0);\n  };\n  _proto.close = function close() {\n    this.tasks.clear();\n    this.subs.forEach(sub => sub.unsubscribe());\n  };\n  return ChangeEventBuffer;\n}();\nexport function createChangeEventBuffer(collection) {\n  return new ChangeEventBuffer(collection);\n}\n", "import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { filter, map, mergeMap } from 'rxjs';\nimport { ucfirst, flatClone, promiseSeries, pluginMissing, ensureNotFalsy, getFromMapOrThrow, PROMISE_RESOLVE_FALSE, PROMISE_RESOLVE_VOID, NON_PREMIUM_COLLECTION_LIMIT, hasPremiumFlag } from \"./plugins/utils/index.js\";\nimport { fillObjectDataBeforeInsert, createRxCollectionStorageInstance, removeCollectionStorages, ensureRxCollectionIsNotClosed } from \"./rx-collection-helper.js\";\nimport { createRxQuery, _getDefaultQuery } from \"./rx-query.js\";\nimport { newRxError, newRxTypeError } from \"./rx-error.js\";\nimport { DocumentCache, mapDocumentsDataToCacheDocs } from \"./doc-cache.js\";\nimport { createQueryCache, defaultCacheReplacementPolicy } from \"./query-cache.js\";\nimport { createChangeEventBuffer } from \"./change-event-buffer.js\";\nimport { runAsyncPluginHooks, runPluginHooks } from \"./hooks.js\";\nimport { createNewRxDocument, getRxDocumentConstructor } from \"./rx-document-prototype-merge.js\";\nimport { getWrappedStorageInstance, getWrittenDocumentsFromBulkWriteResponse, throwIfIsStorageWriteError } from \"./rx-storage-helper.js\";\nimport { IncrementalWriteQueue } from \"./incremental-write.js\";\nimport { beforeDocumentUpdateWrite } from \"./rx-document.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { defaultConflictHandler } from \"./replication-protocol/default-conflict-handler.js\";\nimport { rxChangeEventBulkToRxChangeEvents } from \"./rx-change-event.js\";\nvar HOOKS_WHEN = ['pre', 'post'];\nvar HOOKS_KEYS = ['insert', 'save', 'remove', 'create'];\nvar hooksApplied = false;\nexport var OPEN_COLLECTIONS = new Set();\nexport var RxCollectionBase = /*#__PURE__*/function () {\n  /**\n   * Stores all 'normal' documents\n   */\n\n  /**\n   * Before reads, all these methods are awaited. Used to \"block\" reads\n   * depending on other processes, like when the RxPipeline is running.\n   */\n\n  function RxCollectionBase(database, name, schema, internalStorageInstance, instanceCreationOptions = {}, migrationStrategies = {}, methods = {}, attachments = {}, options = {}, cacheReplacementPolicy = defaultCacheReplacementPolicy, statics = {}, conflictHandler = defaultConflictHandler) {\n    this.storageInstance = {};\n    this.timeouts = new Set();\n    this.incrementalWriteQueue = {};\n    this.awaitBeforeReads = new Set();\n    this._incrementalUpsertQueues = new Map();\n    this.synced = false;\n    this.hooks = {};\n    this._subs = [];\n    this._docCache = {};\n    this._queryCache = createQueryCache();\n    this.$ = {};\n    this.checkpoint$ = {};\n    this._changeEventBuffer = {};\n    this.eventBulks$ = {};\n    this.onClose = [];\n    this.closed = false;\n    this.onRemove = [];\n    this.database = database;\n    this.name = name;\n    this.schema = schema;\n    this.internalStorageInstance = internalStorageInstance;\n    this.instanceCreationOptions = instanceCreationOptions;\n    this.migrationStrategies = migrationStrategies;\n    this.methods = methods;\n    this.attachments = attachments;\n    this.options = options;\n    this.cacheReplacementPolicy = cacheReplacementPolicy;\n    this.statics = statics;\n    this.conflictHandler = conflictHandler;\n    _applyHookFunctions(this.asRxCollection);\n    if (database) {\n      // might be falsy on pseudoInstance\n      this.eventBulks$ = database.eventBulks$.pipe(filter(changeEventBulk => changeEventBulk.collectionName === this.name));\n    } else {}\n\n    /**\n     * Must be last because the hooks might throw on dev-mode\n     * checks and we do not want to have broken collections here.\n     * RxCollection instances created for testings do not have a database\n     * so we do not add these to the list.\n     */\n    if (this.database) {\n      OPEN_COLLECTIONS.add(this);\n    }\n  }\n  var _proto = RxCollectionBase.prototype;\n  _proto.prepare = async function prepare() {\n    if (!(await hasPremiumFlag())) {\n      /**\n       * When used in a test suite, we often open and close many databases with collections\n       * while not awaiting the database.close() call to improve the test times.\n       * So when reopening collections and the OPEN_COLLECTIONS size is full,\n       * we retry after some times to account for this.\n       */\n      var count = 0;\n      while (count < 10 && OPEN_COLLECTIONS.size > NON_PREMIUM_COLLECTION_LIMIT) {\n        count++;\n        await this.promiseWait(30);\n      }\n      if (OPEN_COLLECTIONS.size > NON_PREMIUM_COLLECTION_LIMIT) {\n        throw newRxError('COL23', {\n          database: this.database.name,\n          collection: this.name,\n          args: {\n            existing: Array.from(OPEN_COLLECTIONS.values()).map(c => ({\n              db: c.database ? c.database.name : '',\n              c: c.name\n            }))\n          }\n        });\n      }\n    }\n    this.storageInstance = getWrappedStorageInstance(this.database, this.internalStorageInstance, this.schema.jsonSchema);\n    this.incrementalWriteQueue = new IncrementalWriteQueue(this.storageInstance, this.schema.primaryPath, (newData, oldData) => beforeDocumentUpdateWrite(this, newData, oldData), result => this._runHooks('post', 'save', result));\n    this.$ = this.eventBulks$.pipe(mergeMap(changeEventBulk => rxChangeEventBulkToRxChangeEvents(changeEventBulk)));\n    this.checkpoint$ = this.eventBulks$.pipe(map(changeEventBulk => changeEventBulk.checkpoint));\n    this._changeEventBuffer = createChangeEventBuffer(this.asRxCollection);\n    var documentConstructor;\n    this._docCache = new DocumentCache(this.schema.primaryPath, this.eventBulks$.pipe(filter(bulk => !bulk.isLocal), map(bulk => bulk.events)), docData => {\n      if (!documentConstructor) {\n        documentConstructor = getRxDocumentConstructor(this.asRxCollection);\n      }\n      return createNewRxDocument(this.asRxCollection, documentConstructor, docData);\n    });\n    var listenToRemoveSub = this.database.internalStore.changeStream().pipe(filter(bulk => {\n      var key = this.name + '-' + this.schema.version;\n      var found = bulk.events.find(event => {\n        return event.documentData.context === 'collection' && event.documentData.key === key && event.operation === 'DELETE';\n      });\n      return !!found;\n    })).subscribe(async () => {\n      await this.close();\n      await Promise.all(this.onRemove.map(fn => fn()));\n    });\n    this._subs.push(listenToRemoveSub);\n    var databaseStorageToken = await this.database.storageToken;\n    var subDocs = this.storageInstance.changeStream().subscribe(eventBulk => {\n      var changeEventBulk = {\n        id: eventBulk.id,\n        isLocal: false,\n        internal: false,\n        collectionName: this.name,\n        storageToken: databaseStorageToken,\n        events: eventBulk.events,\n        databaseToken: this.database.token,\n        checkpoint: eventBulk.checkpoint,\n        context: eventBulk.context\n      };\n      this.database.$emit(changeEventBulk);\n    });\n    this._subs.push(subDocs);\n    return PROMISE_RESOLVE_VOID;\n  }\n\n  /**\n   * Manually call the cleanup function of the storage.\n   * @link https://rxdb.info/cleanup.html\n   */;\n  _proto.cleanup = function cleanup(_minimumDeletedTime) {\n    ensureRxCollectionIsNotClosed(this);\n    throw pluginMissing('cleanup');\n  }\n\n  // overwritten by migration-plugin\n  ;\n  _proto.migrationNeeded = function migrationNeeded() {\n    throw pluginMissing('migration-schema');\n  };\n  _proto.getMigrationState = function getMigrationState() {\n    throw pluginMissing('migration-schema');\n  };\n  _proto.startMigration = function startMigration(batchSize = 10) {\n    ensureRxCollectionIsNotClosed(this);\n    return this.getMigrationState().startMigration(batchSize);\n  };\n  _proto.migratePromise = function migratePromise(batchSize = 10) {\n    return this.getMigrationState().migratePromise(batchSize);\n  };\n  _proto.insert = async function insert(json) {\n    ensureRxCollectionIsNotClosed(this);\n    var writeResult = await this.bulkInsert([json]);\n    var isError = writeResult.error[0];\n    throwIfIsStorageWriteError(this, json[this.schema.primaryPath], json, isError);\n    var insertResult = ensureNotFalsy(writeResult.success[0]);\n    return insertResult;\n  };\n  _proto.insertIfNotExists = async function insertIfNotExists(json) {\n    var writeResult = await this.bulkInsert([json]);\n    if (writeResult.error.length > 0) {\n      var error = writeResult.error[0];\n      if (error.status === 409) {\n        var conflictDocData = error.documentInDb;\n        return mapDocumentsDataToCacheDocs(this._docCache, [conflictDocData])[0];\n      } else {\n        throw error;\n      }\n    }\n    return writeResult.success[0];\n  };\n  _proto.bulkInsert = async function bulkInsert(docsData) {\n    ensureRxCollectionIsNotClosed(this);\n    /**\n     * Optimization shortcut,\n     * do nothing when called with an empty array\n    */\n    if (docsData.length === 0) {\n      return {\n        success: [],\n        error: []\n      };\n    }\n    var primaryPath = this.schema.primaryPath;\n    var ids = new Set();\n\n    /**\n     * This code is a bit redundant for better performance.\n     * Instead of iterating multiple times,\n     * we directly transform the input to a write-row array.\n     */\n    var insertRows;\n    if (this.hasHooks('pre', 'insert')) {\n      insertRows = await Promise.all(docsData.map(docData => {\n        var useDocData = fillObjectDataBeforeInsert(this.schema, docData);\n        return this._runHooks('pre', 'insert', useDocData).then(() => {\n          ids.add(useDocData[primaryPath]);\n          return {\n            document: useDocData\n          };\n        });\n      }));\n    } else {\n      insertRows = new Array(docsData.length);\n      var _schema = this.schema;\n      for (var index = 0; index < docsData.length; index++) {\n        var docData = docsData[index];\n        var useDocData = fillObjectDataBeforeInsert(_schema, docData);\n        ids.add(useDocData[primaryPath]);\n        insertRows[index] = {\n          document: useDocData\n        };\n      }\n    }\n    if (ids.size !== docsData.length) {\n      throw newRxError('COL22', {\n        collection: this.name,\n        args: {\n          documents: docsData\n        }\n      });\n    }\n    var results = await this.storageInstance.bulkWrite(insertRows, 'rx-collection-bulk-insert');\n\n    /**\n     * Often the user does not need to access the RxDocuments of the bulkInsert() call.\n     * So we transform the data to RxDocuments only if needed to use less CPU performance.\n     */\n    var rxDocuments;\n    var collection = this;\n    var ret = {\n      get success() {\n        if (!rxDocuments) {\n          var success = getWrittenDocumentsFromBulkWriteResponse(collection.schema.primaryPath, insertRows, results);\n          rxDocuments = mapDocumentsDataToCacheDocs(collection._docCache, success);\n        }\n        return rxDocuments;\n      },\n      error: results.error\n    };\n    if (this.hasHooks('post', 'insert')) {\n      var docsMap = new Map();\n      insertRows.forEach(row => {\n        var doc = row.document;\n        docsMap.set(doc[primaryPath], doc);\n      });\n      await Promise.all(ret.success.map(doc => {\n        return this._runHooks('post', 'insert', docsMap.get(doc.primary), doc);\n      }));\n    }\n    return ret;\n  };\n  _proto.bulkRemove = async function bulkRemove(\n  /**\n   * You can either remove the documents by their ids\n   * or by directly providing the RxDocument instances\n   * if you have them already. This improves performance a bit.\n   */\n  idsOrDocs) {\n    ensureRxCollectionIsNotClosed(this);\n    var primaryPath = this.schema.primaryPath;\n    /**\n     * Optimization shortcut,\n     * do nothing when called with an empty array\n     */\n    if (idsOrDocs.length === 0) {\n      return {\n        success: [],\n        error: []\n      };\n    }\n    var rxDocumentMap;\n    if (typeof idsOrDocs[0] === 'string') {\n      rxDocumentMap = await this.findByIds(idsOrDocs).exec();\n    } else {\n      rxDocumentMap = new Map();\n      idsOrDocs.forEach(d => rxDocumentMap.set(d.primary, d));\n    }\n    var docsData = [];\n    var docsMap = new Map();\n    Array.from(rxDocumentMap.values()).forEach(rxDocument => {\n      var data = rxDocument.toMutableJSON(true);\n      docsData.push(data);\n      docsMap.set(rxDocument.primary, data);\n    });\n    await Promise.all(docsData.map(doc => {\n      var primary = doc[this.schema.primaryPath];\n      return this._runHooks('pre', 'remove', doc, rxDocumentMap.get(primary));\n    }));\n    var removeDocs = docsData.map(doc => {\n      var writeDoc = flatClone(doc);\n      writeDoc._deleted = true;\n      return {\n        previous: doc,\n        document: writeDoc\n      };\n    });\n    var results = await this.storageInstance.bulkWrite(removeDocs, 'rx-collection-bulk-remove');\n    var success = getWrittenDocumentsFromBulkWriteResponse(this.schema.primaryPath, removeDocs, results);\n    var deletedRxDocuments = [];\n    var successIds = success.map(d => {\n      var id = d[primaryPath];\n      var doc = this._docCache.getCachedRxDocument(d);\n      deletedRxDocuments.push(doc);\n      return id;\n    });\n\n    // run hooks\n    await Promise.all(successIds.map(id => {\n      return this._runHooks('post', 'remove', docsMap.get(id), rxDocumentMap.get(id));\n    }));\n    return {\n      success: deletedRxDocuments,\n      error: results.error\n    };\n  }\n\n  /**\n   * same as bulkInsert but overwrites existing document with same primary\n   */;\n  _proto.bulkUpsert = async function bulkUpsert(docsData) {\n    ensureRxCollectionIsNotClosed(this);\n    var insertData = [];\n    var useJsonByDocId = new Map();\n    docsData.forEach(docData => {\n      var useJson = fillObjectDataBeforeInsert(this.schema, docData);\n      var primary = useJson[this.schema.primaryPath];\n      if (!primary) {\n        throw newRxError('COL3', {\n          primaryPath: this.schema.primaryPath,\n          data: useJson,\n          schema: this.schema.jsonSchema\n        });\n      }\n      useJsonByDocId.set(primary, useJson);\n      insertData.push(useJson);\n    });\n    var insertResult = await this.bulkInsert(insertData);\n    var success = insertResult.success.slice(0);\n    var error = [];\n\n    // update the ones that existed already\n    await Promise.all(insertResult.error.map(async err => {\n      if (err.status !== 409) {\n        error.push(err);\n      } else {\n        var id = err.documentId;\n        var writeData = getFromMapOrThrow(useJsonByDocId, id);\n        var docDataInDb = ensureNotFalsy(err.documentInDb);\n        var doc = this._docCache.getCachedRxDocuments([docDataInDb])[0];\n        var newDoc = await doc.incrementalModify(() => writeData);\n        success.push(newDoc);\n      }\n    }));\n    return {\n      error,\n      success\n    };\n  }\n\n  /**\n   * same as insert but overwrites existing document with same primary\n   */;\n  _proto.upsert = async function upsert(json) {\n    ensureRxCollectionIsNotClosed(this);\n    var bulkResult = await this.bulkUpsert([json]);\n    throwIfIsStorageWriteError(this.asRxCollection, json[this.schema.primaryPath], json, bulkResult.error[0]);\n    return bulkResult.success[0];\n  }\n\n  /**\n   * upserts to a RxDocument, uses incrementalModify if document already exists\n   */;\n  _proto.incrementalUpsert = function incrementalUpsert(json) {\n    ensureRxCollectionIsNotClosed(this);\n    var useJson = fillObjectDataBeforeInsert(this.schema, json);\n    var primary = useJson[this.schema.primaryPath];\n    if (!primary) {\n      throw newRxError('COL4', {\n        data: json\n      });\n    }\n\n    // ensure that it won't try 2 parallel runs\n    var queue = this._incrementalUpsertQueues.get(primary);\n    if (!queue) {\n      queue = PROMISE_RESOLVE_VOID;\n    }\n    queue = queue.then(() => _incrementalUpsertEnsureRxDocumentExists(this, primary, useJson)).then(wasInserted => {\n      if (!wasInserted.inserted) {\n        return _incrementalUpsertUpdate(wasInserted.doc, useJson);\n      } else {\n        return wasInserted.doc;\n      }\n    });\n    this._incrementalUpsertQueues.set(primary, queue);\n    return queue;\n  };\n  _proto.find = function find(queryObj) {\n    ensureRxCollectionIsNotClosed(this);\n    runPluginHooks('prePrepareRxQuery', {\n      op: 'find',\n      queryObj,\n      collection: this\n    });\n    if (!queryObj) {\n      queryObj = _getDefaultQuery();\n    }\n    var query = createRxQuery('find', queryObj, this);\n    return query;\n  };\n  _proto.findOne = function findOne(queryObj) {\n    ensureRxCollectionIsNotClosed(this);\n    runPluginHooks('prePrepareRxQuery', {\n      op: 'findOne',\n      queryObj,\n      collection: this\n    });\n    var query;\n    if (typeof queryObj === 'string') {\n      query = createRxQuery('findOne', {\n        selector: {\n          [this.schema.primaryPath]: queryObj\n        },\n        limit: 1\n      }, this);\n    } else {\n      if (!queryObj) {\n        queryObj = _getDefaultQuery();\n      }\n\n      // cannot have limit on findOne queries because it will be overwritten\n      if (queryObj.limit) {\n        throw newRxError('QU6');\n      }\n      queryObj = flatClone(queryObj);\n      queryObj.limit = 1;\n      query = createRxQuery('findOne', queryObj, this);\n    }\n    return query;\n  };\n  _proto.count = function count(queryObj) {\n    ensureRxCollectionIsNotClosed(this);\n    if (!queryObj) {\n      queryObj = _getDefaultQuery();\n    }\n    var query = createRxQuery('count', queryObj, this);\n    return query;\n  }\n\n  /**\n   * find a list documents by their primary key\n   * has way better performance then running multiple findOne() or a find() with a complex $or-selected\n   */;\n  _proto.findByIds = function findByIds(ids) {\n    ensureRxCollectionIsNotClosed(this);\n    var mangoQuery = {\n      selector: {\n        [this.schema.primaryPath]: {\n          $in: ids.slice(0)\n        }\n      }\n    };\n    var query = createRxQuery('findByIds', mangoQuery, this);\n    return query;\n  }\n\n  /**\n   * Export collection to a JSON friendly format.\n   */;\n  _proto.exportJSON = function exportJSON() {\n    throw pluginMissing('json-dump');\n  }\n\n  /**\n   * Import the parsed JSON export into the collection.\n   * @param _exportedJSON The previously exported data from the `<collection>.exportJSON()` method.\n   */;\n  _proto.importJSON = function importJSON(_exportedJSON) {\n    throw pluginMissing('json-dump');\n  };\n  _proto.insertCRDT = function insertCRDT(_updateObj) {\n    throw pluginMissing('crdt');\n  };\n  _proto.addPipeline = function addPipeline(_options) {\n    throw pluginMissing('pipeline');\n  }\n\n  /**\n   * HOOKS\n   */;\n  _proto.addHook = function addHook(when, key, fun, parallel = false) {\n    if (typeof fun !== 'function') {\n      throw newRxTypeError('COL7', {\n        key,\n        when\n      });\n    }\n    if (!HOOKS_WHEN.includes(when)) {\n      throw newRxTypeError('COL8', {\n        key,\n        when\n      });\n    }\n    if (!HOOKS_KEYS.includes(key)) {\n      throw newRxError('COL9', {\n        key\n      });\n    }\n    if (when === 'post' && key === 'create' && parallel === true) {\n      throw newRxError('COL10', {\n        when,\n        key,\n        parallel\n      });\n    }\n\n    // bind this-scope to hook-function\n    var boundFun = fun.bind(this);\n    var runName = parallel ? 'parallel' : 'series';\n    this.hooks[key] = this.hooks[key] || {};\n    this.hooks[key][when] = this.hooks[key][when] || {\n      series: [],\n      parallel: []\n    };\n    this.hooks[key][when][runName].push(boundFun);\n  };\n  _proto.getHooks = function getHooks(when, key) {\n    if (!this.hooks[key] || !this.hooks[key][when]) {\n      return {\n        series: [],\n        parallel: []\n      };\n    }\n    return this.hooks[key][when];\n  };\n  _proto.hasHooks = function hasHooks(when, key) {\n    /**\n     * Performance shortcut\n     * so that we not have to build the empty object.\n     */\n    if (!this.hooks[key] || !this.hooks[key][when]) {\n      return false;\n    }\n    var hooks = this.getHooks(when, key);\n    if (!hooks) {\n      return false;\n    }\n    return hooks.series.length > 0 || hooks.parallel.length > 0;\n  };\n  _proto._runHooks = function _runHooks(when, key, data, instance) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) {\n      return PROMISE_RESOLVE_VOID;\n    }\n\n    // run parallel: false\n    var tasks = hooks.series.map(hook => () => hook(data, instance));\n    return promiseSeries(tasks)\n    // run parallel: true\n    .then(() => Promise.all(hooks.parallel.map(hook => hook(data, instance))));\n  }\n\n  /**\n   * does the same as ._runHooks() but with non-async-functions\n   */;\n  _proto._runHooksSync = function _runHooksSync(when, key, data, instance) {\n    if (!this.hasHooks(when, key)) {\n      return;\n    }\n    var hooks = this.getHooks(when, key);\n    if (!hooks) return;\n    hooks.series.forEach(hook => hook(data, instance));\n  }\n\n  /**\n   * Returns a promise that resolves after the given time.\n   * Ensures that is properly cleans up when the collection is closed\n   * so that no running timeouts prevent the exit of the JavaScript process.\n   */;\n  _proto.promiseWait = function promiseWait(time) {\n    var ret = new Promise(res => {\n      var timeout = setTimeout(() => {\n        this.timeouts.delete(timeout);\n        res();\n      }, time);\n      this.timeouts.add(timeout);\n    });\n    return ret;\n  };\n  _proto.close = async function close() {\n    if (this.closed) {\n      return PROMISE_RESOLVE_FALSE;\n    }\n    OPEN_COLLECTIONS.delete(this);\n    await Promise.all(this.onClose.map(fn => fn()));\n\n    /**\n     * Settings closed = true\n     * must be the first thing to do,\n     * so for example the replication can directly stop\n     * instead of sending requests to a closed storage.\n     */\n    this.closed = true;\n    Array.from(this.timeouts).forEach(timeout => clearTimeout(timeout));\n    if (this._changeEventBuffer) {\n      this._changeEventBuffer.close();\n    }\n    /**\n     * First wait until the whole database is idle.\n     * This ensures that the storage does not get closed\n     * while some operation is running.\n     * It is important that we do not intercept a running call\n     * because it might lead to undefined behavior like when a doc is written\n     * but the change is not added to the changes collection.\n     */\n    return this.database.requestIdlePromise().then(() => this.storageInstance.close()).then(() => {\n      /**\n       * Unsubscribing must be done AFTER the storageInstance.close()\n       * Because the conflict handling is part of the subscriptions and\n       * otherwise there might be open conflicts to be resolved which\n       * will then stuck and never resolve.\n       */\n      this._subs.forEach(sub => sub.unsubscribe());\n      delete this.database.collections[this.name];\n      return runAsyncPluginHooks('postCloseRxCollection', this).then(() => true);\n    });\n  }\n\n  /**\n   * remove all data of the collection\n   */;\n  _proto.remove = async function remove() {\n    await this.close();\n    await Promise.all(this.onRemove.map(fn => fn()));\n    /**\n     * TODO here we should pass the already existing\n     * storage instances instead of creating new ones.\n     */\n    await removeCollectionStorages(this.database.storage, this.database.internalStore, this.database.token, this.database.name, this.name, this.database.multiInstance, this.database.password, this.database.hashFunction);\n  };\n  return _createClass(RxCollectionBase, [{\n    key: \"insert$\",\n    get: function () {\n      return this.$.pipe(filter(cE => cE.operation === 'INSERT'));\n    }\n  }, {\n    key: \"update$\",\n    get: function () {\n      return this.$.pipe(filter(cE => cE.operation === 'UPDATE'));\n    }\n  }, {\n    key: \"remove$\",\n    get: function () {\n      return this.$.pipe(filter(cE => cE.operation === 'DELETE'));\n    }\n\n    // defaults\n\n    /**\n     * Internally only use eventBulks$\n     * Do not use .$ or .observable$ because that has to transform\n     * the events which decreases performance.\n     */\n\n    /**\n     * When the collection is closed,\n     * these functions will be called an awaited.\n     * Used to automatically clean up stuff that\n     * belongs to this collection.\n    */\n  }, {\n    key: \"asRxCollection\",\n    get: function () {\n      return this;\n    }\n  }]);\n}();\n\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\nfunction _applyHookFunctions(collection) {\n  if (hooksApplied) return; // already run\n  hooksApplied = true;\n  var colProto = Object.getPrototypeOf(collection);\n  HOOKS_KEYS.forEach(key => {\n    HOOKS_WHEN.map(when => {\n      var fnName = when + ucfirst(key);\n      colProto[fnName] = function (fun, parallel) {\n        return this.addHook(when, key, fun, parallel);\n      };\n    });\n  });\n}\nfunction _incrementalUpsertUpdate(doc, json) {\n  return doc.incrementalModify(_innerDoc => {\n    return json;\n  });\n}\n\n/**\n * ensures that the given document exists\n * @return promise that resolves with new doc and flag if inserted\n */\nfunction _incrementalUpsertEnsureRxDocumentExists(rxCollection, primary, json) {\n  /**\n   * Optimisation shortcut,\n   * first try to find the document in the doc-cache\n   */\n  var docDataFromCache = rxCollection._docCache.getLatestDocumentDataIfExists(primary);\n  if (docDataFromCache) {\n    return Promise.resolve({\n      doc: rxCollection._docCache.getCachedRxDocuments([docDataFromCache])[0],\n      inserted: false\n    });\n  }\n  return rxCollection.findOne(primary).exec().then(doc => {\n    if (!doc) {\n      return rxCollection.insert(json).then(newDoc => ({\n        doc: newDoc,\n        inserted: true\n      }));\n    } else {\n      return {\n        doc,\n        inserted: false\n      };\n    }\n  });\n}\n\n/**\n * creates and prepares a new collection\n */\nexport async function createRxCollection({\n  database,\n  name,\n  schema,\n  instanceCreationOptions = {},\n  migrationStrategies = {},\n  autoMigrate = true,\n  statics = {},\n  methods = {},\n  attachments = {},\n  options = {},\n  localDocuments = false,\n  cacheReplacementPolicy = defaultCacheReplacementPolicy,\n  conflictHandler = defaultConflictHandler\n}) {\n  var storageInstanceCreationParams = {\n    databaseInstanceToken: database.token,\n    databaseName: database.name,\n    collectionName: name,\n    schema: schema.jsonSchema,\n    options: instanceCreationOptions,\n    multiInstance: database.multiInstance,\n    password: database.password,\n    devMode: overwritable.isDevMode()\n  };\n  runPluginHooks('preCreateRxStorageInstance', storageInstanceCreationParams);\n  var storageInstance = await createRxCollectionStorageInstance(database, storageInstanceCreationParams);\n  var collection = new RxCollectionBase(database, name, schema, storageInstance, instanceCreationOptions, migrationStrategies, methods, attachments, options, cacheReplacementPolicy, statics, conflictHandler);\n  try {\n    await collection.prepare();\n\n    // ORM add statics\n    Object.entries(statics).forEach(([funName, fun]) => {\n      Object.defineProperty(collection, funName, {\n        get: () => fun.bind(collection)\n      });\n    });\n    runPluginHooks('createRxCollection', {\n      collection,\n      creator: {\n        name,\n        schema,\n        storageInstance,\n        instanceCreationOptions,\n        migrationStrategies,\n        methods,\n        attachments,\n        options,\n        cacheReplacementPolicy,\n        localDocuments,\n        statics\n      }\n    });\n\n    /**\n     * Migration must run after the hooks so that the\n     * dev-mode can check up front if the\n     * migration strategies are correctly set.\n     */\n    if (autoMigrate && collection.schema.version !== 0) {\n      await collection.migratePromise();\n    }\n  } catch (err) {\n    /**\n     * If the collection creation fails,\n     * we yet have to close the storage instances.\n     */\n    OPEN_COLLECTIONS.delete(collection);\n    await storageInstance.close();\n    throw err;\n  }\n  return collection;\n}\nexport function isRxCollection(obj) {\n  return obj instanceof RxCollectionBase;\n}\n", "/**\n * Creates a new Idle-Queue\n * @constructor\n * @param {number} [parallels=1] amount of parrallel runs of the limited-ressource\n */\nexport var IdleQueue = function IdleQueue() {\n  var parallels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  this._parallels = parallels || 1;\n\n  /**\n   * _queueCounter\n   * each lock() increased this number\n   * each unlock() decreases this number\n   * If _qC==0, the state is in idle\n   * @type {Number}\n   */\n  this._qC = 0;\n\n  /**\n   * _idleCalls\n   * contains all promises that where added via requestIdlePromise()\n   * and not have been resolved\n   * @type {Set<Promise>} _iC with oldest promise first\n   */\n  this._iC = new Set();\n\n  /**\n   * _lastHandleNumber\n   * @type {Number}\n   */\n  this._lHN = 0;\n\n  /**\n   * _handlePromiseMap\n   * Contains the handleNumber on the left\n   * And the assigned promise on the right.\n   * This is stored so you can use cancelIdleCallback(handleNumber)\n   * to stop executing the callback.\n   * @type {Map<Number><Promise>}\n   */\n  this._hPM = new Map();\n  this._pHM = new Map(); // _promiseHandleMap\n};\nIdleQueue.prototype = {\n  isIdle: function isIdle() {\n    return this._qC < this._parallels;\n  },\n  /**\n   * creates a lock in the queue\n   * and returns an unlock-function to remove the lock from the queue\n   * @return {function} unlock function than must be called afterwards\n   */\n  lock: function lock() {\n    this._qC++;\n  },\n  unlock: function unlock() {\n    this._qC--;\n    _tryIdleCall(this);\n  },\n  /**\n   * wraps a function with lock/unlock and runs it\n   * @performance is really important here because\n   * it is often used in hot paths.\n   * @param  {function}  fun\n   * @return {Promise<any>}\n   */\n  wrapCall: function wrapCall(fun) {\n    var _this = this;\n    this._qC++;\n    var maybePromise;\n    try {\n      maybePromise = fun();\n    } catch (err) {\n      this.unlock();\n      throw err;\n    }\n    if (!maybePromise.then || typeof maybePromise.then !== 'function') {\n      // no promise\n      this.unlock();\n      return maybePromise;\n    } else {\n      // promise\n      return maybePromise.then(function (ret) {\n        // sucessfull -> unlock before return\n        _this.unlock();\n        return ret;\n      })[\"catch\"](function (err) {\n        // not sucessfull -> unlock before throwing\n        _this.unlock();\n        throw err;\n      });\n    }\n  },\n  /**\n   * does the same as requestIdleCallback() but uses promises instead of the callback\n   * @param {{timeout?: number}} options like timeout\n   * @return {Promise<void>} promise that resolves when the database is in idle-mode\n   */\n  requestIdlePromise: function requestIdlePromise(options) {\n    var _this2 = this;\n    options = options || {};\n    var resolve;\n    var prom = new Promise(function (res) {\n      return resolve = res;\n    });\n    var resolveFromOutside = function resolveFromOutside() {\n      _removeIdlePromise(_this2, prom);\n      resolve();\n    };\n    prom._manRes = resolveFromOutside;\n    if (options.timeout) {\n      // if timeout has passed, resolve promise even if not idle\n      var timeoutObj = setTimeout(function () {\n        prom._manRes();\n      }, options.timeout);\n      prom._timeoutObj = timeoutObj;\n    }\n    this._iC.add(prom);\n    _tryIdleCall(this);\n    return prom;\n  },\n  /**\n   * remove the promise so it will never be resolved\n   * @param  {Promise} promise from requestIdlePromise()\n   * @return {void}\n   */\n  cancelIdlePromise: function cancelIdlePromise(promise) {\n    _removeIdlePromise(this, promise);\n  },\n  /**\n   * api equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n   * @param  {Function} callback\n   * @param  {options}   options  [description]\n   * @return {number} handle which can be used with cancelIdleCallback()\n   */\n  requestIdleCallback: function requestIdleCallback(callback, options) {\n    var handle = this._lHN++;\n    var promise = this.requestIdlePromise(options);\n    this._hPM.set(handle, promise);\n    this._pHM.set(promise, handle);\n    promise.then(function () {\n      return callback();\n    });\n    return handle;\n  },\n  /**\n   * API equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelIdleCallback\n   * @param  {number} handle returned from requestIdleCallback()\n   * @return {void}\n   */\n  cancelIdleCallback: function cancelIdleCallback(handle) {\n    var promise = this._hPM.get(handle);\n    this.cancelIdlePromise(promise);\n  },\n  /**\n   * clears and resets everything\n   * @return {void}\n   */\n  clear: function clear() {\n    var _this3 = this;\n    // remove all non-cleared\n    this._iC.forEach(function (promise) {\n      return _removeIdlePromise(_this3, promise);\n    });\n    this._qC = 0;\n    this._iC.clear();\n    this._hPM = new Map();\n    this._pHM = new Map();\n  }\n};\n\n/**\n * processes the oldest call of the idleCalls-queue\n * @return {Promise<void>}\n */\nfunction _resolveOneIdleCall(idleQueue) {\n  if (idleQueue._iC.size === 0) return;\n  var iterator = idleQueue._iC.values();\n  var oldestPromise = iterator.next().value;\n  oldestPromise._manRes();\n\n  // try to call the next tick\n  setTimeout(function () {\n    return _tryIdleCall(idleQueue);\n  }, 0);\n}\n\n/**\n * removes the promise from the queue and maps and also its corresponding handle-number\n * @param  {Promise} promise from requestIdlePromise()\n * @return {void}\n */\nfunction _removeIdlePromise(idleQueue, promise) {\n  if (!promise) return;\n\n  // remove timeout if exists\n  if (promise._timeoutObj) clearTimeout(promise._timeoutObj);\n\n  // remove handle-nr if exists\n  if (idleQueue._pHM.has(promise)) {\n    var handle = idleQueue._pHM.get(promise);\n    idleQueue._hPM[\"delete\"](handle);\n    idleQueue._pHM[\"delete\"](promise);\n  }\n\n  // remove from queue\n  idleQueue._iC[\"delete\"](promise);\n}\n\n/**\n * resolves the last entry of this._iC\n * but only if the queue is empty\n * @return {Promise}\n */\nfunction _tryIdleCall(idleQueue) {\n  // console.log('_tryIdleCall:');\n  // console.dir({\n  //     try: idleQueue._tryIR,\n  //     size: idleQueue._iC.size\n  // });\n  // ensure this does not run in parallel\n  if (idleQueue._tryIR || idleQueue._iC.size === 0) return;\n  idleQueue._tryIR = true;\n\n  // w8 one tick\n  setTimeout(function () {\n    // check if queue empty\n    if (!idleQueue.isIdle()) {\n      idleQueue._tryIR = false;\n      return;\n    }\n\n    /**\n     * wait 1 tick here\n     * because many functions do IO->CPU->IO\n     * which means the queue is empty for a short time\n     * but the ressource is not idle\n     */\n    setTimeout(function () {\n      // check if queue still empty\n      if (!idleQueue.isIdle()) {\n        idleQueue._tryIR = false;\n        return;\n      }\n\n      // ressource is idle\n      _resolveOneIdleCall(idleQueue);\n      idleQueue._tryIR = false;\n    }, 0);\n  }, 0);\n}", "import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { IdleQueue } from 'custom-idle-queue';\nimport { ObliviousSet } from 'oblivious-set';\nimport { pluginMissing, flatClone, PROMISE_RESOLVE_FALSE, randomToken, ensureNotFalsy, getDefaultRevision, getDefaultRxDocumentMeta, defaultHashSha256, RXDB_VERSION } from \"./plugins/utils/index.js\";\nimport { newRxError } from \"./rx-error.js\";\nimport { createRxSchema } from \"./rx-schema.js\";\nimport { runPluginHooks, runAsyncPluginHooks } from \"./hooks.js\";\nimport { Subject } from 'rxjs';\nimport { mergeMap } from 'rxjs/operators';\nimport { createRxCollection } from \"./rx-collection.js\";\nimport { flatCloneDocWithMeta, getSingleDocument, getWrappedStorageInstance, INTERNAL_STORAGE_NAME } from \"./rx-storage-helper.js\";\nimport { ensureStorageTokenDocumentExists, getAllCollectionDocuments, getPrimaryKeyOfInternalDocument, INTERNAL_CONTEXT_COLLECTION, INTERNAL_STORE_SCHEMA, _collectionNamePrimary } from \"./rx-database-internal-store.js\";\nimport { removeCollectionStorages } from \"./rx-collection-helper.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { rxChangeEventBulkToRxChangeEvents } from \"./rx-change-event.js\";\n\n/**\n * stores the used database names+storage names\n * so we can throw when the same database is created more then once.\n */\nvar USED_DATABASE_NAMES = new Set();\nvar DATABASE_UNCLOSED_INSTANCE_PROMISE_MAP = new Map();\nvar DB_COUNT = 0;\nexport var RxDatabaseBase = /*#__PURE__*/function () {\n  /**\n   * Contains all known non-closed storage instances\n   * that belong to this database.\n   * Used in plugins and unit tests.\n   */\n\n  function RxDatabaseBase(name,\n  /**\n   * Uniquely identifies the instance\n   * of this RxDatabase.\n   */\n  token, storage, instanceCreationOptions, password, multiInstance, eventReduce = false, options = {},\n  /**\n   * Stores information documents about the collections of the database\n   */\n  internalStore, hashFunction, cleanupPolicy, allowSlowCount, reactivity, onClosed) {\n    this.idleQueue = new IdleQueue();\n    this.rxdbVersion = RXDB_VERSION;\n    this.storageInstances = new Set();\n    this._subs = [];\n    this.startupErrors = [];\n    this.onClose = [];\n    this.closed = false;\n    this.collections = {};\n    this.states = {};\n    this.eventBulks$ = new Subject();\n    this.closePromise = null;\n    this.observable$ = this.eventBulks$.pipe(mergeMap(changeEventBulk => rxChangeEventBulkToRxChangeEvents(changeEventBulk)));\n    this.storageToken = PROMISE_RESOLVE_FALSE;\n    this.storageTokenDocument = PROMISE_RESOLVE_FALSE;\n    this.emittedEventBulkIds = new ObliviousSet(60 * 1000);\n    this.name = name;\n    this.token = token;\n    this.storage = storage;\n    this.instanceCreationOptions = instanceCreationOptions;\n    this.password = password;\n    this.multiInstance = multiInstance;\n    this.eventReduce = eventReduce;\n    this.options = options;\n    this.internalStore = internalStore;\n    this.hashFunction = hashFunction;\n    this.cleanupPolicy = cleanupPolicy;\n    this.allowSlowCount = allowSlowCount;\n    this.reactivity = reactivity;\n    this.onClosed = onClosed;\n    DB_COUNT++;\n\n    /**\n     * In the dev-mode, we create a pseudoInstance\n     * to get all properties of RxDatabase and ensure they do not\n     * conflict with the collection names etc.\n     * So only if it is not pseudoInstance,\n     * we have all values to prepare a real RxDatabase.\n     *\n     * TODO this is ugly, we should use a different way in the dev-mode\n     * so that all non-dev-mode code can be cleaner.\n     */\n    if (this.name !== 'pseudoInstance') {\n      /**\n       * Wrap the internal store\n       * to ensure that calls to it also end up in\n       * calculation of the idle state and the hooks.\n       */\n      this.internalStore = getWrappedStorageInstance(this.asRxDatabase, internalStore, INTERNAL_STORE_SCHEMA);\n\n      /**\n       * Start writing the storage token.\n       * Do not await the creation because it would run\n       * in a critical path that increases startup time.\n       *\n       * Writing the token takes about 20 milliseconds\n       * even on a fast adapter, so this is worth it.\n       */\n      this.storageTokenDocument = ensureStorageTokenDocumentExists(this.asRxDatabase).catch(err => this.startupErrors.push(err));\n      this.storageToken = this.storageTokenDocument.then(doc => doc.data.token).catch(err => this.startupErrors.push(err));\n    }\n  }\n  var _proto = RxDatabaseBase.prototype;\n  _proto.getReactivityFactory = function getReactivityFactory() {\n    if (!this.reactivity) {\n      throw newRxError('DB14', {\n        database: this.name\n      });\n    }\n    return this.reactivity;\n  }\n\n  /**\n   * Because having unhandled exceptions would fail,\n   * we have to store the async errors of the constructor here\n   * so we can throw them later.\n   */\n\n  /**\n   * When the database is closed,\n   * these functions will be called an awaited.\n   * Used to automatically clean up stuff that\n   * belongs to this collection.\n   */\n\n  /**\n   * Internally only use eventBulks$\n   * Do not use .$ or .observable$ because that has to transform\n   * the events which decreases performance.\n   */\n\n  /**\n   * Unique token that is stored with the data.\n   * Used to detect if the dataset has been deleted\n   * and if two RxDatabase instances work on the same dataset or not.\n   *\n   * Because reading and writing the storageToken runs in the hot path\n   * of database creation, we do not await the storageWrites but instead\n   * work with the promise when we need the value.\n   */\n\n  /**\n   * Stores the whole state of the internal storage token document.\n   * We need this in some plugins.\n   */\n\n  /**\n   * Contains the ids of all event bulks that have been emitted\n   * by the database.\n   * Used to detect duplicates that come in again via BroadcastChannel\n   * or other streams.\n   * In the past we tried to remove this and to ensure\n   * all storages only emit the same event bulks only once\n   * but it turns out this is just not possible for all storages.\n   * JavaScript processes, workers and browser tabs can be closed and started at any time\n   * which can cause cases where it is not possible to know if an event bulk has been emitted already.\n   */;\n  /**\n   * This is the main handle-point for all change events\n   * ChangeEvents created by this instance go:\n   * RxDocument -> RxCollection -> RxDatabase.$emit -> MultiInstance\n   * ChangeEvents created by other instances go:\n   * MultiInstance -> RxDatabase.$emit -> RxCollection -> RxDatabase\n   */\n  _proto.$emit = function $emit(changeEventBulk) {\n    if (this.emittedEventBulkIds.has(changeEventBulk.id)) {\n      return;\n    }\n    this.emittedEventBulkIds.add(changeEventBulk.id);\n    this.eventBulks$.next(changeEventBulk);\n  }\n\n  /**\n   * removes the collection-doc from the internalStore\n   */;\n  _proto.removeCollectionDoc = async function removeCollectionDoc(name, schema) {\n    var doc = await getSingleDocument(this.internalStore, getPrimaryKeyOfInternalDocument(_collectionNamePrimary(name, schema), INTERNAL_CONTEXT_COLLECTION));\n    if (!doc) {\n      throw newRxError('SNH', {\n        name,\n        schema\n      });\n    }\n    var writeDoc = flatCloneDocWithMeta(doc);\n    writeDoc._deleted = true;\n    await this.internalStore.bulkWrite([{\n      document: writeDoc,\n      previous: doc\n    }], 'rx-database-remove-collection');\n  }\n\n  /**\n   * creates multiple RxCollections at once\n   * to be much faster by saving db txs and doing stuff in bulk-operations\n   * This function is not called often, but mostly in the critical path at the initial page load\n   * So it must be as fast as possible.\n   */;\n  _proto.addCollections = async function addCollections(collectionCreators) {\n    var jsonSchemas = {};\n    var schemas = {};\n    var bulkPutDocs = [];\n    var useArgsByCollectionName = {};\n    await Promise.all(Object.entries(collectionCreators).map(async ([name, args]) => {\n      var collectionName = name;\n      var rxJsonSchema = args.schema;\n      jsonSchemas[collectionName] = rxJsonSchema;\n      var schema = createRxSchema(rxJsonSchema, this.hashFunction);\n      schemas[collectionName] = schema;\n\n      // collection already exists\n      if (this.collections[name]) {\n        throw newRxError('DB3', {\n          name\n        });\n      }\n      var collectionNameWithVersion = _collectionNamePrimary(name, rxJsonSchema);\n      var collectionDocData = {\n        id: getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION),\n        key: collectionNameWithVersion,\n        context: INTERNAL_CONTEXT_COLLECTION,\n        data: {\n          name: collectionName,\n          schemaHash: await schema.hash,\n          schema: schema.jsonSchema,\n          version: schema.version,\n          connectedStorages: []\n        },\n        _deleted: false,\n        _meta: getDefaultRxDocumentMeta(),\n        _rev: getDefaultRevision(),\n        _attachments: {}\n      };\n      bulkPutDocs.push({\n        document: collectionDocData\n      });\n      var useArgs = Object.assign({}, args, {\n        name: collectionName,\n        schema,\n        database: this\n      });\n\n      // run hooks\n      var hookData = flatClone(args);\n      hookData.database = this;\n      hookData.name = name;\n      runPluginHooks('preCreateRxCollection', hookData);\n      useArgs.conflictHandler = hookData.conflictHandler;\n      useArgsByCollectionName[collectionName] = useArgs;\n    }));\n    var putDocsResult = await this.internalStore.bulkWrite(bulkPutDocs, 'rx-database-add-collection');\n    await ensureNoStartupErrors(this);\n    await Promise.all(putDocsResult.error.map(async error => {\n      if (error.status !== 409) {\n        throw newRxError('DB12', {\n          database: this.name,\n          writeError: error\n        });\n      }\n      var docInDb = ensureNotFalsy(error.documentInDb);\n      var collectionName = docInDb.data.name;\n      var schema = schemas[collectionName];\n      // collection already exists but has different schema\n      if (docInDb.data.schemaHash !== (await schema.hash)) {\n        throw newRxError('DB6', {\n          database: this.name,\n          collection: collectionName,\n          previousSchemaHash: docInDb.data.schemaHash,\n          schemaHash: await schema.hash,\n          previousSchema: docInDb.data.schema,\n          schema: ensureNotFalsy(jsonSchemas[collectionName])\n        });\n      }\n    }));\n    var ret = {};\n    await Promise.all(Object.keys(collectionCreators).map(async collectionName => {\n      var useArgs = useArgsByCollectionName[collectionName];\n      var collection = await createRxCollection(useArgs);\n      ret[collectionName] = collection;\n\n      // set as getter to the database\n      this.collections[collectionName] = collection;\n      if (!this[collectionName]) {\n        Object.defineProperty(this, collectionName, {\n          get: () => this.collections[collectionName]\n        });\n      }\n    }));\n    return ret;\n  }\n\n  /**\n   * runs the given function between idleQueue-locking\n   */;\n  _proto.lockedRun = function lockedRun(fn) {\n    return this.idleQueue.wrapCall(fn);\n  };\n  _proto.requestIdlePromise = function requestIdlePromise() {\n    return this.idleQueue.requestIdlePromise();\n  }\n\n  /**\n   * Export database to a JSON friendly format.\n   */;\n  _proto.exportJSON = function exportJSON(_collections) {\n    throw pluginMissing('json-dump');\n  };\n  _proto.addState = function addState(_name) {\n    throw pluginMissing('state');\n  }\n\n  /**\n   * Import the parsed JSON export into the collection.\n   * @param _exportedJSON The previously exported data from the `<db>.exportJSON()` method.\n   * @note When an interface is loaded in this collection all base properties of the type are typed as `any`\n   * since data could be encrypted.\n   */;\n  _proto.importJSON = function importJSON(_exportedJSON) {\n    throw pluginMissing('json-dump');\n  };\n  _proto.backup = function backup(_options) {\n    throw pluginMissing('backup');\n  };\n  _proto.leaderElector = function leaderElector() {\n    throw pluginMissing('leader-election');\n  };\n  _proto.isLeader = function isLeader() {\n    throw pluginMissing('leader-election');\n  }\n  /**\n   * returns a promise which resolves when the instance becomes leader\n   */;\n  _proto.waitForLeadership = function waitForLeadership() {\n    throw pluginMissing('leader-election');\n  };\n  _proto.migrationStates = function migrationStates() {\n    throw pluginMissing('migration-schema');\n  }\n\n  /**\n   * closes the database-instance and all collections\n   */;\n  _proto.close = function close() {\n    if (this.closePromise) {\n      return this.closePromise;\n    }\n    var {\n      promise,\n      resolve\n    } = createPromiseWithResolvers();\n    var resolveClosePromise = result => {\n      if (this.onClosed) {\n        this.onClosed();\n      }\n      this.closed = true;\n      resolve(result);\n    };\n    this.closePromise = promise;\n    (async () => {\n      await runAsyncPluginHooks('preCloseRxDatabase', this);\n      /**\n       * Complete the event stream\n       * to stop all subscribers who forgot to unsubscribe.\n       */\n      this.eventBulks$.complete();\n      DB_COUNT--;\n      this._subs.map(sub => sub.unsubscribe());\n\n      /**\n       * closing the pseudo instance will throw\n       * because stuff is missing\n       * TODO we should not need the pseudo instance on runtime.\n       * we should generate the property list on build time.\n       */\n      if (this.name === 'pseudoInstance') {\n        resolveClosePromise(false);\n        return;\n      }\n\n      /**\n       * First wait until the database is idle\n       */\n      return this.requestIdlePromise().then(() => Promise.all(this.onClose.map(fn => fn())))\n      // close all collections\n      .then(() => Promise.all(Object.keys(this.collections).map(key => this.collections[key]).map(col => col.close())))\n      // close internal storage instances\n      .then(() => this.internalStore.close()).then(() => resolveClosePromise(true));\n    })();\n    return promise;\n  }\n\n  /**\n   * deletes the database and its stored data.\n   * Returns the names of all removed collections.\n   */;\n  _proto.remove = function remove() {\n    return this.close().then(() => removeRxDatabase(this.name, this.storage, this.multiInstance, this.password));\n  };\n  return _createClass(RxDatabaseBase, [{\n    key: \"$\",\n    get: function () {\n      return this.observable$;\n    }\n  }, {\n    key: \"asRxDatabase\",\n    get: function () {\n      return this;\n    }\n  }]);\n}();\n\n/**\n * checks if an instance with same name and storage already exists\n * @throws {RxError} if used\n */\nfunction throwIfDatabaseNameUsed(name, storage) {\n  if (USED_DATABASE_NAMES.has(getDatabaseNameKey(name, storage))) {\n    throw newRxError('DB8', {\n      name,\n      storage: storage.name,\n      link: 'https://rxdb.info/rx-database.html#ignoreduplicate'\n    });\n  }\n}\n\n/**\n * ponyfill for https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers\n */\nfunction createPromiseWithResolvers() {\n  var resolve;\n  var reject;\n  var promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return {\n    promise,\n    resolve,\n    reject\n  };\n}\nfunction getDatabaseNameKey(name, storage) {\n  return storage.name + '|' + name;\n}\n\n/**\n * Creates the storage instances that are used internally in the database\n * to store schemas and other configuration stuff.\n */\nexport async function createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, options, multiInstance, password) {\n  var internalStore = await storage.createStorageInstance({\n    databaseInstanceToken,\n    databaseName,\n    collectionName: INTERNAL_STORAGE_NAME,\n    schema: INTERNAL_STORE_SCHEMA,\n    options,\n    multiInstance,\n    password,\n    devMode: overwritable.isDevMode()\n  });\n  return internalStore;\n}\nexport function createRxDatabase({\n  storage,\n  instanceCreationOptions,\n  name,\n  password,\n  multiInstance = true,\n  eventReduce = true,\n  ignoreDuplicate = false,\n  options = {},\n  cleanupPolicy,\n  closeDuplicates = false,\n  allowSlowCount = false,\n  localDocuments = false,\n  hashFunction = defaultHashSha256,\n  reactivity\n}) {\n  runPluginHooks('preCreateRxDatabase', {\n    storage,\n    instanceCreationOptions,\n    name,\n    password,\n    multiInstance,\n    eventReduce,\n    ignoreDuplicate,\n    options,\n    localDocuments\n  });\n  var databaseNameKey = getDatabaseNameKey(name, storage);\n  var databaseNameKeyUnclosedInstancesSet = DATABASE_UNCLOSED_INSTANCE_PROMISE_MAP.get(databaseNameKey) || new Set();\n  var instancePromiseWithResolvers = createPromiseWithResolvers();\n  var closeDuplicatesPromises = Array.from(databaseNameKeyUnclosedInstancesSet);\n  var onInstanceClosed = () => {\n    databaseNameKeyUnclosedInstancesSet.delete(instancePromiseWithResolvers.promise);\n    USED_DATABASE_NAMES.delete(databaseNameKey);\n  };\n  databaseNameKeyUnclosedInstancesSet.add(instancePromiseWithResolvers.promise);\n  DATABASE_UNCLOSED_INSTANCE_PROMISE_MAP.set(databaseNameKey, databaseNameKeyUnclosedInstancesSet);\n  (async () => {\n    if (closeDuplicates) {\n      await Promise.all(closeDuplicatesPromises.map(unclosedInstancePromise => unclosedInstancePromise.catch(() => null).then(instance => instance && instance.close())));\n    }\n    if (ignoreDuplicate) {\n      if (!overwritable.isDevMode()) {\n        throw newRxError('DB9', {\n          database: name\n        });\n      }\n    } else {\n      // check if combination already used\n      throwIfDatabaseNameUsed(name, storage);\n    }\n    USED_DATABASE_NAMES.add(databaseNameKey);\n    var databaseInstanceToken = randomToken(10);\n    var storageInstance = await createRxDatabaseStorageInstance(databaseInstanceToken, storage, name, instanceCreationOptions, multiInstance, password);\n    var rxDatabase = new RxDatabaseBase(name, databaseInstanceToken, storage, instanceCreationOptions, password, multiInstance, eventReduce, options, storageInstance, hashFunction, cleanupPolicy, allowSlowCount, reactivity, onInstanceClosed);\n    await runAsyncPluginHooks('createRxDatabase', {\n      database: rxDatabase,\n      creator: {\n        storage,\n        instanceCreationOptions,\n        name,\n        password,\n        multiInstance,\n        eventReduce,\n        ignoreDuplicate,\n        options,\n        localDocuments\n      }\n    });\n    return rxDatabase;\n  })().then(rxDatabase => {\n    instancePromiseWithResolvers.resolve(rxDatabase);\n  }).catch(err => {\n    instancePromiseWithResolvers.reject(err);\n    onInstanceClosed();\n  });\n  return instancePromiseWithResolvers.promise;\n}\n\n/**\n * Removes the database and all its known data\n * with all known collections and all internal meta data.\n *\n * Returns the names of the removed collections.\n */\nexport async function removeRxDatabase(databaseName, storage, multiInstance = true, password) {\n  var databaseInstanceToken = randomToken(10);\n  var dbInternalsStorageInstance = await createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, {}, multiInstance, password);\n  var collectionDocs = await getAllCollectionDocuments(dbInternalsStorageInstance);\n  var collectionNames = new Set();\n  collectionDocs.forEach(doc => collectionNames.add(doc.data.name));\n  var removedCollectionNames = Array.from(collectionNames);\n  await Promise.all(removedCollectionNames.map(collectionName => removeCollectionStorages(storage, dbInternalsStorageInstance, databaseInstanceToken, databaseName, collectionName, multiInstance, password)));\n  await runAsyncPluginHooks('postRemoveRxDatabase', {\n    databaseName,\n    storage\n  });\n  await dbInternalsStorageInstance.remove();\n  return removedCollectionNames;\n}\nexport function isRxDatabase(obj) {\n  return obj instanceof RxDatabaseBase;\n}\nexport function dbCount() {\n  return DB_COUNT;\n}\n\n/**\n * Returns true if the given RxDatabase was the first\n * instance that was created on the storage with this name.\n *\n * Can be used for some optimizations because on the first instantiation,\n * we can assume that no data was written before.\n */\nexport async function isRxDatabaseFirstTimeInstantiated(database) {\n  var tokenDoc = await database.storageTokenDocument;\n  return tokenDoc.data.instanceToken === database.token;\n}\n\n/**\n * For better performance some tasks run async\n * and are awaited later.\n * But we still have to ensure that there have been no errors\n * on database creation.\n */\nexport async function ensureNoStartupErrors(rxDatabase) {\n  await rxDatabase.storageToken;\n  if (rxDatabase.startupErrors[0]) {\n    throw rxDatabase.startupErrors[0];\n  }\n}\n"],
  "mappings": "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",
  "names": ["RxSchema", "getDocumentPrototype", "IncrementalWriteQueue", "item", "lastChar", "QueryCache", "rxQuery", "DocumentCache", "RxQuerySingleResult", "map", "getProperty", "getProperty", "simpleBdd", "eventReduceEvent", "RxQueryBase", "docs", "doesMatchNow", "docId", "docData", "ChangeEventBuffer", "RxCollectionBase", "docData", "useDocData", "IdleQueue", "requestIdlePromise", "resolveFromOutside", "RxDatabaseBase", "requestIdlePromise"]
}
