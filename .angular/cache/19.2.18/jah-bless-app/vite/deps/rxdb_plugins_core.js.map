{
  "version": 3,
  "sources": ["../../../../../../node_modules/rxdb/dist/esm/custom-index.js"],
  "sourcesContent": ["/**\n * For some RxStorage implementations,\n * we need to use our custom crafted indexes\n * so we can easily iterate over them. And sort plain arrays of document data.\n *\n * We really often have to craft an index string for a given document.\n * Performance of everything in this file is very important\n * which is why the code sometimes looks strange.\n * Run performance tests before and after you touch anything here!\n */\n\nimport { getSchemaByObjectPath } from \"./rx-schema-helper.js\";\nimport { ensureNotFalsy, objectPathMonad } from \"./plugins/utils/index.js\";\nimport { INDEX_MAX, INDEX_MIN } from \"./query-planner.js\";\n\n/**\n * Prepare all relevant information\n * outside of the returned function\n * from getIndexableStringMonad()\n * to save performance when the returned\n * function is called many times.\n */\n\nexport function getIndexMeta(schema, index) {\n  var fieldNameProperties = index.map(fieldName => {\n    var schemaPart = getSchemaByObjectPath(schema, fieldName);\n    if (!schemaPart) {\n      throw new Error('not in schema: ' + fieldName);\n    }\n    var type = schemaPart.type;\n    var parsedLengths;\n    if (type === 'number' || type === 'integer') {\n      parsedLengths = getStringLengthOfIndexNumber(schemaPart);\n    }\n    var getValue = objectPathMonad(fieldName);\n    var maxLength = schemaPart.maxLength ? schemaPart.maxLength : 0;\n    var getIndexStringPart;\n    if (type === 'string') {\n      getIndexStringPart = docData => {\n        var fieldValue = getValue(docData);\n        if (!fieldValue) {\n          fieldValue = '';\n        }\n        return fieldValue.padEnd(maxLength, ' ');\n      };\n    } else if (type === 'boolean') {\n      getIndexStringPart = docData => {\n        var fieldValue = getValue(docData);\n        return fieldValue ? '1' : '0';\n      };\n    } else {\n      // number\n      getIndexStringPart = docData => {\n        var fieldValue = getValue(docData);\n        return getNumberIndexString(parsedLengths, fieldValue);\n      };\n    }\n    var ret = {\n      fieldName,\n      schemaPart,\n      parsedLengths,\n      getValue,\n      getIndexStringPart\n    };\n    return ret;\n  });\n  return fieldNameProperties;\n}\n\n/**\n * Crafts an indexable string that can be used\n * to check if a document would be sorted below or above\n * another documents, dependent on the index values.\n * @monad for better performance\n *\n * IMPORTANT: Performance is really important here\n * which is why we code so 'strange'.\n * Always run performance tests when you want to\n * change something in this method.\n */\nexport function getIndexableStringMonad(schema, index) {\n  var fieldNameProperties = getIndexMeta(schema, index);\n  var fieldNamePropertiesAmount = fieldNameProperties.length;\n  var indexPartsFunctions = fieldNameProperties.map(r => r.getIndexStringPart);\n\n  /**\n   * @hotPath Performance of this function is very critical!\n   */\n  var ret = function (docData) {\n    var str = '';\n    for (var i = 0; i < fieldNamePropertiesAmount; ++i) {\n      str += indexPartsFunctions[i](docData);\n    }\n    return str;\n  };\n  return ret;\n}\nexport function getStringLengthOfIndexNumber(schemaPart) {\n  var minimum = Math.floor(schemaPart.minimum);\n  var maximum = Math.ceil(schemaPart.maximum);\n  var multipleOf = schemaPart.multipleOf;\n  var valueSpan = maximum - minimum;\n  var nonDecimals = valueSpan.toString().length;\n  var multipleOfParts = multipleOf.toString().split('.');\n  var decimals = 0;\n  if (multipleOfParts.length > 1) {\n    decimals = multipleOfParts[1].length;\n  }\n  return {\n    minimum,\n    maximum,\n    nonDecimals,\n    decimals,\n    roundedMinimum: minimum\n  };\n}\nexport function getIndexStringLength(schema, index) {\n  var fieldNameProperties = getIndexMeta(schema, index);\n  var length = 0;\n  fieldNameProperties.forEach(props => {\n    var schemaPart = props.schemaPart;\n    var type = schemaPart.type;\n    if (type === 'string') {\n      length += schemaPart.maxLength;\n    } else if (type === 'boolean') {\n      length += 1;\n    } else {\n      var parsedLengths = props.parsedLengths;\n      length = length + parsedLengths.nonDecimals + parsedLengths.decimals;\n    }\n  });\n  return length;\n}\nexport function getPrimaryKeyFromIndexableString(indexableString, primaryKeyLength) {\n  var paddedPrimaryKey = indexableString.slice(primaryKeyLength * -1);\n  // we can safely trim here because the primary key is not allowed to start or end with a space char.\n  var primaryKey = paddedPrimaryKey.trim();\n  return primaryKey;\n}\nexport function getNumberIndexString(parsedLengths, fieldValue) {\n  /**\n   * Ensure that the given value is in the boundaries\n   * of the schema, otherwise it would create a broken index string.\n   * This can happen for example if you have a minimum of 0\n   * and run a query like\n   * selector {\n   *  numField: { $gt: -1000 }\n   * }\n   */\n  if (typeof fieldValue === 'undefined') {\n    fieldValue = 0;\n  }\n  if (fieldValue < parsedLengths.minimum) {\n    fieldValue = parsedLengths.minimum;\n  }\n  if (fieldValue > parsedLengths.maximum) {\n    fieldValue = parsedLengths.maximum;\n  }\n  var nonDecimalsValueAsString = (Math.floor(fieldValue) - parsedLengths.roundedMinimum).toString();\n  var str = nonDecimalsValueAsString.padStart(parsedLengths.nonDecimals, '0');\n  if (parsedLengths.decimals > 0) {\n    var splitByDecimalPoint = fieldValue.toString().split('.');\n    var decimalValueAsString = splitByDecimalPoint.length > 1 ? splitByDecimalPoint[1] : '0';\n    str += decimalValueAsString.padEnd(parsedLengths.decimals, '0');\n  }\n  return str;\n}\nexport function getStartIndexStringFromLowerBound(schema, index, lowerBound) {\n  var str = '';\n  index.forEach((fieldName, idx) => {\n    var schemaPart = getSchemaByObjectPath(schema, fieldName);\n    var bound = lowerBound[idx];\n    var type = schemaPart.type;\n    switch (type) {\n      case 'string':\n        var maxLength = ensureNotFalsy(schemaPart.maxLength, 'maxLength not set');\n        if (typeof bound === 'string') {\n          str += bound.padEnd(maxLength, ' ');\n        } else {\n          // str += ''.padStart(maxLength, inclusiveStart ? ' ' : INDEX_MAX);\n          str += ''.padEnd(maxLength, ' ');\n        }\n        break;\n      case 'boolean':\n        if (bound === null) {\n          str += '0';\n        } else if (bound === INDEX_MIN) {\n          str += '0';\n        } else if (bound === INDEX_MAX) {\n          str += '1';\n        } else {\n          var boolToStr = bound ? '1' : '0';\n          str += boolToStr;\n        }\n        break;\n      case 'number':\n      case 'integer':\n        var parsedLengths = getStringLengthOfIndexNumber(schemaPart);\n        if (bound === null || bound === INDEX_MIN) {\n          var fillChar = '0';\n          str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n        } else if (bound === INDEX_MAX) {\n          str += getNumberIndexString(parsedLengths, parsedLengths.maximum);\n        } else {\n          var add = getNumberIndexString(parsedLengths, bound);\n          str += add;\n        }\n        break;\n      default:\n        throw new Error('unknown index type ' + type);\n    }\n  });\n  return str;\n}\nexport function getStartIndexStringFromUpperBound(schema, index, upperBound) {\n  var str = '';\n  index.forEach((fieldName, idx) => {\n    var schemaPart = getSchemaByObjectPath(schema, fieldName);\n    var bound = upperBound[idx];\n    var type = schemaPart.type;\n    switch (type) {\n      case 'string':\n        var maxLength = ensureNotFalsy(schemaPart.maxLength, 'maxLength not set');\n        if (typeof bound === 'string' && bound !== INDEX_MAX) {\n          str += bound.padEnd(maxLength, ' ');\n        } else if (bound === INDEX_MIN) {\n          str += ''.padEnd(maxLength, ' ');\n        } else {\n          str += ''.padEnd(maxLength, INDEX_MAX);\n        }\n        break;\n      case 'boolean':\n        if (bound === null) {\n          str += '1';\n        } else {\n          var boolToStr = bound ? '1' : '0';\n          str += boolToStr;\n        }\n        break;\n      case 'number':\n      case 'integer':\n        var parsedLengths = getStringLengthOfIndexNumber(schemaPart);\n        if (bound === null || bound === INDEX_MAX) {\n          var fillChar = '9';\n          str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n        } else if (bound === INDEX_MIN) {\n          var _fillChar = '0';\n          str += _fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n        } else {\n          str += getNumberIndexString(parsedLengths, bound);\n        }\n        break;\n      default:\n        throw new Error('unknown index type ' + type);\n    }\n  });\n  return str;\n}\n\n/**\n * Used in storages where it is not possible\n * to define inclusiveEnd/inclusiveStart\n */\nexport function changeIndexableStringByOneQuantum(str, direction) {\n  var lastChar = str.slice(-1);\n  var charCode = lastChar.charCodeAt(0);\n  charCode = charCode + direction;\n  var withoutLastChar = str.slice(0, -1);\n  return withoutLastChar + String.fromCharCode(charCode);\n}\n"],
  "mappings": "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",
  "names": []
}
