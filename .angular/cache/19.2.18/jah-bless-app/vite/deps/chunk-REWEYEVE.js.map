{
  "version": 3,
  "sources": ["../../../../../../node_modules/rxdb/dist/esm/plugin.js", "../../../../../../node_modules/rxdb/dist/esm/replication-protocol/checkpoint.js", "../../../../../../node_modules/rxdb/dist/esm/replication-protocol/helper.js", "../../../../../../node_modules/rxdb/dist/esm/replication-protocol/meta-instance.js", "../../../../../../node_modules/rxdb/dist/esm/replication-protocol/downstream.js", "../../../../../../node_modules/rxdb/dist/esm/replication-protocol/conflicts.js", "../../../../../../node_modules/rxdb/dist/esm/plugins/attachments/attachments-utils.js", "../../../../../../node_modules/rxdb/dist/esm/plugins/attachments/index.js", "../../../../../../node_modules/rxdb/dist/esm/replication-protocol/upstream.js", "../../../../../../node_modules/rxdb/dist/esm/replication-protocol/index.js"],
  "sourcesContent": ["/**\n * this handles how plugins are added to rxdb\n * basically it changes the internal prototypes\n * by passing them to the plugins-functions\n */\nimport { RxSchema } from \"./rx-schema.js\";\nimport { basePrototype as RxDocumentPrototype } from \"./rx-document.js\";\nimport { RxQueryBase } from \"./rx-query.js\";\nimport { RxCollectionBase } from \"./rx-collection.js\";\nimport { RxDatabaseBase } from \"./rx-database.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { HOOKS, runPluginHooks } from \"./hooks.js\";\nimport { newRxError, newRxTypeError } from \"./rx-error.js\";\n\n/**\n * prototypes that can be manipulated with a plugin\n */\nvar PROTOTYPES = {\n  RxSchema: RxSchema.prototype,\n  RxDocument: RxDocumentPrototype,\n  RxQuery: RxQueryBase.prototype,\n  RxCollection: RxCollectionBase.prototype,\n  RxDatabase: RxDatabaseBase.prototype\n};\nvar ADDED_PLUGINS = new Set();\nvar ADDED_PLUGIN_NAMES = new Set();\n\n/**\n * Add a plugin to the RxDB library.\n * Plugins are added globally and cannot be removed.\n */\nexport function addRxPlugin(plugin) {\n  runPluginHooks('preAddRxPlugin', {\n    plugin,\n    plugins: ADDED_PLUGINS\n  });\n\n  // do nothing if added before\n  if (ADDED_PLUGINS.has(plugin)) {\n    return;\n  } else {\n    // ensure no other plugin with the same name was already added\n    if (ADDED_PLUGIN_NAMES.has(plugin.name)) {\n      throw newRxError('PL3', {\n        name: plugin.name,\n        plugin\n      });\n    }\n    ADDED_PLUGINS.add(plugin);\n    ADDED_PLUGIN_NAMES.add(plugin.name);\n  }\n\n  /**\n   * To identify broken configurations,\n   * we only allow RxDB plugins to be passed into addRxPlugin().\n   */\n  if (!plugin.rxdb) {\n    throw newRxTypeError('PL1', {\n      plugin\n    });\n  }\n  if (plugin.init) {\n    plugin.init();\n  }\n\n  // prototype-overwrites\n  if (plugin.prototypes) {\n    Object.entries(plugin.prototypes).forEach(([name, fun]) => {\n      return fun(PROTOTYPES[name]);\n    });\n  }\n  // overwritable-overwrites\n  if (plugin.overwritable) {\n    Object.assign(overwritable, plugin.overwritable);\n  }\n  // extend-hooks\n  if (plugin.hooks) {\n    Object.entries(plugin.hooks).forEach(([name, hooksObj]) => {\n      if (hooksObj.after) {\n        HOOKS[name].push(hooksObj.after);\n      }\n      if (hooksObj.before) {\n        HOOKS[name].unshift(hooksObj.before);\n      }\n    });\n  }\n}\n", "import { getComposedPrimaryKeyOfDocumentData } from \"../rx-schema-helper.js\";\nimport { getWrittenDocumentsFromBulkWriteResponse, stackCheckpoints } from \"../rx-storage-helper.js\";\nimport { createRevision, ensureNotFalsy, getDefaultRevision, getDefaultRxDocumentMeta, now } from \"../plugins/utils/index.js\";\nexport async function getLastCheckpointDoc(state, direction) {\n  var checkpointDocId = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, {\n    isCheckpoint: '1',\n    itemId: direction\n  });\n  var checkpointResult = await state.input.metaInstance.findDocumentsById([checkpointDocId], false);\n  var checkpointDoc = checkpointResult[0];\n  state.lastCheckpointDoc[direction] = checkpointDoc;\n  if (checkpointDoc) {\n    return checkpointDoc.checkpointData;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Sets the checkpoint,\n * automatically resolves conflicts that appear.\n */\nexport async function setCheckpoint(state, direction, checkpoint) {\n  state.checkpointQueue = state.checkpointQueue.then(async () => {\n    var previousCheckpointDoc = state.lastCheckpointDoc[direction];\n    if (checkpoint &&\n    /**\n     * If the replication is already canceled,\n     * we do not write a checkpoint\n     * because that could mean we write a checkpoint\n     * for data that has been fetched from the master\n     * but not been written to the child.\n     */\n    !state.events.canceled.getValue() && (\n    /**\n     * Only write checkpoint if it is different from before\n     * to have less writes to the storage.\n     */\n\n    !previousCheckpointDoc || JSON.stringify(previousCheckpointDoc.checkpointData) !== JSON.stringify(checkpoint))) {\n      var newDoc = {\n        id: '',\n        isCheckpoint: '1',\n        itemId: direction,\n        _deleted: false,\n        _attachments: {},\n        checkpointData: checkpoint,\n        _meta: getDefaultRxDocumentMeta(),\n        _rev: getDefaultRevision()\n      };\n      newDoc.id = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, newDoc);\n      while (!state.events.canceled.getValue()) {\n        /**\n         * Instead of just storing the new checkpoint,\n         * we have to stack up the checkpoint with the previous one.\n         * This is required for plugins like the sharding RxStorage\n         * where the changeStream events only contain a Partial of the\n         * checkpoint.\n         */\n        if (previousCheckpointDoc) {\n          newDoc.checkpointData = stackCheckpoints([previousCheckpointDoc.checkpointData, newDoc.checkpointData]);\n        }\n        newDoc._meta.lwt = now();\n        newDoc._rev = createRevision(await state.checkpointKey, previousCheckpointDoc);\n        if (state.events.canceled.getValue()) {\n          return;\n        }\n        var writeRows = [{\n          previous: previousCheckpointDoc,\n          document: newDoc\n        }];\n        var result = await state.input.metaInstance.bulkWrite(writeRows, 'replication-set-checkpoint');\n        var successDoc = getWrittenDocumentsFromBulkWriteResponse(state.primaryPath, writeRows, result)[0];\n        if (successDoc) {\n          state.lastCheckpointDoc[direction] = successDoc;\n          return;\n        } else {\n          var error = result.error[0];\n          if (error.status !== 409) {\n            throw error;\n          } else {\n            previousCheckpointDoc = ensureNotFalsy(error.documentInDb);\n            newDoc._rev = createRevision(await state.checkpointKey, previousCheckpointDoc);\n          }\n        }\n      }\n    }\n  });\n  await state.checkpointQueue;\n}\nexport async function getCheckpointKey(input) {\n  var hash = await input.hashFunction([input.identifier, input.forkInstance.databaseName, input.forkInstance.collectionName].join('||'));\n  return 'rx_storage_replication_' + hash;\n}\n", "import { clone, createRevision, flatClone, getDefaultRevision, now } from \"../plugins/utils/index.js\";\nimport { stripAttachmentsDataFromDocument } from \"../rx-storage-helper.js\";\nexport function docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, docState, previous) {\n  var docData = Object.assign({}, docState, {\n    _attachments: hasAttachments && docState._attachments ? docState._attachments : {},\n    _meta: keepMeta ? docState._meta : Object.assign({}, previous ? previous._meta : {}, {\n      lwt: now()\n    }),\n    _rev: keepMeta ? docState._rev : getDefaultRevision()\n  });\n  if (!docData._rev) {\n    docData._rev = createRevision(databaseInstanceToken, previous);\n  }\n  return docData;\n}\nexport function writeDocToDocState(writeDoc, keepAttachments, keepMeta) {\n  var ret = flatClone(writeDoc);\n  if (!keepAttachments) {\n    delete ret._attachments;\n  }\n  if (!keepMeta) {\n    delete ret._meta;\n    delete ret._rev;\n  }\n  return ret;\n}\nexport function stripAttachmentsDataFromMetaWriteRows(state, rows) {\n  if (!state.hasAttachments) {\n    return rows;\n  }\n  return rows.map(row => {\n    var document = clone(row.document);\n    document.docData = stripAttachmentsDataFromDocument(document.docData);\n    return {\n      document,\n      previous: row.previous\n    };\n  });\n}\nexport function getUnderlyingPersistentStorage(instance) {\n  while (true) {\n    if (instance.underlyingPersistentStorage) {\n      instance = instance.underlyingPersistentStorage;\n    } else {\n      return instance;\n    }\n  }\n}\n", "import { fillWithDefaultSettings, getComposedPrimaryKeyOfDocumentData, getLengthOfPrimaryKey } from \"../rx-schema-helper.js\";\nimport { flatCloneDocWithMeta } from \"../rx-storage-helper.js\";\nimport { getDefaultRevision, createRevision, now } from \"../plugins/utils/index.js\";\nexport var META_INSTANCE_SCHEMA_TITLE = 'RxReplicationProtocolMetaData';\nexport function getRxReplicationMetaInstanceSchema(replicatedDocumentsSchema, encrypted) {\n  var parentPrimaryKeyLength = getLengthOfPrimaryKey(replicatedDocumentsSchema);\n  var baseSchema = {\n    title: META_INSTANCE_SCHEMA_TITLE,\n    primaryKey: {\n      key: 'id',\n      fields: ['itemId', 'isCheckpoint'],\n      separator: '|'\n    },\n    type: 'object',\n    version: replicatedDocumentsSchema.version,\n    additionalProperties: false,\n    properties: {\n      id: {\n        type: 'string',\n        minLength: 1,\n        // add +1 for the '|' and +1 for the 'isCheckpoint' flag\n        maxLength: parentPrimaryKeyLength + 2\n      },\n      isCheckpoint: {\n        type: 'string',\n        enum: ['0', '1'],\n        minLength: 1,\n        maxLength: 1\n      },\n      itemId: {\n        type: 'string',\n        /**\n         * ensure that all values of RxStorageReplicationDirection ('DOWN' has 4 chars) fit into it\n         * because checkpoints use the itemId field for that.\n         */\n        maxLength: parentPrimaryKeyLength > 4 ? parentPrimaryKeyLength : 4\n      },\n      checkpointData: {\n        type: 'object',\n        additionalProperties: true\n      },\n      docData: {\n        type: 'object',\n        properties: replicatedDocumentsSchema.properties\n      },\n      isResolvedConflict: {\n        type: 'string'\n      }\n    },\n    keyCompression: replicatedDocumentsSchema.keyCompression,\n    required: ['id', 'isCheckpoint', 'itemId']\n  };\n  if (encrypted) {\n    baseSchema.encrypted = ['docData'];\n  }\n  var metaInstanceSchema = fillWithDefaultSettings(baseSchema);\n  return metaInstanceSchema;\n}\n\n/**\n * Returns the document states of what the fork instance\n * assumes to be the latest state on the master instance.\n */\nexport function getAssumedMasterState(state, docIds) {\n  return state.input.metaInstance.findDocumentsById(docIds.map(docId => {\n    var useId = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, {\n      itemId: docId,\n      isCheckpoint: '0'\n    });\n    return useId;\n  }), true).then(metaDocs => {\n    var ret = {};\n    Object.values(metaDocs).forEach(metaDoc => {\n      ret[metaDoc.itemId] = {\n        docData: metaDoc.docData,\n        metaDocument: metaDoc\n      };\n    });\n    return ret;\n  });\n}\nexport async function getMetaWriteRow(state, newMasterDocState, previous, isResolvedConflict) {\n  var docId = newMasterDocState[state.primaryPath];\n  var newMeta = previous ? flatCloneDocWithMeta(previous) : {\n    id: '',\n    isCheckpoint: '0',\n    itemId: docId,\n    docData: newMasterDocState,\n    _attachments: {},\n    _deleted: false,\n    _rev: getDefaultRevision(),\n    _meta: {\n      lwt: 0\n    }\n  };\n  newMeta.docData = newMasterDocState;\n\n  /**\n   * Sending isResolvedConflict with the value undefined\n   * will throw a schema validation error because it must be either\n   * not set or have a string.\n   */\n  if (isResolvedConflict) {\n    newMeta.isResolvedConflict = isResolvedConflict;\n  }\n  newMeta._meta.lwt = now();\n  newMeta.id = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, newMeta);\n  newMeta._rev = createRevision(await state.checkpointKey, previous);\n  var ret = {\n    previous,\n    document: newMeta\n  };\n  return ret;\n}\n", "import { firstValueFrom, filter, mergeMap } from 'rxjs';\nimport { newRxError } from \"../rx-error.js\";\nimport { getWrittenDocumentsFromBulkWriteResponse, stackCheckpoints } from \"../rx-storage-helper.js\";\nimport { appendToArray, createRevision, ensureNotFalsy, flatClone, getDefaultRevision, getHeightOfRevision, now, PROMISE_RESOLVE_VOID } from \"../plugins/utils/index.js\";\nimport { getLastCheckpointDoc, setCheckpoint } from \"./checkpoint.js\";\nimport { stripAttachmentsDataFromMetaWriteRows, writeDocToDocState } from \"./helper.js\";\nimport { getAssumedMasterState, getMetaWriteRow } from \"./meta-instance.js\";\n\n/**\n * Writes all documents from the master to the fork.\n * The downstream has two operation modes\n * - Sync by iterating over the checkpoints via downstreamResyncOnce()\n * - Sync by listening to the changestream via downstreamProcessChanges()\n * We need this to be able to do initial syncs\n * and still can have fast event based sync when the client is not offline.\n */\nexport async function startReplicationDownstream(state) {\n  if (state.input.initialCheckpoint && state.input.initialCheckpoint.downstream) {\n    var checkpointDoc = await getLastCheckpointDoc(state, 'down');\n    if (!checkpointDoc) {\n      await setCheckpoint(state, 'down', state.input.initialCheckpoint.downstream);\n    }\n  }\n  var identifierHash = await state.input.hashFunction(state.input.identifier);\n  var replicationHandler = state.input.replicationHandler;\n\n  // used to detect which tasks etc can in it at which order.\n  var timer = 0;\n  var openTasks = [];\n  function addNewTask(task) {\n    state.stats.down.addNewTask = state.stats.down.addNewTask + 1;\n    var taskWithTime = {\n      time: timer++,\n      task\n    };\n    openTasks.push(taskWithTime);\n    state.streamQueue.down = state.streamQueue.down.then(() => {\n      var useTasks = [];\n      while (openTasks.length > 0) {\n        state.events.active.down.next(true);\n        var innerTaskWithTime = ensureNotFalsy(openTasks.shift());\n\n        /**\n         * If the task came in before the last time we started the pull\n         * from the master, then we can drop the task.\n         */\n        if (innerTaskWithTime.time < lastTimeMasterChangesRequested) {\n          continue;\n        }\n        if (innerTaskWithTime.task === 'RESYNC') {\n          if (useTasks.length === 0) {\n            useTasks.push(innerTaskWithTime.task);\n            break;\n          } else {\n            break;\n          }\n        }\n        useTasks.push(innerTaskWithTime.task);\n      }\n      if (useTasks.length === 0) {\n        return;\n      }\n      if (useTasks[0] === 'RESYNC') {\n        return downstreamResyncOnce();\n      } else {\n        return downstreamProcessChanges(useTasks);\n      }\n    }).then(() => {\n      state.events.active.down.next(false);\n      if (!state.firstSyncDone.down.getValue() && !state.events.canceled.getValue()) {\n        state.firstSyncDone.down.next(true);\n      }\n    });\n  }\n  addNewTask('RESYNC');\n\n  /**\n   * If a write on the master happens, we have to trigger the downstream.\n   * Only do this if not canceled yet, otherwise firstValueFrom errors\n   * when running on a completed observable.\n   */\n  if (!state.events.canceled.getValue()) {\n    var sub = replicationHandler.masterChangeStream$.pipe(mergeMap(async ev => {\n      /**\n       * While a push is running, we have to delay all incoming\n       * events from the server to not mix up the replication state.\n       */\n      await firstValueFrom(state.events.active.up.pipe(filter(s => !s)));\n      return ev;\n    })).subscribe(task => {\n      state.stats.down.masterChangeStreamEmit = state.stats.down.masterChangeStreamEmit + 1;\n      addNewTask(task);\n    });\n    // unsubscribe when replication is canceled\n    firstValueFrom(state.events.canceled.pipe(filter(canceled => !!canceled))).then(() => sub.unsubscribe());\n  }\n\n  /**\n   * For faster performance, we directly start each write\n   * and then await all writes at the end.\n   */\n  var lastTimeMasterChangesRequested = -1;\n  async function downstreamResyncOnce() {\n    state.stats.down.downstreamResyncOnce = state.stats.down.downstreamResyncOnce + 1;\n    if (state.events.canceled.getValue()) {\n      return;\n    }\n    state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'down'));\n    var lastCheckpoint = await state.checkpointQueue;\n    var promises = [];\n    while (!state.events.canceled.getValue()) {\n      lastTimeMasterChangesRequested = timer++;\n      var downResult = await replicationHandler.masterChangesSince(lastCheckpoint, state.input.pullBatchSize);\n      if (downResult.documents.length === 0) {\n        break;\n      }\n      lastCheckpoint = stackCheckpoints([lastCheckpoint, downResult.checkpoint]);\n      promises.push(persistFromMaster(downResult.documents, lastCheckpoint));\n\n      /**\n       * By definition we stop pull when the pulled documents\n       * do not fill up the pullBatchSize because we\n       * can assume that the remote has no more documents.\n       */\n      if (downResult.documents.length < state.input.pullBatchSize) {\n        break;\n      }\n    }\n    await Promise.all(promises);\n  }\n  function downstreamProcessChanges(tasks) {\n    state.stats.down.downstreamProcessChanges = state.stats.down.downstreamProcessChanges + 1;\n    var docsOfAllTasks = [];\n    var lastCheckpoint = null;\n    tasks.forEach(task => {\n      if (task === 'RESYNC') {\n        throw new Error('SNH');\n      }\n      appendToArray(docsOfAllTasks, task.documents);\n      lastCheckpoint = stackCheckpoints([lastCheckpoint, task.checkpoint]);\n    });\n    return persistFromMaster(docsOfAllTasks, ensureNotFalsy(lastCheckpoint));\n  }\n\n  /**\n   * It can happen that the calls to masterChangesSince() or the changeStream()\n   * are way faster then how fast the documents can be persisted.\n   * Therefore we merge all incoming downResults into the nonPersistedFromMaster object\n   * and process them together if possible.\n   * This often bundles up single writes and improves performance\n   * by processing the documents in bulks.\n   */\n  var persistenceQueue = PROMISE_RESOLVE_VOID;\n  var nonPersistedFromMaster = {\n    docs: {}\n  };\n  function persistFromMaster(docs, checkpoint) {\n    var primaryPath = state.primaryPath;\n    state.stats.down.persistFromMaster = state.stats.down.persistFromMaster + 1;\n\n    /**\n     * Add the new docs to the non-persistent list\n     */\n    docs.forEach(docData => {\n      var docId = docData[primaryPath];\n      nonPersistedFromMaster.docs[docId] = docData;\n    });\n    nonPersistedFromMaster.checkpoint = checkpoint;\n\n    /**\n     * Run in the queue\n     * with all open documents from nonPersistedFromMaster.\n     */\n    persistenceQueue = persistenceQueue.then(() => {\n      var downDocsById = nonPersistedFromMaster.docs;\n      nonPersistedFromMaster.docs = {};\n      var useCheckpoint = nonPersistedFromMaster.checkpoint;\n      var docIds = Object.keys(downDocsById);\n      if (state.events.canceled.getValue() || docIds.length === 0) {\n        return PROMISE_RESOLVE_VOID;\n      }\n      var writeRowsToFork = [];\n      var writeRowsToForkById = {};\n      var writeRowsToMeta = {};\n      var useMetaWriteRows = [];\n      return Promise.all([state.input.forkInstance.findDocumentsById(docIds, true), getAssumedMasterState(state, docIds)]).then(([currentForkStateList, assumedMasterState]) => {\n        var currentForkState = new Map();\n        currentForkStateList.forEach(doc => currentForkState.set(doc[primaryPath], doc));\n        return Promise.all(docIds.map(async docId => {\n          var forkStateFullDoc = currentForkState.get(docId);\n          var forkStateDocData = forkStateFullDoc ? writeDocToDocState(forkStateFullDoc, state.hasAttachments, false) : undefined;\n          var masterState = downDocsById[docId];\n          var assumedMaster = assumedMasterState[docId];\n          if (assumedMaster && forkStateFullDoc && assumedMaster.metaDocument.isResolvedConflict === forkStateFullDoc._rev) {\n            /**\n             * The current fork state represents a resolved conflict\n             * that first must be send to the master in the upstream.\n             * All conflicts are resolved by the upstream.\n             */\n            // return PROMISE_RESOLVE_VOID;\n            await state.streamQueue.up;\n          }\n          var isAssumedMasterEqualToForkState = !assumedMaster || !forkStateDocData ? false : state.input.conflictHandler.isEqual(assumedMaster.docData, forkStateDocData, 'downstream-check-if-equal-0');\n          if (!isAssumedMasterEqualToForkState && assumedMaster && assumedMaster.docData._rev && forkStateFullDoc && forkStateFullDoc._meta[state.input.identifier] && getHeightOfRevision(forkStateFullDoc._rev) === forkStateFullDoc._meta[state.input.identifier]) {\n            isAssumedMasterEqualToForkState = true;\n          }\n          if (forkStateFullDoc && assumedMaster && isAssumedMasterEqualToForkState === false || forkStateFullDoc && !assumedMaster) {\n            /**\n             * We have a non-upstream-replicated\n             * local write to the fork.\n             * This means we ignore the downstream of this document\n             * because anyway the upstream will first resolve the conflict.\n             */\n            return PROMISE_RESOLVE_VOID;\n          }\n          var areStatesExactlyEqual = !forkStateDocData ? false : state.input.conflictHandler.isEqual(masterState, forkStateDocData, 'downstream-check-if-equal-1');\n          if (forkStateDocData && areStatesExactlyEqual) {\n            /**\n             * Document states are exactly equal.\n             * This can happen when the replication is shut down\n             * unexpected like when the user goes offline.\n             *\n             * Only when the assumedMaster is different from the forkState,\n             * we have to patch the document in the meta instance.\n             */\n            if (!assumedMaster || isAssumedMasterEqualToForkState === false) {\n              useMetaWriteRows.push(await getMetaWriteRow(state, forkStateDocData, assumedMaster ? assumedMaster.metaDocument : undefined));\n            }\n            return PROMISE_RESOLVE_VOID;\n          }\n\n          /**\n           * All other master states need to be written to the forkInstance\n           * and metaInstance.\n           */\n          var newForkState = Object.assign({}, masterState, forkStateFullDoc ? {\n            _meta: flatClone(forkStateFullDoc._meta),\n            _attachments: state.hasAttachments && masterState._attachments ? masterState._attachments : {},\n            _rev: getDefaultRevision()\n          } : {\n            _meta: {\n              lwt: now()\n            },\n            _rev: getDefaultRevision(),\n            _attachments: state.hasAttachments && masterState._attachments ? masterState._attachments : {}\n          });\n          /**\n           * If the remote works with revisions,\n           * we store the height of the next fork-state revision\n           * inside of the documents meta data.\n           * By doing so we can filter it out in the upstream\n           * and detect the document as being equal to master or not.\n           * This is used for example in the CouchDB replication plugin.\n           */\n          if (masterState._rev) {\n            var nextRevisionHeight = !forkStateFullDoc ? 1 : getHeightOfRevision(forkStateFullDoc._rev) + 1;\n            newForkState._meta[state.input.identifier] = nextRevisionHeight;\n            if (state.input.keepMeta) {\n              newForkState._rev = masterState._rev;\n            }\n          }\n          if (state.input.keepMeta && masterState._meta) {\n            newForkState._meta = masterState._meta;\n          }\n          var forkWriteRow = {\n            previous: forkStateFullDoc,\n            document: newForkState\n          };\n          forkWriteRow.document._rev = forkWriteRow.document._rev ? forkWriteRow.document._rev : createRevision(identifierHash, forkWriteRow.previous);\n          writeRowsToFork.push(forkWriteRow);\n          writeRowsToForkById[docId] = forkWriteRow;\n          writeRowsToMeta[docId] = await getMetaWriteRow(state, masterState, assumedMaster ? assumedMaster.metaDocument : undefined);\n        }));\n      }).then(async () => {\n        if (writeRowsToFork.length > 0) {\n          return state.input.forkInstance.bulkWrite(writeRowsToFork, await state.downstreamBulkWriteFlag).then(forkWriteResult => {\n            var success = getWrittenDocumentsFromBulkWriteResponse(state.primaryPath, writeRowsToFork, forkWriteResult);\n            success.forEach(doc => {\n              var docId = doc[primaryPath];\n              state.events.processed.down.next(writeRowsToForkById[docId]);\n              useMetaWriteRows.push(writeRowsToMeta[docId]);\n            });\n            var mustThrow;\n            forkWriteResult.error.forEach(error => {\n              /**\n               * We do not have to care about downstream conflict errors here\n               * because on conflict, it will be solved locally and result in another write.\n               */\n              if (error.status === 409) {\n                return;\n              }\n              // other non-conflict errors must be handled\n              var throwMe = newRxError('RC_PULL', {\n                writeError: error\n              });\n              state.events.error.next(throwMe);\n              mustThrow = throwMe;\n            });\n            if (mustThrow) {\n              throw mustThrow;\n            }\n          });\n        }\n      }).then(() => {\n        if (useMetaWriteRows.length > 0) {\n          return state.input.metaInstance.bulkWrite(stripAttachmentsDataFromMetaWriteRows(state, useMetaWriteRows), 'replication-down-write-meta').then(metaWriteResult => {\n            metaWriteResult.error.forEach(writeError => {\n              state.events.error.next(newRxError('RC_PULL', {\n                id: writeError.documentId,\n                writeError\n              }));\n            });\n          });\n        }\n      }).then(() => {\n        /**\n         * For better performance we do not await checkpoint writes,\n         * but to ensure order on parallel checkpoint writes,\n         * we have to use a queue.\n         */\n        setCheckpoint(state, 'down', useCheckpoint);\n      });\n    }).catch(unhandledError => state.events.error.next(unhandledError));\n    return persistenceQueue;\n  }\n}\n", "import { getDefaultRevision, createRevision, now, flatClone } from \"../plugins/utils/index.js\";\n\n/**\n * Resolves a conflict error or determines that the given document states are equal.\n * Returns the resolved document that must be written to the fork.\n * Then the new document state can be pushed upstream.\n * If document is not in conflict, returns undefined.\n * If error is non-409, it throws an error.\n * Conflicts are only solved in the upstream, never in the downstream.\n */\nexport async function resolveConflictError(state, input, forkState) {\n  var conflictHandler = state.input.conflictHandler;\n  var isEqual = conflictHandler.isEqual(input.realMasterState, input.newDocumentState, 'replication-resolve-conflict');\n  if (isEqual) {\n    /**\n     * Documents are equal,\n     * so this is not a conflict -> do nothing.\n     */\n    return undefined;\n  } else {\n    var resolved = await conflictHandler.resolve(input, 'replication-resolve-conflict');\n    /**\n     * We have a resolved conflict,\n     * use the resolved document data.\n     */\n    var resolvedDoc = Object.assign({}, resolved, {\n      /**\n       * Because the resolved conflict is written to the fork,\n       * we have to keep/update the forks _meta data, not the masters.\n       */\n      _meta: flatClone(forkState._meta),\n      _rev: getDefaultRevision(),\n      _attachments: flatClone(forkState._attachments)\n    });\n    resolvedDoc._meta.lwt = now();\n    resolvedDoc._rev = createRevision(await state.checkpointKey, forkState);\n    return resolvedDoc;\n  }\n}\n", "import { newRxError } from \"../../rx-error.js\";\nimport { ensureNotFalsy } from \"../utils/index.js\";\nexport function ensureSchemaSupportsAttachments(doc) {\n  var schemaJson = doc.collection.schema.jsonSchema;\n  if (!schemaJson.attachments) {\n    throw newRxError('AT1', {\n      link: 'https://pubkey.github.io/rxdb/rx-attachment.html'\n    });\n  }\n}\nexport function assignMethodsToAttachment(attachment) {\n  Object.entries(attachment.doc.collection.attachments).forEach(([funName, fun]) => {\n    Object.defineProperty(attachment, funName, {\n      get: () => fun.bind(attachment)\n    });\n  });\n}\n\n/**\n * Fill up the missing attachment.data of the newDocument\n * so that the new document can be send to somewhere else\n * which could then receive all required attachments data\n * that it did not have before.\n */\nexport async function fillWriteDataForAttachmentsChange(primaryPath, storageInstance, newDocument, originalDocument) {\n  if (!newDocument._attachments || originalDocument && !originalDocument._attachments) {\n    throw new Error('_attachments missing');\n  }\n  var docId = newDocument[primaryPath];\n  var originalAttachmentsIds = new Set(originalDocument && originalDocument._attachments ? Object.keys(originalDocument._attachments) : []);\n  await Promise.all(Object.entries(newDocument._attachments).map(async ([key, value]) => {\n    if ((!originalAttachmentsIds.has(key) || originalDocument && ensureNotFalsy(originalDocument._attachments)[key].digest !== value.digest) && !value.data) {\n      var attachmentDataString = await storageInstance.getAttachmentData(docId, key, value.digest);\n      value.data = attachmentDataString;\n    }\n  }));\n  return newDocument;\n}\n", "import { map } from 'rxjs';\nimport { blobToBase64String, blobToString, createBlobFromBase64, flatClone, getBlobSize, PROMISE_RESOLVE_VOID } from \"../../plugins/utils/index.js\";\nimport { assignMethodsToAttachment, ensureSchemaSupportsAttachments } from \"./attachments-utils.js\";\n\n/**\n * an RxAttachment is basically just the attachment-stub\n * wrapped so that you can access the attachment-data\n */\nexport var RxAttachment = /*#__PURE__*/function () {\n  function RxAttachment({\n    doc,\n    id,\n    type,\n    length,\n    digest\n  }) {\n    this.doc = doc;\n    this.id = id;\n    this.type = type;\n    this.length = length;\n    this.digest = digest;\n    assignMethodsToAttachment(this);\n  }\n  var _proto = RxAttachment.prototype;\n  _proto.remove = function remove() {\n    return this.doc.collection.incrementalWriteQueue.addWrite(this.doc._data, docWriteData => {\n      delete docWriteData._attachments[this.id];\n      return docWriteData;\n    }).then(() => {});\n  }\n\n  /**\n   * returns the data for the attachment\n   */;\n  _proto.getData = async function getData() {\n    var plainDataBase64 = await this.getDataBase64();\n    var ret = await createBlobFromBase64(plainDataBase64, this.type);\n    return ret;\n  };\n  _proto.getStringData = async function getStringData() {\n    var data = await this.getData();\n    var asString = await blobToString(data);\n    return asString;\n  };\n  _proto.getDataBase64 = async function getDataBase64() {\n    var plainDataBase64 = await this.doc.collection.storageInstance.getAttachmentData(this.doc.primary, this.id, this.digest);\n    return plainDataBase64;\n  };\n  return RxAttachment;\n}();\nexport function fromStorageInstanceResult(id, attachmentData, rxDocument) {\n  return new RxAttachment({\n    doc: rxDocument,\n    id,\n    type: attachmentData.type,\n    length: attachmentData.length,\n    digest: attachmentData.digest\n  });\n}\nexport async function putAttachment(attachmentData) {\n  ensureSchemaSupportsAttachments(this);\n  var dataSize = getBlobSize(attachmentData.data);\n  var dataString = await blobToBase64String(attachmentData.data);\n  return this.putAttachmentBase64({\n    id: attachmentData.id,\n    length: dataSize,\n    type: attachmentData.type,\n    data: dataString\n  });\n}\nexport async function putAttachmentBase64(attachmentData) {\n  ensureSchemaSupportsAttachments(this);\n  var digest = await this.collection.database.hashFunction(attachmentData.data);\n  var id = attachmentData.id;\n  var type = attachmentData.type;\n  var data = attachmentData.data;\n  return this.collection.incrementalWriteQueue.addWrite(this._data, docWriteData => {\n    docWriteData = flatClone(docWriteData);\n    docWriteData._attachments = flatClone(docWriteData._attachments);\n    docWriteData._attachments[id] = {\n      length: attachmentData.length,\n      type,\n      data,\n      digest\n    };\n    return docWriteData;\n  }).then(writeResult => {\n    var newDocument = this.collection._docCache.getCachedRxDocument(writeResult);\n    var attachmentDataOfId = writeResult._attachments[id];\n    var attachment = fromStorageInstanceResult(id, attachmentDataOfId, newDocument);\n    return attachment;\n  });\n}\n\n/**\n * get an attachment of the document by its id\n */\nexport function getAttachment(id) {\n  ensureSchemaSupportsAttachments(this);\n  var docData = this._data;\n  if (!docData._attachments || !docData._attachments[id]) return null;\n  var attachmentData = docData._attachments[id];\n  var attachment = fromStorageInstanceResult(id, attachmentData, this);\n  return attachment;\n}\n\n/**\n * returns all attachments of the document\n */\nexport function allAttachments() {\n  ensureSchemaSupportsAttachments(this);\n  var docData = this._data;\n\n  // if there are no attachments, the field is missing\n  if (!docData._attachments) {\n    return [];\n  }\n  return Object.keys(docData._attachments).map(id => {\n    return fromStorageInstanceResult(id, docData._attachments[id], this);\n  });\n}\nexport async function preMigrateDocument(data) {\n  var attachments = data.docData._attachments;\n  if (attachments) {\n    var newAttachments = {};\n    await Promise.all(Object.keys(attachments).map(async attachmentId => {\n      var attachment = attachments[attachmentId];\n      var docPrimary = data.docData[data.oldCollection.schema.primaryPath];\n      var rawAttachmentData = await data.oldCollection.storageInstance.getAttachmentData(docPrimary, attachmentId, attachment.digest);\n      var digest = await data.oldCollection.database.hashFunction(rawAttachmentData);\n      newAttachments[attachmentId] = {\n        length: attachment.length,\n        type: attachment.type,\n        data: rawAttachmentData,\n        digest\n      };\n    }));\n\n    /**\n     * Hooks mutate the input\n     * instead of returning stuff\n     */\n    data.docData._attachments = newAttachments;\n  }\n}\nexport function postMigrateDocument(_action) {\n  /**\n   * No longer needed because\n   * we store the attachments data buffers directly in the document.\n   */\n  return PROMISE_RESOLVE_VOID;\n}\nexport var RxDBAttachmentsPlugin = {\n  name: 'attachments',\n  rxdb: true,\n  prototypes: {\n    RxDocument: proto => {\n      proto.putAttachment = putAttachment;\n      proto.putAttachmentBase64 = putAttachmentBase64;\n      proto.getAttachment = getAttachment;\n      proto.allAttachments = allAttachments;\n      Object.defineProperty(proto, 'allAttachments$', {\n        get: function allAttachments$() {\n          return this.$.pipe(map(rxDocument => Object.entries(rxDocument.toJSON(true)._attachments)), map(entries => {\n            return entries.map(([id, attachmentData]) => {\n              return fromStorageInstanceResult(id, attachmentData, this);\n            });\n          }));\n        }\n      });\n    }\n  },\n  overwritable: {},\n  hooks: {\n    preMigrateDocument: {\n      after: preMigrateDocument\n    },\n    postMigrateDocument: {\n      after: postMigrateDocument\n    }\n  }\n};\nexport * from \"./attachments-utils.js\";\n", "import { firstValueFrom, filter } from 'rxjs';\nimport { getChangedDocumentsSince, getWrittenDocumentsFromBulkWriteResponse, stackCheckpoints } from \"../rx-storage-helper.js\";\nimport { appendToArray, batchArray, clone, ensureNotFalsy, getHeightOfRevision, PROMISE_RESOLVE_FALSE } from \"../plugins/utils/index.js\";\nimport { getLastCheckpointDoc, setCheckpoint } from \"./checkpoint.js\";\nimport { resolveConflictError } from \"./conflicts.js\";\nimport { stripAttachmentsDataFromMetaWriteRows, writeDocToDocState } from \"./helper.js\";\nimport { getAssumedMasterState, getMetaWriteRow } from \"./meta-instance.js\";\nimport { fillWriteDataForAttachmentsChange } from \"../plugins/attachments/index.js\";\nimport { newRxError } from \"../rx-error.js\";\n\n/**\n * Writes all document changes from the fork to the master.\n * The upstream runs on two modes:\n * - For initial replication, a checkpoint-iteration is used\n * - For ongoing local writes, we just subscribe to the changeStream of the fork.\n *   In contrast to the master, the fork can be assumed to never loose connection,\n *   so we do not have to prepare for missed out events.\n */\nexport async function startReplicationUpstream(state) {\n  if (state.input.initialCheckpoint && state.input.initialCheckpoint.upstream) {\n    var checkpointDoc = await getLastCheckpointDoc(state, 'up');\n    if (!checkpointDoc) {\n      await setCheckpoint(state, 'up', state.input.initialCheckpoint.upstream);\n    }\n  }\n  var replicationHandler = state.input.replicationHandler;\n  state.streamQueue.up = state.streamQueue.up.then(() => {\n    return upstreamInitialSync().then(() => {\n      return processTasks();\n    });\n  });\n\n  // used to detect which tasks etc can in it at which order.\n  var timer = 0;\n  var initialSyncStartTime = -1;\n  var openTasks = [];\n  var persistenceQueue = PROMISE_RESOLVE_FALSE;\n  var nonPersistedFromMaster = {\n    docs: {}\n  };\n  var sub = state.input.forkInstance.changeStream().subscribe(eventBulk => {\n    if (state.events.paused.getValue()) {\n      return;\n    }\n    state.stats.up.forkChangeStreamEmit = state.stats.up.forkChangeStreamEmit + 1;\n    openTasks.push({\n      task: eventBulk,\n      time: timer++\n    });\n    if (!state.events.active.up.getValue()) {\n      state.events.active.up.next(true);\n    }\n    if (state.input.waitBeforePersist) {\n      return state.input.waitBeforePersist().then(() => processTasks());\n    } else {\n      return processTasks();\n    }\n  });\n  var subResync = replicationHandler.masterChangeStream$.pipe(filter(ev => ev === 'RESYNC')).subscribe(() => {\n    openTasks.push({\n      task: 'RESYNC',\n      time: timer++\n    });\n    processTasks();\n  });\n\n  // unsubscribe when replication is canceled\n  firstValueFrom(state.events.canceled.pipe(filter(canceled => !!canceled))).then(() => {\n    sub.unsubscribe();\n    subResync.unsubscribe();\n  });\n  async function upstreamInitialSync() {\n    state.stats.up.upstreamInitialSync = state.stats.up.upstreamInitialSync + 1;\n    if (state.events.canceled.getValue()) {\n      return;\n    }\n    state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'up'));\n    var lastCheckpoint = await state.checkpointQueue;\n    var promises = new Set();\n    var _loop = async function () {\n      initialSyncStartTime = timer++;\n\n      /**\n       * Throttle the calls to\n       * forkInstance.getChangedDocumentsSince() so that\n       * if the pushing to the remote is slower compared to the\n       * pulling out of forkInstance, we do not block the UI too much\n       * and have a big memory spike with all forkInstance documents.\n       */\n      if (promises.size > 3) {\n        await Promise.race(Array.from(promises));\n      }\n      var upResult = await getChangedDocumentsSince(state.input.forkInstance, state.input.pushBatchSize, lastCheckpoint);\n      if (upResult.documents.length === 0) {\n        return 1; // break\n      }\n      lastCheckpoint = stackCheckpoints([lastCheckpoint, upResult.checkpoint]);\n      var promise = persistToMaster(upResult.documents, ensureNotFalsy(lastCheckpoint));\n      promises.add(promise);\n      promise.catch().then(() => promises.delete(promise));\n    };\n    while (!state.events.canceled.getValue()) {\n      if (await _loop()) break;\n    }\n\n    /**\n     * If we had conflicts during the initial sync,\n     * it means that we likely have new writes to the fork\n     * and so we have to run the initial sync again to upstream these new writes.\n     */\n    var resolvedPromises = await Promise.all(promises);\n    var hadConflicts = resolvedPromises.find(r => !!r);\n    if (hadConflicts) {\n      await upstreamInitialSync();\n    } else if (!state.firstSyncDone.up.getValue() && !state.events.canceled.getValue()) {\n      state.firstSyncDone.up.next(true);\n    }\n  }\n\n  /**\n   * Takes all open tasks an processes them at once.\n   */\n  function processTasks() {\n    if (state.events.canceled.getValue() || openTasks.length === 0) {\n      state.events.active.up.next(false);\n      return;\n    }\n    state.stats.up.processTasks = state.stats.up.processTasks + 1;\n    state.events.active.up.next(true);\n    state.streamQueue.up = state.streamQueue.up.then(async () => {\n      /**\n       * Merge/filter all open tasks\n       */\n      var docs = [];\n      var checkpoint;\n      while (openTasks.length > 0) {\n        var taskWithTime = ensureNotFalsy(openTasks.shift());\n        /**\n         * If the task came in before the last time the initial sync fetching\n         * has run, we can ignore the task because the initial sync already processed\n         * these documents.\n         */\n        if (taskWithTime.time < initialSyncStartTime) {\n          continue;\n        }\n        if (taskWithTime.task === 'RESYNC') {\n          state.events.active.up.next(false);\n          await upstreamInitialSync();\n          return;\n        }\n\n        /**\n         * If the task came from the downstream, we can ignore these documents\n         * because we know they are replicated already.\n         * But even if they can be ignored, we later have to call persistToMaster()\n         * to have the correct checkpoint set.\n         */\n        if (taskWithTime.task.context !== (await state.downstreamBulkWriteFlag)) {\n          appendToArray(docs, taskWithTime.task.events.map(r => {\n            return r.documentData;\n          }));\n        }\n        checkpoint = stackCheckpoints([checkpoint, taskWithTime.task.checkpoint]);\n      }\n      await persistToMaster(docs, checkpoint);\n\n      // might have got more tasks while running persistToMaster()\n      if (openTasks.length === 0) {\n        state.events.active.up.next(false);\n      } else {\n        return processTasks();\n      }\n    });\n  }\n\n  /**\n   * Returns true if had conflicts,\n   * false if not.\n   */\n  function persistToMaster(docs, checkpoint) {\n    state.stats.up.persistToMaster = state.stats.up.persistToMaster + 1;\n\n    /**\n     * Add the new docs to the non-persistent list\n     */\n    docs.forEach(docData => {\n      var docId = docData[state.primaryPath];\n      nonPersistedFromMaster.docs[docId] = docData;\n    });\n    nonPersistedFromMaster.checkpoint = checkpoint;\n    persistenceQueue = persistenceQueue.then(async () => {\n      if (state.events.canceled.getValue()) {\n        return false;\n      }\n      var upDocsById = nonPersistedFromMaster.docs;\n      nonPersistedFromMaster.docs = {};\n      var useCheckpoint = nonPersistedFromMaster.checkpoint;\n      var docIds = Object.keys(upDocsById);\n      /**\n       * Even if we do not have anything to push,\n       * we still have to store the up-checkpoint.\n       * This ensures that when many documents have been pulled\n       * from the remote (that do not have to be pushed again),\n       * we continue at the correct position and do not have to load\n       * these documents from the storage again when the replication is restarted.\n       */\n      function rememberCheckpointBeforeReturn() {\n        return setCheckpoint(state, 'up', useCheckpoint);\n      }\n      ;\n      if (docIds.length === 0) {\n        rememberCheckpointBeforeReturn();\n        return false;\n      }\n      var assumedMasterState = await getAssumedMasterState(state, docIds);\n      var writeRowsToMaster = {};\n      var writeRowsToMasterIds = [];\n      var writeRowsToMeta = {};\n      var forkStateById = {};\n      await Promise.all(docIds.map(async docId => {\n        var fullDocData = upDocsById[docId];\n        forkStateById[docId] = fullDocData;\n        var docData = writeDocToDocState(fullDocData, state.hasAttachments, !!state.input.keepMeta);\n        var assumedMasterDoc = assumedMasterState[docId];\n\n        /**\n         * If the master state is equal to the\n         * fork state, we can assume that the document state is already\n         * replicated.\n         */\n        if (assumedMasterDoc &&\n        // if the isResolvedConflict is correct, we do not have to compare the documents.\n        assumedMasterDoc.metaDocument.isResolvedConflict !== fullDocData._rev && state.input.conflictHandler.isEqual(assumedMasterDoc.docData, docData, 'upstream-check-if-equal') || (\n        /**\n         * If the master works with _rev fields,\n         * we use that to check if our current doc state\n         * is different from the assumedMasterDoc.\n         */\n\n        assumedMasterDoc && assumedMasterDoc.docData._rev && getHeightOfRevision(fullDocData._rev) === fullDocData._meta[state.input.identifier])) {\n          return;\n        }\n        writeRowsToMasterIds.push(docId);\n        writeRowsToMaster[docId] = {\n          assumedMasterState: assumedMasterDoc ? assumedMasterDoc.docData : undefined,\n          newDocumentState: docData\n        };\n        writeRowsToMeta[docId] = await getMetaWriteRow(state, docData, assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined);\n      }));\n      if (writeRowsToMasterIds.length === 0) {\n        rememberCheckpointBeforeReturn();\n        return false;\n      }\n      var writeRowsArray = Object.values(writeRowsToMaster);\n      var conflictIds = new Set();\n      var conflictsById = {};\n\n      /**\n       * To always respect the push.batchSize,\n       * we have to split the write rows into batches\n       * to ensure that replicationHandler.masterWrite() is never\n       * called with more documents than what the batchSize limits.\n       */\n      var writeBatches = batchArray(writeRowsArray, state.input.pushBatchSize);\n      await Promise.all(writeBatches.map(async writeBatch => {\n        // enhance docs with attachments\n        if (state.hasAttachments) {\n          await Promise.all(writeBatch.map(async row => {\n            row.newDocumentState = await fillWriteDataForAttachmentsChange(state.primaryPath, state.input.forkInstance, clone(row.newDocumentState), row.assumedMasterState);\n          }));\n        }\n        var masterWriteResult = await replicationHandler.masterWrite(writeBatch);\n        masterWriteResult.forEach(conflictDoc => {\n          var id = conflictDoc[state.primaryPath];\n          conflictIds.add(id);\n          conflictsById[id] = conflictDoc;\n        });\n      }));\n      var useWriteRowsToMeta = [];\n      writeRowsToMasterIds.forEach(docId => {\n        if (!conflictIds.has(docId)) {\n          state.events.processed.up.next(writeRowsToMaster[docId]);\n          useWriteRowsToMeta.push(writeRowsToMeta[docId]);\n        }\n      });\n      if (state.events.canceled.getValue()) {\n        return false;\n      }\n      if (useWriteRowsToMeta.length > 0) {\n        await state.input.metaInstance.bulkWrite(stripAttachmentsDataFromMetaWriteRows(state, useWriteRowsToMeta), 'replication-up-write-meta');\n        // TODO what happens when we have conflicts here?\n      }\n\n      /**\n       * Resolve conflicts by writing a new document\n       * state to the fork instance and the 'real' master state\n       * to the meta instance.\n       * Non-409 errors will be detected by resolveConflictError()\n       */\n      var hadConflictWrites = false;\n      if (conflictIds.size > 0) {\n        state.stats.up.persistToMasterHadConflicts = state.stats.up.persistToMasterHadConflicts + 1;\n        var conflictWriteFork = [];\n        var conflictWriteMeta = {};\n        await Promise.all(Object.entries(conflictsById).map(([docId, realMasterState]) => {\n          var writeToMasterRow = writeRowsToMaster[docId];\n          var input = {\n            newDocumentState: writeToMasterRow.newDocumentState,\n            assumedMasterState: writeToMasterRow.assumedMasterState,\n            realMasterState\n          };\n          return resolveConflictError(state, input, forkStateById[docId]).then(async resolved => {\n            if (resolved) {\n              state.events.resolvedConflicts.next({\n                input,\n                output: resolved\n              });\n              conflictWriteFork.push({\n                previous: forkStateById[docId],\n                document: resolved\n              });\n              var assumedMasterDoc = assumedMasterState[docId];\n              conflictWriteMeta[docId] = await getMetaWriteRow(state, ensureNotFalsy(realMasterState), assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined, resolved._rev);\n            }\n          });\n        }));\n        if (conflictWriteFork.length > 0) {\n          hadConflictWrites = true;\n          state.stats.up.persistToMasterConflictWrites = state.stats.up.persistToMasterConflictWrites + 1;\n          var forkWriteResult = await state.input.forkInstance.bulkWrite(conflictWriteFork, 'replication-up-write-conflict');\n          var mustThrow;\n          forkWriteResult.error.forEach(error => {\n            /**\n             * Conflict-Errors in the forkWriteResult must not be handled\n             * because they have been caused by a write to the forkInstance\n             * in between which will anyway trigger a new upstream cycle\n             * that will then resolved the conflict again.\n             */\n            if (error.status === 409) {\n              return;\n            }\n            // other non-conflict errors must be handled\n            var throwMe = newRxError('RC_PUSH', {\n              writeError: error\n            });\n            state.events.error.next(throwMe);\n            mustThrow = throwMe;\n          });\n          if (mustThrow) {\n            throw mustThrow;\n          }\n          var useMetaWrites = [];\n          var success = getWrittenDocumentsFromBulkWriteResponse(state.primaryPath, conflictWriteFork, forkWriteResult);\n          success.forEach(docData => {\n            var docId = docData[state.primaryPath];\n            useMetaWrites.push(conflictWriteMeta[docId]);\n          });\n          if (useMetaWrites.length > 0) {\n            await state.input.metaInstance.bulkWrite(stripAttachmentsDataFromMetaWriteRows(state, useMetaWrites), 'replication-up-write-conflict-meta');\n          }\n          // TODO what to do with conflicts while writing to the metaInstance?\n        }\n      }\n\n      /**\n       * For better performance we do not await checkpoint writes,\n       * but to ensure order on parallel checkpoint writes,\n       * we have to use a queue.\n       */\n      rememberCheckpointBeforeReturn();\n      return hadConflictWrites;\n    }).catch(unhandledError => {\n      state.events.error.next(unhandledError);\n      return false;\n    });\n    return persistenceQueue;\n  }\n}\n", "/**\n * These files contain the replication protocol.\n * It can be used to replicated RxStorageInstances or RxCollections\n * or even to do a client(s)-server replication.\n */\n\nimport { BehaviorSubject, combineLatest, filter, firstValueFrom, mergeMap, Subject } from 'rxjs';\nimport { getPrimaryFieldOfPrimaryKey } from \"../rx-schema-helper.js\";\nimport { clone, ensureNotFalsy, flatClone, PROMISE_RESOLVE_VOID } from \"../plugins/utils/index.js\";\nimport { getCheckpointKey } from \"./checkpoint.js\";\nimport { startReplicationDownstream } from \"./downstream.js\";\nimport { docStateToWriteDoc, getUnderlyingPersistentStorage, writeDocToDocState } from \"./helper.js\";\nimport { startReplicationUpstream } from \"./upstream.js\";\nimport { fillWriteDataForAttachmentsChange } from \"../plugins/attachments/index.js\";\nimport { getChangedDocumentsSince } from \"../rx-storage-helper.js\";\nimport { newRxError } from \"../rx-error.js\";\nexport * from \"./checkpoint.js\";\nexport * from \"./downstream.js\";\nexport * from \"./upstream.js\";\nexport * from \"./meta-instance.js\";\nexport * from \"./conflicts.js\";\nexport * from \"./helper.js\";\nexport * from \"./default-conflict-handler.js\";\nexport function replicateRxStorageInstance(input) {\n  input = flatClone(input);\n  input.forkInstance = getUnderlyingPersistentStorage(input.forkInstance);\n  input.metaInstance = getUnderlyingPersistentStorage(input.metaInstance);\n  var checkpointKeyPromise = getCheckpointKey(input);\n  var state = {\n    primaryPath: getPrimaryFieldOfPrimaryKey(input.forkInstance.schema.primaryKey),\n    hasAttachments: !!input.forkInstance.schema.attachments,\n    input,\n    checkpointKey: checkpointKeyPromise,\n    downstreamBulkWriteFlag: checkpointKeyPromise.then(checkpointKey => 'replication-downstream-' + checkpointKey),\n    events: {\n      canceled: new BehaviorSubject(false),\n      paused: new BehaviorSubject(false),\n      active: {\n        down: new BehaviorSubject(true),\n        up: new BehaviorSubject(true)\n      },\n      processed: {\n        down: new Subject(),\n        up: new Subject()\n      },\n      resolvedConflicts: new Subject(),\n      error: new Subject()\n    },\n    stats: {\n      down: {\n        addNewTask: 0,\n        downstreamProcessChanges: 0,\n        downstreamResyncOnce: 0,\n        masterChangeStreamEmit: 0,\n        persistFromMaster: 0\n      },\n      up: {\n        forkChangeStreamEmit: 0,\n        persistToMaster: 0,\n        persistToMasterConflictWrites: 0,\n        persistToMasterHadConflicts: 0,\n        processTasks: 0,\n        upstreamInitialSync: 0\n      }\n    },\n    firstSyncDone: {\n      down: new BehaviorSubject(false),\n      up: new BehaviorSubject(false)\n    },\n    streamQueue: {\n      down: PROMISE_RESOLVE_VOID,\n      up: PROMISE_RESOLVE_VOID\n    },\n    checkpointQueue: PROMISE_RESOLVE_VOID,\n    lastCheckpointDoc: {}\n  };\n  startReplicationDownstream(state);\n  startReplicationUpstream(state);\n  return state;\n}\nexport function awaitRxStorageReplicationFirstInSync(state) {\n  return firstValueFrom(combineLatest([state.firstSyncDone.down.pipe(filter(v => !!v)), state.firstSyncDone.up.pipe(filter(v => !!v))])).then(() => {});\n}\nexport function awaitRxStorageReplicationInSync(replicationState) {\n  return Promise.all([replicationState.streamQueue.up, replicationState.streamQueue.down, replicationState.checkpointQueue]);\n}\nexport async function awaitRxStorageReplicationIdle(state) {\n  await awaitRxStorageReplicationFirstInSync(state);\n  while (true) {\n    var {\n      down,\n      up\n    } = state.streamQueue;\n    await Promise.all([up, down]);\n    /**\n     * If the Promises have not been reassigned\n     * after awaiting them, we know that the replication\n     * is in idle state at this point in time.\n     */\n    if (down === state.streamQueue.down && up === state.streamQueue.up) {\n      return;\n    }\n  }\n}\nexport function rxStorageInstanceToReplicationHandler(instance, conflictHandler, databaseInstanceToken,\n/**\n * If set to true,\n * the _meta.lwt from the pushed documents is kept.\n * (Used in the migration to ensure checkpoints are still valid)\n */\nkeepMeta = false) {\n  instance = getUnderlyingPersistentStorage(instance);\n  var hasAttachments = !!instance.schema.attachments;\n  var primaryPath = getPrimaryFieldOfPrimaryKey(instance.schema.primaryKey);\n  var replicationHandler = {\n    masterChangeStream$: instance.changeStream().pipe(mergeMap(async eventBulk => {\n      var ret = {\n        checkpoint: eventBulk.checkpoint,\n        documents: await Promise.all(eventBulk.events.map(async event => {\n          var docData = writeDocToDocState(event.documentData, hasAttachments, keepMeta);\n          if (hasAttachments) {\n            docData = await fillWriteDataForAttachmentsChange(primaryPath, instance, clone(docData),\n            /**\n             * Notice that the master never knows\n             * the client state of the document.\n             * Therefore we always send all attachments data.\n             */\n            undefined);\n          }\n          return docData;\n        }))\n      };\n      return ret;\n    })),\n    masterChangesSince(checkpoint, batchSize) {\n      return getChangedDocumentsSince(instance, batchSize, checkpoint).then(async result => {\n        return {\n          checkpoint: result.documents.length > 0 ? result.checkpoint : checkpoint,\n          documents: await Promise.all(result.documents.map(async plainDocumentData => {\n            var docData = writeDocToDocState(plainDocumentData, hasAttachments, keepMeta);\n            if (hasAttachments) {\n              docData = await fillWriteDataForAttachmentsChange(primaryPath, instance, clone(docData),\n              /**\n               * Notice the the master never knows\n               * the client state of the document.\n               * Therefore we always send all attachments data.\n               */\n              undefined);\n            }\n            return docData;\n          }))\n        };\n      });\n    },\n    async masterWrite(rows) {\n      var rowById = {};\n      rows.forEach(row => {\n        var docId = row.newDocumentState[primaryPath];\n        rowById[docId] = row;\n      });\n      var ids = Object.keys(rowById);\n      var masterDocsStateList = await instance.findDocumentsById(ids, true);\n      var masterDocsState = new Map();\n      masterDocsStateList.forEach(doc => masterDocsState.set(doc[primaryPath], doc));\n      var conflicts = [];\n      var writeRows = [];\n      await Promise.all(Object.entries(rowById).map(([id, row]) => {\n        var masterState = masterDocsState.get(id);\n        if (!masterState) {\n          writeRows.push({\n            document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState)\n          });\n        } else if (masterState && !row.assumedMasterState) {\n          conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));\n        } else if (conflictHandler.isEqual(writeDocToDocState(masterState, hasAttachments, keepMeta), ensureNotFalsy(row.assumedMasterState), 'rxStorageInstanceToReplicationHandler-masterWrite') === true) {\n          writeRows.push({\n            previous: masterState,\n            document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState, masterState)\n          });\n        } else {\n          conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));\n        }\n      }));\n      if (writeRows.length > 0) {\n        var result = await instance.bulkWrite(writeRows, 'replication-master-write');\n        result.error.forEach(err => {\n          if (err.status !== 409) {\n            throw newRxError('SNH', {\n              name: 'non conflict error',\n              error: err\n            });\n          } else {\n            conflicts.push(writeDocToDocState(ensureNotFalsy(err.documentInDb), hasAttachments, keepMeta));\n          }\n        });\n      }\n      return conflicts;\n    }\n  };\n  return replicationHandler;\n}\nexport async function cancelRxStorageReplication(replicationState) {\n  replicationState.events.canceled.next(true);\n  replicationState.events.active.up.complete();\n  replicationState.events.active.down.complete();\n  replicationState.events.processed.up.complete();\n  replicationState.events.processed.down.complete();\n  replicationState.events.resolvedConflicts.complete();\n  replicationState.events.canceled.complete();\n  await replicationState.checkpointQueue;\n}\n"],
  "mappings": "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",
  "names": ["RxAttachment"]
}
